<h1>Selectors Level 4</h1>
<pre class='metadata'>
Group: CSSWG
Shortname: selectors
Level: 4
Status: ED
ED: http://dev.w3.org/csswg/selectors
TR: http://www.w3.org/TR/selectors/
Previous Version: http://www.w3.org/TR/2013/WD-selectors4-20130502/
Previous Version: http://www.w3.org/TR/2012/WD-selectors4-20120823/
Previous Version: http://www.w3.org/TR/2011/WD-selectors4-20110929/
Editor: Elika J. Etemad, Invited Expert, http://fantasai.inkedblade.net/contact
Editor: Tab Atkins Jr., Google, http://xanthir.com/contact/
Former Editor: Tantek Çelik, http://www.tantek.com
Former Editor: Daniel Glazman
Former Editor: Ian Hickson
Former Editor: Peter Linss
Former Editor: John Williams
Abstract: <b>Selectors</b> are patterns that match against elements in a tree, and as such form one of several technologies that can be used to select nodes in a document. Selectors have been optimized for use with HTML and XML, and are designed to be usable in performance-critical code. They are a core component of <abbr title="Cascading Style Sheets">CSS</abbr> (Cascading Style Sheets), which uses Selectors to bind style properties to elements in the document.
Abstract: Selectors Level 4 describes the selectors that already exist in [[!SELECT]], and further introduces new selectors for CSS and other languages that may need them.
At Risk: the column combinator
At Risk: The '':drop()'' pseudo-class
Ignored Terms: DocumentFragment, math, h1, shadow tree, box tree, query()
Link Defaults: html5 (element) a
</pre>
<style>
.tprofile td, th { vertical-align: baseline; padding: 0 0.5em; }
.tprofile th { text-align: right; }
</style>

<h2 id="context">
Introduction</h2>

	<em>This section is not normative.</em>

	A selector is a boolean predicate
	that takes an element in a tree structure
	and tests whether the element matches the selector or not.

	These expressions may be used for many things:

	<ul>
		<li>
			directly on an element to test whether it matches some criteria,
			such as in the <code>element.matches()</code> function defined in [[DOM]]

		<li>
			applied to an entire tree of elements
			to filter it into a set of elements that match the criteria,
			such as in the <code>document.queryAll()</code> function defined in [[DOM]]
			or the selector of a CSS style rule.

		<li>
			used "in reverse" to generate markup that would match a given selector,
			such as in <a href="http://haml.info/">HAML</a> or <a href="http://en.wikipedia.org/wiki/Zen_Coding">Zen Coding</a>
	</ul>

	Selectors Levels 1, 2, and 3 are defined as the subsets of selector
	functionality defined in the <a href="http://www.w3.org/TR/REC-CSS1">CSS1</a>,
	<a href="http://www.w3.org/TR/CSS21/">CSS2.1</a>, and
	<a href="http://www.w3.org/TR/css3-selectors/">Selectors Level 3</a>
	specifications, respectively. This module defines Selectors Level 4.

<h3 id="placement">Module Interactions</h3>

	This module replaces the definitions of
	and extends the set of selectors defined for CSS in [[SELECT]] and [[CSS21]].

	Pseudo-element selectors,
	which define abstract elements in a rendering tree,
	are not part of this specification:
	their generic syntax is described here,
	but, due to their close integration with the rendering model and irrelevance to other uses such as DOM queries,
	they will be defined in other modules.

<h2 id="overview">
Selectors Overview</h2>

	<em>This section is non-normative, as it merely summarizes the
	following sections.</em>

	A selector represents a structure. This structure can be used as a
	condition (e.g. in a CSS rule) that determines which elements a
	selector matches in the document tree, or as a flat description of the
	HTML or XML fragment corresponding to that structure.

	Selectors may range from simple element names to rich contextual
	representations.

	The following table summarizes the Selector syntax:

	<table class="data">
		<col class="pattern">
		<col class="meaning">
		<col class="section">
		<col class="level">
		<thead>
			<tr>
				<th>Pattern
				<th>Represents
				<th>Section
				<th>Level
		<tbody>
			<tr>
				<td><code>*</code>
				<td>any element
				<td><a href="#universal-selector">Universal selector</a>
				<td>2
			<tr>
				<td><code>E</code>
				<td>an element of type E
				<td><a href="#type-selectors">Type (tag name) selector</a>
				<td>1
		<tbody>
			<tr>
				<td><code>E:not(<var>s1</var>, <var>s2</var>)</code>
				<td>an E element that does not match either <a>compound selector</a> <var>s1</var>
						or <a>compound selector</a> <var>s2</var>
				<td><a href="#negation">Negation pseudo-class</a>
				<td>3/4
			<tr>
				<td><code>E:matches(<var>s1</var>, <var>s2</var>)</code>
				<td>an E element that matches <a>compound selector</a> <var>s1</var>
						and/or <a>compound selector</a> <var>s2</var>
				<td><a href="#matches">Matches-any pseudo-class</a>
				<td>4
		<tbody>
			<tr>
				<td><code>E.warning</code>
				<td>an E element belonging to the class <code>warning</code>
						(the document language specifies how class is determined).
				<td><a href="#class-html">Class selectors</a>
				<td>1
			<tr>
				<td><code>E#myid</code>
				<td>an E element with ID equal to <code>myid</code>.
				<td><a href="#id-selectors">ID selectors</a>
				<td>1
			<tr>
				<td><code>E[foo]</code>
				<td>an E element with a <code>foo</code> attribute
				<td><a href="#attribute-selectors">Attribute selectors</a>
				<td>2
			<tr>
				<td><code>E[foo="bar"]</code>
				<td>an E element whose <code>foo</code> attribute value is
						exactly equal to <code>bar</code>
				<td><a href="#attribute-selectors">Attribute selectors</a>
				<td>2
			<tr>
				<td><code>E[foo="bar" i]</code>
				<td>an E element whose <code>foo</code> attribute value is
						exactly equal to any (ASCII-range) case-permutation of <code>bar</code>
				<td><a href="#attribute-case">Attribute selectors: Case-sensitivity</a>
				<td>4
			<tr>
				<td><code>E[foo~="bar"]</code>
				<td>an E element whose <code>foo</code> attribute value is
						a list of whitespace-separated values, one of which is
						exactly equal to <code>bar</code>
				<td><a href="#attribute-selectors">Attribute selectors</a>
				<td>2
			<tr>
				<td><code>E[foo^="bar"]</code>
				<td>an E element whose <code>foo</code> attribute value
						begins exactly with the string "bar"
				<td><a href="#attribute-selectors">Attribute selectors</a>
				<td>3
			<tr>
				<td><code>E[foo$="bar"]</code>
				<td>an E element whose <code>foo</code> attribute value
						ends exactly with the string <code>bar</code>
				<td><a href="#attribute-selectors">Attribute selectors</a>
				<td>3
			<tr>
				<td><code>E[foo*="bar"]</code>
				<td>an E element whose <code>foo</code> attribute value
						contains the substring <code>bar</code>
				<td><a href="#attribute-selectors">Attribute selectors</a>
				<td>3
			<tr>
				<td><code>E[foo|="en"]</code>
				<td>an E element whose <code>foo</code> attribute value is
						a hyphen-separated list of values beginning with <code>en</code>
				<td><a href="#attribute-selectors">Attribute selectors</a>
				<td>2
		<tbody>
			<tr>
				<td><code>E:dir(ltr)</code>
				<td>an element of type E in with left-to-right directionality
					(the document language specifies how directionality is determined)
				<td><a href="#dir-pseudo">The :dir() pseudo-class</a>
				<td>4
			<tr>
				<td><code>E:lang(zh, *-hant)</code>
				<td>an element of type E tagged as being either in Chinese
					(any dialect or writing system)
					or othewise written with traditional Chinese characters
				<td><a href="#lang-pseudo">The :lang() pseudo-class</a>
				<td>2/4
		<tbody>
			<tr>
				<td><code>E:any-link</code>
				<td>an E element being the source anchor of a hyperlink
				<td><a href="#any-link-pseudo">The hyperlink pseudo-class</a>
				<td>4
			<tr>
				<td><code>E:link</code>
				<td>an E element being the source anchor of a hyperlink
						of which the target is not yet visited
				<td><a href="#link">The link history pseudo-classes</a>
				<td>1
			<tr>
				<td><code>E:visited</code>
				<td>an E element being the source anchor of a hyperlink
						of which the target is already visited
				<td><a href="#link">The link history pseudo-classes</a>
				<td>1
			<tr>
				<td><code>E:local-link</code>
				<td>an E element being the source anchor of a hyperlink
						of which the target is the current document
				<td><a href="#local-pseudo">The local link pseudo-class</a>
				<td>4
			<tr>
				<td><code>E:local-link(0)</code>
				<td>an E element being the source anchor of a hyperlink
						of which the target is within the current domain
				<td><a href="#local-pseudo">The local link pseudo-class</a>
				<td>4
			<tr>
				<td><code>E:target</code>
				<td>an E element being the target of the referring URL
				<td><a href="#target-pseudo">The target pseudo-class</a>
				<td>3
			<tr>
				<td><code>E:scope</code>
				<td>an E element being a designated reference element
				<td><a href="#scope-pseudo">The scope pseudo-class</a>
				<td>4
		<tbody>
			<tr>
				<td><code>E:current</code>
				<td>an E element that is currently presented in a time-dimensional canvas
				<td><a href="#time-pseudos">Time-dimensional Pseudo-classes</a>
				<td>4
			<tr>
				<td><code>E:current(<var>s</var>)</code>
				<td>an E element that is the deepest '':current'' element that
						matches selector <var>s</var>
				<td><a href="#time-pseudos">Time-dimensional Pseudo-classes</a>
				<td>4
			<tr>
				<td><code>E:past</code>
				<td>an E element that is in the past in a time-dimensional canvas
				<td><a href="#time-pseudos">Time-dimensional Pseudo-classes</a>
				<td>4
			<tr>
				<td><code>E:future</code>
				<td>an E element that is in the future in a time-dimensional canvas
				<td><a href="#time-pseudos">Time-dimensional Pseudo-classes</a>
				<td>4
		<tbody>
			<tr>
				<td><code>E:active</code>
				<td>an E element that is in an activated state
				<td><a href="#useraction-pseudos">The user action pseudo-classes</a>
				<td>1
			<tr>
				<td><code>E:hover</code>
				<td>an E element that is under the cursor,
						or that has a descendant under the cursor
				<td><a href="#useraction-pseudos">The user action pseudo-classes</a>
				<td>2
			<tr>
				<td><code>E:focus</code>
				<td>an E element that has user input focus
				<td><a href="#useraction-pseudos">The user action pseudo-classes</a>
				<td>2
			<tr>
				<td><code>E:active-drop</code>
				<td>an E element that will receive the item currently being dragged
				<td><a href="#drag-pseudos">The drag-and-drop pseudo-classes</a>
				<td>4
			<tr>
				<td><code>E:valid-drop</code>
				<td>an E element that could receive the item currently being dragged
				<td><a href="#drag-pseudos">The drag-and-drop pseudo-classes</a>
				<td>4
			<tr>
				<td><code>E:invalid-drop</code>
				<td>an E element that cannot receive the item currently being dragged, but could receive some other item
				<td><a href="#drag-pseudos">The drag-and-drop pseudo-classes</a>
				<td>4
		<tbody>
			<tr>
				<td><code>E:enabled<br>E:disabled</code>
				<td>a user interface element E that is enabled or disabled, respectively
				<td><a href="#enableddisabled">The :enabled and :disabled pseudo-classes</a>
				<td>3
			<tr>
				<td><code>E:read-only</code><br><code>E:read-write</code>
				<td>a user interface element E that
				<td><a href="#rw-pseudos">The mutability pseudo-classes</a>
				<td>3-UI/4
			<tr>
				<td><code>E:placeholder-shown</code>
				<td>an input control currently showing placeholder text
				<td><a href="#rw-pseudos">The placeholder-shown pseudo-class</a>
				<td>3-UI/4
			<tr>
				<td><code>E:default</code>
				<td>a user interface element E that
				<td><a href="#default-pseudo">The default option pseudo-class :default</a>
				<td>3-UI/4
			<tr>
				<td><code>E:checked</code>
				<td>a user interface element E that is checked/selected
					 (for instance a radio-button or checkbox)
				<td><a href="#checked">The selected-option pseudo-class</a>
				<td>3
			<tr>
				<td><code>E:indeterminate</code>
				<td>a user interface element E that is in an indeterminate state
						(neither checked nor unchecked)
				<td><a href="#indeterminate">The indeterminate-value pseudo-class</a>
				<td>4
			<tr>
				<td><code>E:valid</code><br><code>E:invalid</code>
				<td>a user-input element E that
				<td><a href="#range-pseudos">The validity pseudo-classes</a>
				<td>3-UI/4
			<tr>
				<td><code>E:in-range</code><br><code>E:out-of-range</code>
				<td>a user-input element E whose value is in-range/out-of-range
				<td><a href="#range-pseudos">The range pseudo-classes</a>
				<td>3-UI/4
			<tr>
				<td><code>E:required</code><br><code>E:optional</code>
				<td>a user-input element E that requires/does not require input
				<td><a href="#opt-pseudos">The optionality pseudo-classes</a>
				<td>3-UI/4
			<tr>
				<td><code>E:required</code><br><code>E:optional</code>
				<td>a user-input element E with incorrect input
				<td><a href="#opt-pseudos">The optionality pseudo-classes</a>
				<td>4
		<tbody>
			<tr>
				<td><code>E:root</code>
				<td>an E element, root of the document
				<td><a href="#structural-pseudos">Structural pseudo-classes</a>
				<td>3
			<tr>
				<td><code>E:empty</code>
				<td>an E element that has no children (not even text nodes)
				<td><a href="#structural-pseudos">Structural pseudo-classes</a>
				<td>3
			<tr>
				<td><code>E:blank</code>
				<td>an E element that has no content except maybe white space
				<td><a href="#structural-pseudos">Structural pseudo-classes</a>
				<td>4
			<tr>
				<td><code>E:nth-child(<var>n</var>)</code>
				<td>an E element, the <var>n</var>-th child of its parent
				<td><a href="#structural-pseudos">Structural pseudo-classes</a>
				<td>3
			<tr>
				<td><code>E:nth-last-child(<var>n</var>)</code>
				<td>an E element, the <var>n</var>-th child of its parent,
						counting from the last one
				<td><a href="#structural-pseudos">Structural pseudo-classes</a>
				<td>3
			<tr>
				<td><code>E:first-child</code>
				<td>an E element, first child of its parent
				<td><a href="#structural-pseudos">Structural pseudo-classes</a>
				<td>2
			<tr>
				<td><code>E:last-child</code>
				<td>an E element, last child of its parent
				<td><a href="#structural-pseudos">Structural pseudo-classes</a>
				<td>3
			<tr>
				<td><code>E:only-child</code>
				<td>an E element, only child of its parent
				<td><a href="#structural-pseudos">Structural pseudo-classes</a>
				<td>3
			<tr>
				<td><code>E:nth-of-type(<var>n</var>)</code>
				<td>an E element, the <var>n</var>-th sibling of its type
				<td><a href="#structural-pseudos">Structural pseudo-classes</a>
				<td>3
			<tr>
				<td><code>E:nth-last-of-type(<var>n</var>)</code>
				<td>an E element, the <var>n</var>-th sibling of its type,
						counting from the last one
				<td><a href="#structural-pseudos">Structural pseudo-classes</a>
				<td>3
			<tr>
				<td><code>E:first-of-type</code>
				<td>an E element, first sibling of its type
				<td><a href="#structural-pseudos">Structural pseudo-classes</a>
				<td>3
			<tr>
				<td><code>E:last-of-type</code>
				<td>an E element, last sibling of its type
				<td><a href="#structural-pseudos">Structural pseudo-classes</a>
				<td>3
			<tr>
				<td><code>E:only-of-type</code>
				<td>an E element, only sibling of its type
				<td><a href="#structural-pseudos">Structural pseudo-classes</a>
				<td>3
			<tr>
				<td><code>E:nth-match(<var>n</var> of <var>selector</var>)</code>
				<td>an E element, the <var>n</var>-th sibling matching <var>selector</var>
				<td><a href="#structural-pseudos">Structural pseudo-classes</a>
				<td>4
			<tr>
				<td><code>E:nth-last-match(<var>n</var> of <var>selector</var>)</code>
				<td>an E element, the <var>n</var>-th sibling matching <var>selector</var>,
						counting from the last one
				<td><a href="#structural-pseudos">Structural pseudo-classes</a>
				<td>4
		<tbody>
			<tr>
				<td><code>E F</code>
				<td>an F element descendant of an E element
				<td><a href="#descendant-combinators">Descendant combinator</a>
				<td>1
			<tr>
				<td><code>E > F</code>
				<td>an F element child of an E element
				<td><a href="#child-combinators">Child combinator</a>
				<td>2
			<tr>
				<td><code>E + F</code>
				<td>an F element immediately preceded by an E element
				<td><a href="#adjacent-sibling-combinators">Next-sibling combinator</a>
				<td>2
			<tr>
				<td><code>E ~ F</code>
				<td>an F element preceded by an E element
				<td><a href="#general-sibling-combinators">Following-sibling combinator</a>
				<td>3
			<tr>
				<td><code>E /foo/ F</code>
				<td>an F element ID-referenced by an E element's <code>foo</code> attribute
				<td><a href="#idref-combinators">Reference combinator</a>
				<td>4
			<tr>
				<td><code>!E > F</code>
				<td>an E element parent of an F element
				<td><a href="#subject">Determining the subject of a selector</a> +
						<a href="#child-combinators">Child combinator</a>
				<td>4
		<tbody>
			<tr>
				<td><code>F || E</code>
				<td>an E element that represents a cell in a grid/table
						belonging to a column represented by an element F
				<td><a href="#table-pseudos">Grid-Structural pseudo-classes</a>
				<td>4
			<tr>
				<td><code>E:nth-column(<var>n</var>)</code>
				<td>an E element that represents a cell belonging to the
						<var>n</var>th column in a grid/table
				<td><a href="#table-pseudos">Grid-Structural pseudo-classes</a>
				<td>4
			<tr>
				<td><code>E:nth-last-column(<var>n</var>)</code>
				<td>an E element that represents a cell belonging to the
						<var>n</var>th column in a grid/table, counting from the last one
				<td><a href="#table-pseudos">Grid-Structural pseudo-classes</a>
				<td>4
	</table>

	Note: Some Level 4 selectors (noted above as "3-UI") were introduced in [[CSS3UI]].

<h3 id="profiles">
<a>Fast</a> vs <a>Complete</a> Selector Profiles</h3>

	Selectors are used in many different contexts,
	with wildly varying performance characteristics.
	Some powerful selectors are unfortunately too slow
	to realistically include in the more performance-sensitive contexts.
	To accommodate this, two profiles of the Selectors spec are defined:

	<dl>
		<dt><dfn id='fast-profile'>fast</dfn>
		<dd>
			The <a>fast</a> profile is appropriate for use in any context,
			including dynamic browser CSS selector matching.
			It includes every selector defined in this document,
			except for:

			<ul>
				<li><a>Combinators</a> within '':matches()'', '':not()'', '':nth-match()'', and '':nth-last-match()''.
					<p class='issue'>We are considering whether this restriction should be lifted.
				<li>The <a href="#idref-combinators">reference combinator</a>
				<li>The <a href="#subject">subject indicator</a>
			</ul>

		<dt><dfn id='complete-profile'>complete</dfn>
		<dd>
			The <a>complete</a> profile is appropriate for contexts which aren't extremely performance sensitive.
			For example, the <a method for=Element>query()</a> method defined in [[DOM]] should use the ''complete'' profile.
			It includes all of the selectors defined in this document.
	</dl>

	CSS implementations conformant to Selectors Level 4 must use the ''fast'' profile for CSS selection.

	<p class='issue'>
		The categorization of things into the "fast" or "complete" profiles needs implementor review.
		If some things currently not in the fast profile can reasonably be done in CSS Selectors,
		we should move them.


<h2 id="syntax">
Selector Syntax and Structure</h2>

<h3 id="structure">
Structure and Terminology</h3>

	The term <dfn export>selector</dfn> can refer to a <a>simple selector</a>,
	<a>compound selector</a>, <a>complex selector</a>, or <a>selector list</a>.

	A <a>selector list</a> is a comma-separated list of <a>selectors</a>;
	see <a href="#grouping">Selector Lists</a>.

	A <dfn id="complex" export>complex selector</dfn> is a sequence of one or more <a>compound selectors</a>
	separated by <a>combinators</a>.

	A <dfn id="compound" export>compound selector</dfn>
	is a sequence of <a>simple selectors</a>
	that are not separated by a <a>combinator</a>.
	If it contains a <a>type selector</a> or <a>universal selector</a>,
	that selector comes first in the sequence.
	Only one type selector or universal selector is allowed in the sequence.

	A <dfn id="simple" export>simple selector</dfn> represents an aspect of an element to be matched against.
	A simple selector is either a
	<a>type selector</a>,
	<a>universal selector</a>,
	<a>attribute selector</a>,
	<a>class selector</a>,
	<a>ID selector</a>,
	or <a>pseudo-class</a>.

	A <dfn export>combinator</dfn> represents a particular kind of relationship
	between the elements matched by the <a>compound selectors</a> on either side.
	Combinators in Selectors level 4 include:
	whitespace,
	“greater-than sign” (U+003E, <code>></code>),
	“plus sign” (U+002B, <code>+</code>),
	and “tilde” (U+007E, <code>~</code>).

	Issue: Fill in more combinators.

	An empty selector,
	containing no <a>compound selector</a>,
	is an <a href="#invalid">invalid selector</a>.

	Note: As whitespace is a valid <a>combinator</a>,
	no whitespace is allowed between the <a>simple selectors</a>
	in a <a>compound selector</a>.

<h3 id='evaluating-selectors'>
Evaluating a Selector</h3>

	This section describes how to <dfn export>evaluate a selector</dfn> against a set of elements.

	APIs using this algorithm must provide a selector.
	They may optionally provide:

	<ul>
		<li>
			a <a>selector match list</a> of elements to match against.
			If not specified, the <a>initial selector match list</a> for the selector's context is used.

		<li>
			a <a>scoping method</a> and <a>scoping root</a>.
			If not specified, the selector defaults to being unscoped.

		<li>
			a set of <a>:scope elements</a>,
			for resolving the '':scope'' pseudo-class against.
			If not specified,
			the set defaults to being empty.

			If the selector is a <a>relative selector</a>,
			the set of <a>:scope elements</a> must not be empty.

			Note: Note that if the selector is scoped,
			the scoping root is automatically taken as the <a>:scope element</a>,
			so it doesn't have to be provided explicitly
			unless a different result is desired.

		<li>
			which <a>pseudo-elements</a> are allowed to show up in the match list, if any.
			If not specified, this defaults to allowing all pseudo-elements.
	</ul>

	A <a>selector</a> is evaluated against some initial list of elements,
	as determined by the context that the selector is evaluated in:
	the <dfn export>selector match list</dfn>.
	If the selector is <a>scope-contained</a>,
	the <a>selector match list</a> is immediately filtered
	to contain only elements that are either the <a>scoping root</a>
	or descendants of the <a>scoping root</a>.

	The selector is processed from left to right in order,
	with <a>simple selectors</a> filtering the <a>selector match list</a>,
	and <a>combinators</a> and <a>pseudo-elements</a> changing the <a>selector match list</a> into something new.
	If the selector is <a>scope-contained</a>
	then after each <a>combinator</a>
	the <a>selector match list</a> must be filtered
	to contain only elements that are either the <a>scoping root</a>
	or descendants of the <a>scoping root</a>.

	If the selector is <a>scope-filtered</a>,
	then after the selector is finished processing,
	the <a>selector match list</a> must be filtered
	to contain only elements that are either the <a>scoping root</a>
	or descendants of the <a>scoping root</a>.

	After the selector is finished matching,
	the <a>selector match list</a> must be filtered
	to only contain elements and <a>pseudo-elements</a>
	allowed by the invoker of this algorithm.

	When this process is done, the elements in the <a>selector match list</a>
	are the elements said to match the selector.
	If the order of elements matter,
	they must be sorted in document order,
	unless otherwise specified.

	<div class='example'>
		For example, to evaluate the selector "div > i.name" against a document,
		the <a>selector match list</a> is first set to all the elements in the entire document.
		Then, the "div" type selector is evaluated, filtering the <a>selector match list</a>
		to only contain elements with a tagname of "div".
		Then, the ">" child combinator is evaluated, transforming the <a>selector match list</a>
		by replacing each element currently in it with the element's children.
		Then, the "i" type selector is evaluated, filtering the <a>selector match list</a>
		to only contain elements with a tagname of "i".
		Finally, the ".name" class selector is evaluated, filter the <a>selector match list</a>
		to only contain elements with a class of "name".
	</div>

	Note: Many implementations of selectors instead evaluate them right to left,
	as it's more efficient to do so in many cases.
	This, as usual, is completely valid,
	as long as it results in the same elements being returned
	as the spec's algorithm would.

	Each context that a selector can be evaluated in
	must define the <dfn export>initial selector match list</dfn>,
	the list of elements that every selector in that context begins with.

	When evaluating a selector against a DOM document,
	the <a>initial selector match list</a>
	is the root element and all of its descendants,
	ordered by a pre-order traversal.

	Issue: The relative position of pseudo-elements in the <a>selector match list</a> is undefined.
	There's not yet a context that exposes this information,
	but we need to decide on something eventually,
	before something <em>is</em> exposed.


<h3 id='data-model'>
Data Model</h3>

	Selectors are matched against a <a>selector match list</a> of elements,
	which is usually arranged in an abstract tree structure.

	Each element may have any of:

	<ul>
		<li>A type, which is a pair of strings: a namespace and a local name.
		<li>An ID, which is a string.
		<li>Classes, which are strings.
		<li>Attributes, which are pairs of strings consisting of an attribute name and an attribute value.
		<li>A list of child elements.
		<li>Arbitrary additional information,
			which isn't directly accessible,
			but can be used in the matching of pseudo-classes and pseudo-elements.
	</ul>

	The first four bullet points in the list above are referred to as <dfn export title="feature">features</dfn>.
	The <a>simple selectors</a> which are keyed off of them
	(<a>universal selector</a>, <a>type selectors</a>, <a>ID selectors</a>, <a>class selectors</a>, and <a>attribute selectors</a>)
	are called <dfn export title="feature selector">feature selectors</dfn>.

	While elements may lack any of the individual <a>features</a>,
	some elements are <dfn export>featureless</dfn>,
	which means that not only do they lack any <a>features</a>
	(and thus will never match a <a>feature selector</a>),
	but any selectors that reference <a>features</a>,
	such as '':not(div)'',
	also never match them.
	Thus, only <a>pseudo-classes</a> or <a>pseudo-elements</a> can be used to select them.
	Individual <a>featureless</a> elements may define additional restrictions on what kinds of selectors can match them.
	(For example, the <a>host element</a> in a <a>shadow tree</a> is <a>featureless</a>,
	and can't be matched by <em>any</em> <a>pseudo-class</a> except for '':host'' and '':host-context()''.)

	In a DOM document,
	the DOM is used as the <a>selector match list</a>.
	Each DOM element is an element in the <a>selector match list</a>,
	with the DOM element's tagname as the type,
	and its ID, class list, attributes, and child elements
	as the ID, classes, attributes, and child elements in the <a>selector match list</a>.
	The rest of the information in the DOM is also accessible
	as the arbitrary additional information in the <a>selector match list</a>.


<h3 id="scoping">
Scoped Selectors</h3>

	Some host applications may choose to <dfn export title="scope | scoped selector">scope</dfn> selectors
	to a particular subtree or fragment of the document.
	The root of the scoping subtree is called the <dfn export>scoping root</dfn>,
	and may be either a true element (the <dfn export>scoping element</dfn>)
	or a <dfn export title="virtual scoping root">virtual</dfn> one (such as a <a interface>DocumentFragment</a>).

	There are two <dfn export title="scoping method | selector scoping method">scoping methods</dfn> for selectors:

	<dl>
		<dt><dfn export title="scope-contained | scope-contained selector">scope-contained</dfn>
		<dd>
			With this method of scoping, selectors match as if
			the <a>scoping root</a> were the root of the document:
			all <a>compound selectors</a> must be represented within the scope.
			(The '':root'' pseudo-class, however,
			still only matches the actual root of the document.)

		<dt><dfn export title="scope-filtered | scope-filtered selector">scope-filtered</dfn>
		<dd>
			With this method of scoping, a selector matches an element only if the element is within the scope,
			even if other components of the selector are outside the scope.
			(A <a>scoping element</a> is considered to be in scope.)
	</dl>

	<div class='example'>
		For example,
		the <code>element.querySelector()</code> function defined in [[DOM]]
		allows the author to define a <a>scope-filtered</a> selector.

		On the other hand, the selectors within an [[HTML5]] scoped stylesheet
		define <a>scope-contained</a> selectors.
	</div>

	Note: If there are no <a>:scope elements</a> when a selector is evaluated,
	the <a>scoping root</a> acts like a <a>:scope element</a>.

<h3 id="relative">
Relative Selectors</h3>

	Certain contexts may accept <dfn title="relative selector | relative | scope-relative" export>relative selectors</dfn>,
	which are a shorthand for selectors that represent elements relative to a <a>:scope element</a>
	(i.e. an element that matches '':scope'').
	In a <a>relative selector</a>,
	“:scope ” (the '':scope'' pseudo-class followed by a space)
	is implied at the beginning of each <a>complex selector</a>
	that does not already contain the '':scope'' pseudo-class.
	This allows the selector to begin syntactically with a <a>combinator</a>.
	However, it must be <a href="#absolutize">absolutized</a> before matching.

	Relative selectors, once absolutized,
	can additionally be <a>scope-contained</a> or <a>scope-filtered</a>.

<h4 id='absolutizing'>
Absolutizing a Relative Selector</h4>

	To <dfn id='absolutize' export>absolutize a relative selector</dfn>:

	If there are no <a>:scope elements</a>
	and the selector is <a>scoped</a> to a <a>virtual scoping root</a>:

	<ol>
		<li>
			If the selector starts with a <a>child combinator</a>,
			remove the child combinator.
			The selector is now absolute,
			with the additional constraint that the first compound selector in the selector
			only matches elements without a parent.

		<li>
			Otherwise, if the selector starts with any combinator other than the <a>descendant combinator</a>,
			change the selector to '':not(*)''.
			<span class='note'>This is the shortest selector that is valid, but guaranteed to match nothing.</span>

		<li>
			Otherwise, the selector is already absolute.
	</ol>

	Otherwise:

	<ol>
		<li>
			If the selector starts with a <a>combinator</a> other than the <a>descendant combinator</a>,
			prepend '':scope'' as the initial <a>compound selector</a>.

		<li>
			Otherwise, if the selector does not contain any instance of the '':scope'' pseudo-class
			(either at the top-level or as an argument to a functional pseudo-class),
			prepend '':scope'' followed by the <a>descendant combinator</a>.

		<li>
			Otherwise, the selector is already absolute.
	</ol>

	To <dfn id='absolutize-list' export>absolutize a relative selector list</dfn>,
	absolutize each relative selector in the list.


<h3 id="pseudo-classes">
Pseudo-classes</h3>

	The <dfn export>pseudo-class</dfn> concept is introduced to permit selection based on
	information that lies outside of the document tree
	or that can be awkward or impossible to express using the other simple selectors.

	The syntax of a <a>pseudo-class</a>
	is a ":" (U+003A COLON)
	followed by the name of the <a>pseudo-class</a>,
	which is either an <a>identifier</a>,
	or in the case of a	<dfn export>functional pseudo-class</dfn>,
	a function potentially containing arguments between parentheses
	(similar to CSS functions).

	No <a>white space</a> is allowed between the colon and the name of the <a>pseudo-class</a>,
	and as usual for CSS syntax,
	there are no spaces between the function name and its opening parenthesis.
	As usual for CSS syntax,
	<a>white space</a> is allowed arond the arguments between the parentheses
	of a functional pseudo-class,
	unless otherwise specified.

	<a>Pseudo-classes</a> are identical to any other type of <a>simple selector</a>:
	they're allowed in all <a>compound selectors</a> contained in a selector,
	and must follow the <a>type selector</a> or <a>universal selector</a>, if present.
	<a>Pseudo-class</a> names are <a href="#case-sensitive">ASCII case-insensitive</a>.
	Some <a>pseudo-classes</a> are mutually exclusive
	(such that a <a>compound selector</a> containing them, while valid, will never match anything),
	while others can apply simultaneously to the same element.
	<a>Pseudo-classes</a> may be dynamic,
	in the sense that an element can acquire or lose a pseudo-class
	while a user interacts with the document.

<h3 id="pseudo-elements">Pseudo-elements</h3>

	Similar to how <a>pseudo-classes</a> represent additional information
	not directly present in the document tree
	(or that is inconvenient to use),
	a <dfn export>pseudo-element</dfn> is an <em>element</em>
	not directly present in the document tree,
	used to create abstractions about the document tree
	beyond those specified by the document language.

	<div class="example">
		For instance, document languages do not offer mechanisms to access
		the first letter or first line of an element's content,
		but there exist <a>pseudo-elements</a>
		(''::first-letter'' and ''::first-line'')
		that allow those things to be styled.

		<a>Pseudo-elements</a> can also represent content that doesn't exist in the source document at all,
		such as the ''::before'' and ''::after'' pseudo-elements
		which allow additional content to be inserted before or after the contents of any element.
	</div>

	The syntax of a <a>pseudo-element</a>
	is "::" (two U+003A COLON characters)
	followed by the name of the <a>pseudo-element</a> as an <a>identifier</a>.
	<a>Pseudo-element</a> names are <a href="#case-sensitive">ASCII case-insensitive</a>.
	No <a>white space</a> is allowed between the two colons, or between the colons and the name.

	Due to legacy constraints,
	user agents must allow ''::before'', ''::after'', ''::first-line'', and ''::first-letter'' pseudo-elements
	to be written with a single colon rather than two,
	similar to <a>pseudo-class</a> syntax.
	Authors must always use the double-colon syntax for these <a>pseudo-elements</a>.

	<a>Pseudo-elements</a> do not exist independently;
	they belong to another element on the page,
	called their <dfn export>originating element</dfn>.
	When a <a>pseudo-element</a> is encountered in a selector as part of a <a>compound selector</a>,
	the part of the selector to the left of the <a>pseudo-element</a> selects the <a>originating element</a> for the <a>pseudo-element</a>;
	the part of the selector to the right, if any, applies to the <a>pseudo-element</a> itself.
	If a <a>pseudo-element</a> <em>starts</em> a <a>compound selector</a>,
	it's treated as if the selector to its left was the <a>universal selector</a>.

	<div class='example'>
		For example, in the selector ''div a::before'',
		the ''a'' elements matched by the selector are the <a>originating elements</a>
		for the ''::before'' pseudo-elements attached to them.

		The selector ''::first-line'' is equivalent to ''*::first-line'',
		which selects the ''::first-line'' pseudo-element on <em>every</em> element in the document.
	</div>

	<a>Pseudo-elements</a> are <a>featureless</a>,
	and so can't be matched by any <a>feature selector</a>.
	They also do not affect the interpretation of <a>structural pseudo-classes</a>,
	which are evaluated based solely on real elements.
	Other <a>pseudo-classes</a> <em>can</em> match <a>pseudo-elements</a>,
	unless otherwise specified.

	<p class='issue'>
		I've switched over to defaulting to allowing.
		Is that okay,
		or should we stick with defaulting to *not* allowing,
		and requiring individual pseudo-classes to specify that they work on pseudo-elements?

	<div class="example">
		For example, the '':hover'' pseudo-class specifies that it
		can apply to any pseudo-element, i.e. ''::first-line:hover''
		will match when the first line is hovered.
		However, since neither '':focus'' nor ''::first-line''
		define that '':focus'' can apply to ''::first-line'',
		the selector ''::first-line:focus'' will never match anything.
	</div>

	<a>Pseudo-elements</a> may have children,
	as defined by the specification defining them.
	Their children can be children of other elements, too,
	turning the <a>selector match list</a> into a directed acyclic graph,
	but their rendering must be defined so as to maintain the tree-ness of the <a>box tree</a>.

	<div class='example'>
		For example,
		the ''::content'' pseudo-element treats elements distributed to it as its children.
		This means that, given the following fragment:

		<pre>
		&lt;div>
			&lt;span>foo&lt;/span>
			&lt;"shadow root">
				&lt;content>&lt;/content>
			&lt;/"shadow root">
		&lt;/div>
		</pre>

		the selectors ''div > span'' and ''div::shadow ::content > span'' select the same element via different paths.

		However, when rendered,
		the <code>&lt;span></code> element generates boxes as if it were the child of the <code>&lt;content></code> element,
		rather than the <code>&lt;div></code> element,
		so the tree structure of the <a>box tree</a> is maintained.
	</div>

	The host language defines which pseudo-elements exist and their meaning.
	[[CSS21]] defines the ''::before'', ''::after'', ''::first-line'' and ''::first-letter'' pseudo-elements
	which exist in all document languages.

<h4 id='pseudo-element-types'>
Types of Pseudo-Elements</h4>

	<a>Pseudo-elements</a> are divided into two categories:
	<a>content pseudo-elements</a>,
	<a>text pseudo-elements</a>,

	A <dfn export>content pseudo-element</dfn>
	“acts like an element”.
	It might be able to generate boxes
	(though it probably doesn't by default),
	and all properties are valid on it.
	While it is ignored by <a>structural pseudo-classes</a>,
	it's otherwise treated exactly like an element inserted in its place.

	<div class='example'>
		For example, the ''::before'' <a>pseudo-element</a> is a <a>content pseudo-element</a>,
		as it can be styled like any other element
		(as long as its 'content' property is set to a non-''content/none'' value).

		The ''::shadow'' <a>pseudo-element</a> is also a <a>content pseudo-element</a>,
		even though it never generates boxes.
		It does, however,
		act as the parent of the top-level elements in its <a>shadow tree</a>.
	</div>

	A <dfn export>text pseudo-element</dfn>,
	on the other hand,
	never generates boxes.
	Instead, it generates fragments
	within the boxes generated by its <a>originating element</a>.
	Further, the fragments generated by a <a>text pseudo-element</a>
	can cross content boundaries of elements within the <a>originating element</a>.
	For these reasons,
	the properties that apply to <a>text pseudo-elements</a> are extremely restricted.
	<span class='issue'>Explain this better.</span>

	<div class='example'>
		The ''::first-line'' and ''::first-letter'' <a>pseudo-elements</a>
		are both <a>text pseudo-elements</a>.
	</div>

<h3 id="case-sensitive">
Characters and case sensitivity</h3>

	All Selectors syntax is case-insensitive within the ASCII range
	(i.e. [a-z]  and [A-Z] are equivalent),
	except for the following parts,
	which are not under the control of Selectors:
	the case-sensitivity of
	document language element names,
	attribute names,
	and attribute values
	depends on the document language.
	For example,
	<a href="http://www.whatwg.org/html/selectors.html#case-sensitivity">in HTML, element names are case-insensitive</a>,
	but in XML, they are case-sensitive.
	Case sensitivity of namespace prefixes is defined in [[!CSS3NAMESPACE]].
	Case sensitivity of <a>language ranges</a> is defined in the '':lang()'' section.

	<dfn id="whitespace">White space</dfn> in Selectors consists of the
	code points SPACE (U+0020), TAB (U+0009), LINE FEED (U+000A),
	CARRIAGE RETURN (U+000D), and FORM FEED (U+000C) can occur in whitespace.
	Other space-like code points, such as EM SPACE (U+2003) and
	IDEOGRAPHIC SPACE (U+3000), are never part of white space.

	Code points in Selectors can be escaped with a backslash
	according to the same <a href="http://www.w3.org/TR/CSS21/syndata.html#characters">escaping rules</a> as CSS. [[!CSS21]]
	Note that escaping a code point "cancels out" any special meaning it may have in Selectors.
	For example, the selector ''#foo>a'' contains a combinator,
	but ''#foo\>a'' instead selects an element with the id <code>foo>a</code>.


<h3 id="namespaces">
Namespaces</h3>

	Certain selectors support namespace prefixes.
	The mechanism by which namespace prefixes are <dfn id="nsdecl">declared</dfn>
	should be specified by the language that uses Selectors.
	If the language does not specify a namespace prefix declaration mechanism,
	then no prefixes are declared.
	In CSS, namespace prefixes are declared with the ''@namespace''rule. [[!CSS3NAMESPACE]]

<h3 id="invalid">
Invalid Selectors and Error Handling</h3>

	User agents must observe the rules for handling <dfn title="invalid selector|invalid">invalid selectors</dfn>:

	<ul>
		<li>a parsing error in a selector,
			e.g. an unrecognized token or a token which is not allowed at the current parsing point,
			causes that selector to be invalid
		<li>a simple selector containing an <a href="#namespaces">undeclared namespace prefix</a> is invalid
		<li>a selector containing an invalid simple selector, an invalid combinator
			or an invalid token is invalid.
		<li>a selector list containing an invalid selector is invalid.
	</ul>

	An <a>invalid selector</a> represents nothing.



<h2 id="logical-combination">
Logical Combinations</h2>

<h3 id="grouping">
Selector Lists</h3>

	A comma-separated list of selectors represents the union of all
	elements selected by each of the individual selectors in the
	<dfn export>selector list</dfn>.
	(A comma is U+002C.) For example, in CSS when several selectors share
	the same declarations, they may be grouped into a comma-separated
	list. White space may appear before and/or after the comma.

	<div class="example">
		CSS example:
		In this example, we condense three rules with identical
		declarations into one. Thus,
		<pre>
		h1 { font-family: sans-serif }
		h2 { font-family: sans-serif }
		h3 { font-family: sans-serif }
		</pre>
		is equivalent to:
		<pre>h1, h2, h3 { font-family: sans-serif }
		</pre>
	</div>

	<strong>Warning</strong>: the equivalence is true in this example
	because all the selectors are valid selectors. If just one of these
	selectors were invalid, the entire <a>selector list</a> would be
	invalid. This would invalidate the rule for all three heading
	elements, whereas in the former case only one of the three individual
	heading rules would be invalidated.

	<div class="example">
		Invalid CSS example:

		<pre>
		h1 { font-family: sans-serif }
		h2..foo { font-family: sans-serif }
		h3 { font-family: sans-serif }
		</pre>

		is not equivalent to:

		<pre>h1, h2..foo, h3 { font-family: sans-serif } </pre>

		because the above selector (''h1, h2..foo, h3'')
		is entirely invalid and the entire style rule is dropped. (When
		the selectors are not grouped, only the rule for ''h2..foo''
		is dropped.)
	</div>

<h3 id="matches">
The Matches-Any Pseudo-class: '':matches()''</h3>

	The matches-any pseudo-class, <dfn id='matches-pseudo'>:matches()</dfn>,
	is a functional pseudo-class taking a <a href="#grouping">selector list</a>
	as its argument. It represents an element that is represented by its argument.

	In the <a>fast</a> Selectors profile, only lists of <a>compound selectors</a>
	are allowed within '':matches()'':
	<a>combinators</a> are not allowed.
	In the <a>complete</a> profile,
	full <a>complex selectors</a> are allowed.

	The '':matches()'' pseudo-class may not be nested within itself
	or within '':not()'':
	'':matches(:matches(...))'' and '':not(:matches(...))'' are invalid.
	Additionally, pseudo-elements cannot be represented by the matches-any pseudo-class;
	they are not valid within '':matches()''.

	Default namespace declarations do not affect any “implied” universal selectors
	within a '':matches()'' pseudo-class.

	<div class="example">
		For example, following selector matches any element that is being
		hovered or focused, regardless of its namespace. In particular, it
		is not limited to only matching elements in the default namespace
		that are being hovered or focused.

		<pre>*|*:matches(:hover, :focus) </pre>

		The following selector, however, represents only hovered or focused
		elements that are in the default namespace, because it uses an explicit
		universal selector within the '':matches()'' notation:

		<pre>*|*:matches(*:hover, *:focus) </pre>
	</div>

<h3 id="negation">
The Negation Pseudo-class: '':not()''</h3>

	The negation pseudo-class, <dfn id='negation-pseudo'>:not()</dfn>, is a
	functional pseudo-class taking a <a href="#grouping">selector list</a>
	as an argument. It represents an element that is not represented
	by its argument.

	In the <a>fast</a> Selectors profile, only lists of <a>compound selectors</a>
	are allowed within '':not()'':
	<a>combinators</a> are not allowed.
	In the <a>complete</a> profile,
	full <a>complex selectors</a> are allowed.

	Note: In Selectors Level 3,
	only a single <a>simple selector</a> was allowed as the argument to '':not()''.

	A negation may not be nested within itself or within '':matches()'':
	'':not(:not(...))'' and '':matches(:not(...))'' are invalid.
	Additionally, pseudo-elements cannot be represented by the negation pseudo-class;
	they are not valid within '':not()''.

	<div class="example">
		For example, the following selector matches all <a element>button</a> elements in an HTML document
		that are not disabled.

		<pre>button:not([DISABLED]) </pre>

		The following selector represents all but <a element title=''>FOO</a> elements.

		<pre>*:not(FOO)</pre>

		The following compound selector represents all HTML elements
		except links.

		<pre>html|*:not(:link):not(:visited)</pre>
	</div>

	Default namespace declarations do not affect the subject of any selector
	within a negation pseudo-class unless the argument is an explicit universal
	selector or a type selector. (See '':matches()''for examples.)

	Note: The '':not()'' pseudo allows
	useless selectors to be written.  For instance '':not(*|*)'',
	which represents no element at all, or ''foo:not(bar)'',
	which is equivalent to ''foo'' but with a higher
	specificity.

<h2 id="elemental-selectors">
Elemental selectors</h2>

<h3 id="type-selectors">
Type (tag name) selector</h3>

	A <dfn export>type selector</dfn> is the name of a document language element type
	written using the syntax of <a href="http://www.w3.org/TR/css3-namespace/#css-qnames">CSS qualified names</a> [[!CSS3NAMESPACE]].
	A type selector represents an instance of the element type in the document tree.

	<div class="example">
	 Example:
	 The following selector represents an <a element>h1</a> element in the document tree:

	 <pre>h1 </pre>
	</div>

<h4 id="typenmsp">
Type selectors and namespaces</h4>

	Type selectors allow an optional namespace component: a namespace
	prefix that has been previously <a href="#nsdecl">declared</a> may be
	prepended to the element name separated by the namespace separator
	&quot;vertical bar&quot; (U+007C, <code>|</code>). (See, e.g., [[XML-NAMES]] for the use of namespaces in
	XML.)

	The namespace component may be left empty (no prefix before the
	namespace separator) to indicate that the selector is only to
	represent elements with no namespace.

	An asterisk may be used for the namespace prefix, indicating that
	the selector represents elements in any namespace (including elements
	with no namespace).

	Element type selectors that have no namespace component (no
	namespace separator) represent elements without regard to the
	element's namespace (equivalent to "<code>*|</code>") unless a default
	namespace has been <a href="#nsdecl">declared</a>  for namespaced selectors (e.g. in CSS, in
	the style sheet). If a default namespace has been declared, such
	selectors will represent only elements in the default namespace.

	A type selector containing a namespace prefix that has not been
	previously <a href="#nsdecl">declared</a> for namespaced selectors is
	an <a href="#conformance">invalid</a> selector.

	In a namespace-aware client,
	the name part of element type selectors
	(the part after the namespace separator, if it is present)
	will only match against the <a href="http://www.w3.org/TR/REC-xml-names/#NT-LocalPart">local part</a>
	of the element's <a href="http://www.w3.org/TR/REC-xml-names/#ns-qualnames">qualified name</a>.

	In summary:

	<dl>
		<dt><code>ns|E</code>
		<dd>
			elements with name E in namespace ns

		<dt><code>*|E</code>
		<dd>
			elements with name E in any namespace,
			including those without a namespace

		<dt><code>|E</code>
		<dd>
			elements with name E without a namespace

		<dt><code>E</code>
		<dd>
			if no default namespace has been <a href="#nsdecl">declared</a> for selectors,
			this is equivalent to *|E.
			Otherwise it is equivalent to ns|E
			where ns is the default namespace.
	</dl>

	<div class="example">
		CSS examples:

		<pre>
		@namespace foo url(http://www.example.com);
		foo|h1 { color: blue }  /* first rule */
		foo|* { color: yellow } /* second rule */
		|h1 { color: red }      /* ...*/
		*|h1 { color: green }
		h1 { color: green }
		</pre>

		The first rule (not counting the ''@namespace'' at-rule)
		will match only <a element>h1</a> elements in the
		"http://www.example.com" namespace.

		The second rule will match all elements in the
		"http://www.example.com" namespace.

		The third rule will match only <a element>h1</a> elements with
		no namespace.

		The fourth rule will match <a element>h1</a> elements in any
		namespace (including those without any namespace).

		The last rule is equivalent to the fourth rule because no default
		namespace has been defined.
	</div>

<h3 id="universal-selector">
Universal selector </h3>

	The <dfn export>universal selector</dfn>, written as a
	<a href="http://www.w3.org/TR/css3-namespace/#css-qnames">CSS qualified
	name</a> [[!CSS3NAMESPACE]] with an asterisk (<code>*</code>
	U+002A) as the local name, represents the qualified name of any element
	type. It represents any single element in the document tree in any
	namespace (including those without a namespace) if no default
	namespace has been specified for selectors. If a default namespace has
	been specified, see <a href="#univnmsp">Universal selector and
	Namespaces</a> below.

	If a universal selector represented by ''*''
	(i.e. without a namespace prefix)
	is not the only component of a <a>compound selector</a>
	or is immediately followed by a <a>pseudo-element</a>,
	then the ''*'' may be omitted
	and the universal selector's presence implied.

	<div class="example">
		<ul>
			<li>''*[hreflang|=en]'' and ''[hreflang|=en]'' are equivalent,
			<li>''*.warning'' and ''.warning'' are equivalent,
			<li>''*#myid'' and ''#myid'' are equivalent.
		</ul>
	</div>

	Note: It is recommended that the ''*'' not be omitted,
	because it decreases the potential confusion between,
	for example, ''div :first-child''
	and ''div:first-child''.
	Here, ''div *:first-child'' is more readable.

<h4 id="univnmsp">
Universal selector and namespaces</h4>

	The universal selector allows an optional namespace component. It
	is used as follows:

	<dl>
		<dt>''ns|*''
		<dd>
			all elements in namespace ns

		<dt>''*|*''
		<dd>
			all elements

		<dt>''|*''
		<dd>
			all elements without a namespace

		<dt>''*''
		<dd>
			if no default namespace has been specified,
			this is equivalent to *|*.
			Otherwise it is equivalent to ns|*
			where ns is the default namespace.
	</dl>

	A universal selector containing a namespace prefix
	that has not been previously <a href="#nsdecl">declared</a>
	is an <a>invalid selector</a>.


<h2 id="attribute-selectors">
Attribute selectors</h2>

	Selectors allow the representation of an element's attributes. When
	a selector is used as an expression to match against an element,
	an <dfn export>attribute selector</dfn> must be considered to match an element if that
	element has an attribute that matches the attribute represented by the
	attribute selector.

	<p class="issue">Add comma-separated syntax for
	<a href="http://lists.w3.org/Archives/Public/www-style/2011Mar/0215.html">multiple-value matching</a>?
	e.g. [rel ~= next, prev, up, first, last]

<h3 id="attribute-representation">
Attribute presence and value selectors</h3>

	CSS2 introduced four attribute selectors:

	<dl>
		<dt>''[att]''
		<dd>
			Represents an element with the <code>att</code> attribute,
			whatever the value of the attribute.

		<dt>''[att=val]''
		<dd>
			Represents an element with the <code>att</code> attribute
			whose value is exactly "val".

		<dt>''[att~=val]''
		<dd>
			Represents an element with the <code>att</code> attribute
			whose value is a <a href="#whitespace">whitespace</a>-separated list of words,
			one of which is exactly "val".
			If "val" contains whitespace,
			it will never represent anything
			(since the words are <em>separated</em> by spaces).
			Also if "val" is the empty string,
			it will never represent anything.

		<dt>''[att|=val]''
		<dd>
			Represents an element with the <code>att</code> attribute,
			its value either being exactly "val"
			or beginning with "val" immediately followed by "-" (U+002D).
			This is primarily intended to allow language subcode matches
			(e.g., the <code>hreflang</code> attribute on the <a element>a</a> element in HTML)
			as described in BCP 47 ([[BCP47]]) or its successor.
			For <code>lang</code> (or <code>xml:lang</code>) language subcode matching,
			please see the '':lang'' pseudo-class.
	</dl>

	Attribute values must be <<ident-token>>s or <<string-token>>s. [[!CSS3SYN]]

	<div class="example">
		Examples:

		The following attribute selector represents an <a element>h1</a> element
		that carries the <code>title</code> attribute,
		whatever its value:

		<pre>h1[title]</pre>

		In the following example, the selector represents a
		<a element>span</a> element whose <code>class</code> attribute has
		exactly the value "example":

		<pre>span[class="example"]</pre>

		Multiple attribute selectors can be used to represent several
		attributes of an element, or several conditions on the same
		attribute. Here, the selector represents a <a element>span</a> element
		whose <code>hello</code> attribute has exactly the value "Cleveland"
		and whose <code>goodbye</code> attribute has exactly the value
		"Columbus":

		<pre>span[hello="Cleveland"][goodbye="Columbus"]</pre>

		The following CSS rules illustrate the differences between
		"=" and "~=".  The first selector would match, for example, an
		<a element>a</a> element with the value "copyright copyleft
		copyeditor" on a <code>rel</code> attribute. The second selector
		would only match an <a element>a</a> element with an <code>href</code>
		attribute having the exact value "http://www.w3.org/".

		<pre>
		a[rel~="copyright"] { ... }
		a[href="http://www.w3.org/"] { ... }
		</pre>

		The following selector represents an <a element>a</a> element
		whose <code>hreflang</code> attribute is exactly "fr".

		<pre>a[hreflang=fr] </pre>

		The following selector represents an <a element>a</a> element for
		which the value of the <code>hreflang</code> attribute begins with
		"en", including "en", "en-US", and "en-scouse":

		<pre>a[hreflang|="en"] </pre>

		The following selectors represent a <a element title=''>DIALOGUE</a> element
		whenever it has one of two different values for an attribute
		<code>character</code>:

		<pre>
		DIALOGUE[character=romeo]
		DIALOGUE[character=juliet]
		</pre>

	</div>

<h3 id="attribute-substrings">
Substring matching attribute selectors</h3>

	Three additional attribute selectors are provided for matching
	substrings in the value of an attribute:

	<dl>
		<dt>''[att^=val]''
		<dd>
			Represents an element with the <code>att</code> attribute
			whose value begins with the prefix "val".
			If "val" is the empty string
			then the selector does not represent anything.

		<dt>''[att$=val]''
		<dd>
			Represents an element with the <code>att</code> attribute
			whose value ends with the suffix "val".
			If "val" is the empty string
			then the selector does not represent anything.

		<dt>''[att*=val]''
		<dd>
			Represents an element with the <code>att</code> attribute
			whose value contains at least one instance of the substring "val".
			If "val" is the empty string
			then the selector does not represent anything.
	</dl>

	Attribute values must be <<ident-token>>s or <<string-token>>s.

	<div class="example">
		Examples:
		The following selector represents an HTML <a element>object</a> element,
		referencing an image:

		<pre>object[type^="image/"] </pre>

		The following selector represents an HTML <a element>a</a> element
		with an <code>href</code> attribute whose value ends with ".html".

		<pre>a[href$=".html"] </pre>

		The following selector represents an HTML paragraph
		with a <code>title</code> attribute whose value contains the substring "hello"

		<pre>p[title*="hello"] </pre>
	</div>

<h3 id="attribute-case">
Case-sensitivity</h3>

	By default case-sensitivity of attribute names and values in selectors
	depends on the document language. To match attribute values case-insensitively
	regardless of document language rules, the attribute selector may include the
	identifier <code>i</code> before the closing bracket (<code>]</code>).
	When this flag is present, UAs must match the attribute's value
	case-insensitively within the ASCII range.

	<div class="example">
		The following rule will style the <code>frame</code> attribute when it
		has a value of <code>hsides</code>, whether that value is represented
		as <code>hsides</code>, <code>HSIDES</code>, <code>hSides</code>, etc.
		even in an XML environment where attribute values are case-sensitive.

		<pre>[frame=hsides i] { border-style: solid none; } </pre>
	</div>

	<!-- plinss notes we may eventually want to choose other normalizations
			 for attribute matching; but since there's no normalization scheme
			 that really seems needed at this point, this issue is deferred to
			 a later level -->

<h3 id="attrnmsp">
Attribute selectors and namespaces</h3>

	The attribute name in an attribute selector is given as a
	<a href="http://www.w3.org/TR/css3-namespace/#css-qnames">CSS qualified
	name</a>: a namespace prefix that has been previously <a href="#nsdecl">declared</a>
	may be prepended to the attribute name separated by the namespace
	separator &quot;vertical bar&quot; (<code>|</code>). In keeping with
	the Namespaces in the XML recommendation, default namespaces do not
	apply to attributes, therefore attribute selectors without a namespace
	component apply only to attributes that have no namespace (equivalent
	to ''|attr''). An asterisk may be used for
	the namespace prefix indicating that the selector is to match all
	attribute names without regard to the attribute's namespace.

	An attribute selector with an attribute name containing a namespace
	prefix that has not been previously <a href="#nsdecl">declared</a> is
	an <a href="#conformance">invalid</a> selector.

	<div class="example">
		CSS examples:

		<pre>
		@namespace foo "http://www.example.com";
		[foo|att=val] { color: blue }
		[*|att] { color: yellow }
		[|att] { color: green }
		[att] { color: green }
		</pre>

		The first rule will match only elements with the attribute
		<code>att</code> in the "http://www.example.com" namespace with the
		value "val".

		The second rule will match only elements with the attribute
		<code>att</code> regardless of the namespace of the attribute
		(including no namespace).

		The last two rules are equivalent and will match only elements
		with the attribute <code>att</code> where the attribute is not
		in a namespace.
	</div>

<h3 id="def-values">
Default attribute values in DTDs</h3>

	Attribute selectors represent attribute values in the document tree.
	How that document tree is constructed is outside the scope of Selectors.
	In some document formats default attribute values can be defined in a DTD or
	elsewhere, but these can only be selected by attribute selectors if they
	appear in the document tree. Selectors should be designed so that they
	work whether or not the default values are included in the document tree.

	For example, a XML UA may, but is <em>not</em> required to,
	read an “external subset” of the DTD, but <em>is</em> required to
	look for default attribute values in the document's “internal subset”.
	(See, e.g., [[XML10]] for definitions of these subsets.)
	Depending on the UA, a default attribute value defined in the external subset of the DTD
	might or might not appear in the document tree.

	A UA that recognizes an XML namespace may, but is not required to use its
	knowledge of that namespace to treat default attribute values as if
	they were present in the document. (For example, an XHTML UA is not
	required to use its built-in knowledge of the XHTML DTD. See, e.g., [[XML-NAMES]] for details on namespaces in XML
	1.0.)

	Note: Typically, implementations
	choose to ignore external subsets. This corresponds to the behaviour
	of non-validating processors as defined by the XML specification.

	<div class="example">
		Example:

		Consider an element <code>EXAMPLE</code> with an attribute <code>radix</code>
		that has a default value of <code>"decimal"</code>. The DTD fragment might be

		<pre class="dtd-example">&lt;!ATTLIST EXAMPLE radix (decimal,octal) "decimal"> </pre>

		If the style sheet contains the rules

		<pre>
		EXAMPLE[radix=decimal] { /*... default property settings ...*/ }
		EXAMPLE[radix=octal]   { /*... other settings...*/ }
		</pre>

		the first rule might not match elements whose <code>radix</code> attribute is
		set by default, i.e. not set explicitly. To catch all cases, the
		attribute selector for the default value must be dropped:

		<pre>
		EXAMPLE                { /*... default property settings ...*/ }
		EXAMPLE[radix=octal]   { /*... other settings...*/ }
		</pre>

		Here, because the selector ''EXAMPLE[radix=octal]'' is
		more specific than the type selector alone, the style declarations in
		the second rule will override those in the first for elements that
		have a <code>radix</code> attribute value of <code>"octal"</code>. Care has to be taken that
		all property declarations that are to apply only to the default case
		are overridden in the non-default cases' style rules.
	</div>

<h3 id="class-html">
Class selectors</h3>

	The <dfn export>class selector</dfn> is given as a full stop (. U+002E) immediately
	followed by an identifier. It represents an element belonging to the
	class identified by the identifier, as defined by the document language.
	For example, in [[HTML5]], [[SVG11]], and [[MATHML]] membership in a
	class is given by the <code>class</code> attribute: in these languages
	it is equivalent to the <code>~=</code> notation applied to the
	local <code>class</code> attribute
	(i.e. <code>[class~=<var>identifier</var>]</code>).

	<div class="example">
		CSS examples:

		We can assign style information to all elements with
		<code>class~="pastoral"</code> as follows:

		<pre>*.pastoral { color: green }  /* all elements with class~=pastoral */ </pre>

		or just

		<pre>.pastoral { color: green }  /* all elements with class~=pastoral */ </pre>

		The following assigns style only to H1 elements with
		<code>class~="pastoral"</code>:

		<pre>H1.pastoral { color: green }  /* H1 elements with class~=pastoral */ </pre>

		Given these rules, the first <code>H1</code> instance below would not have
		green text, while the second would:

		<pre>
		&lt;H1>Not green&lt;/H1>
		&lt;H1 class="pastoral">Very green&lt;/H1>
		</pre>

		The following rule matches any <a element>P</a> element whose <code>class</code>
		attribute has been assigned a list of <a
		href="#whitespace">whitespace</a>-separated values that includes both
		<code>pastoral</code> and <code>marine</code>:

		<pre>p.pastoral.marine { color: green } </pre>

		This rule matches when <code>class="pastoral blue aqua
		marine"</code> but does not match for <code>class="pastoral
		blue"</code>.
	</div>

	Note: Because CSS gives considerable
	power to the "class" attribute, authors could conceivably design their
	own "document language" based on elements with almost no associated
	presentation (such as <a element>div</a> and <a element>span</a> in HTML)
	and assigning style
	information through the "class" attribute.  Authors should avoid this
	practice since the structural elements of a document language often
	have recognized and accepted meanings and author-defined classes may
	not.

	Note: If an element has multiple
	class attributes, their values must be concatenated with spaces
	between the values before searching for the class. As of this time the
	working group is not aware of any manner in which this situation can
	be reached, however, so this behavior is explicitly non-normative in
	this specification.

<h3 id="id-selectors">
ID selectors</h3>

	Document languages may contain attributes that are declared to be of type ID.
	What makes attributes of type ID special
	is that no two such attributes can have the same value in a conformant document,
	regardless of the type of the elements that carry them;
	whatever the document language,
	an ID typed attribute can be used to uniquely identify its element.
	In HTML all ID attributes are named <code>id</code>;
	XML applications may name ID attributes differently,
	but the same restriction applies.
	Which attribute on an element is considered the “ID attribute“ is defined by the document language.

	An <dfn export>ID selector</dfn> consists of a “number sign” (U+0023, <code>#</code>)
	immediately followed by the ID value,
	which must be a CSS <a href="http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">identifier</a>.
	An ID selector represents an element instance that has an identifier that matches the identifier in the ID selector.
	(It is possible in non-conforming documents for multiple elements to match a single ID selector.)

	<div class="example">
		Examples:
		The following ID selector represents an <a element>h1</a> element
		whose ID-typed attribute has the value "chapter1":

		<pre>h1#chapter1 </pre>

		The following ID selector represents any element whose ID-typed
		attribute has the value "chapter1":

		<pre>#chapter1 </pre>

		The following selector represents any element whose ID-typed
		attribute has the value "z98y".

		<pre>*#z98y </pre>
	</div>

	Note: In XML 1.0 [[XML10]], the information about which attribute
	contains an element's IDs is contained in a DTD or a schema. When
	parsing XML, UAs do not always read the DTD, and thus may not know
	what the ID of an element is (though a UA may have namespace-specific
	knowledge that allows it to determine which attribute is the ID
	attribute for that namespace). If a style sheet author knows or
	suspects that a UA may not know what the ID of an element is, he
	should use normal attribute selectors instead:
	''[name=p371]'' instead of ''#p371''.

	If an element has multiple ID attributes, all of them must be
	treated as IDs for that element for the purposes of the ID
	selector. Such a situation could be reached using mixtures of xml:id,
	DOM3 Core, XML DTDs, and namespace-specific knowledge.

<h2 id="linguistic-pseudos">
Linguistic Pseudo-classes</h2>

<h3 id="the-dir-pseudo">
The directionality pseudo-class '':dir()''</h3>

	The <dfn id='dir-pseudo'>:dir()</dfn> pseudo-class allows the author to write
	selectors that represent an element based on its directionality as
	determined by the document language.
	For example, [[HTML5]] defines <a href="http://www.whatwg.org/html/selectors.html#selector-ltr">how to determine the directionality of an element</a>,
	based on a combination of the <code>dir</code> attribute, the surrounding text, and other factors.
	The '':dir()'' pseudo-class does not select based on stylistic
	states&#8212;for example, the CSS 'direction' property does not affect
	whether it matches.

	The pseudo-class '':dir(ltr)'' represents an element that
	has a directionality of left-to-right (<code>ltr</code>). The
	pseudo-class '':dir(rtl)'' represents an element that has
	a directionality of right-to-left (<code>rtl</code>). The argument to
	'':dir()'' must be a single identifier, otherwise the selector
	is invalid. White space is optionally allowed between the identifier
	and the parentheses. Values other than <code>ltr</code> and
	<code>rtl</code> are not invalid, but do not match anything. (If a
	future markup spec defines other directionalities, then Selectors may
	be extended to allow corresponding values.)

	The difference between '':dir(C)'' and ''[dir=C]''
	is that ''[dir=C]'' only performs a comparison against a given
	attribute on the element, while the '':dir(C)'' pseudo-class
	uses the UAs knowledge of the document's semantics to perform the
	comparison. For example, in HTML, the directionality of an element
	inherits so that a child without a <code>dir</code> attribute will have
	the same directionality as its closest ancestor with a valid <code>dir</code>
	attribute. As another example, in HTML,
	an element that matches ''[dir=auto]'' will match either
	'':dir(ltr)'' or '':dir(rtl)'' depending on the resolved
	directionality of the elements as determined by its contents. [[HTML5]]

<h3 id="the-lang-pseudo">
The language pseudo-class '':lang()''</h3>

	If the document language specifies how the (human) content language of an
	element is determined, it is possible to write selectors that
	represent an element based on its language.
	The <dfn id='lang-pseudo'>:lang()</dfn> pseudo-class represents an element that
	is in one of the languages listed in its argument. It accepts
	a comma-separated list of one or more <a>language ranges</a> as its
	argument. Each <dfn>language range</dfn> in '':lang()''
	must be a valid CSS <a href="http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">identifier</a>
	[[!CSS21]]
	or consist of an asterisk (* U+002A) immediately followed by an identifier
	beginning with an ASCII hyphen (U+002D) for the selector to be valid.

	The <dfn>language</dfn> of an element is defined by the document language.
	For example, in HTML [[HTML401]], the <a>language</a> is determined by a
	combination of the <code>lang</code> attribute, information from
	<a element>meta</a> elements, and possibly also the protocol (e.g.
	from HTTP headers). XML languages can use the <code>xml:lang</code>
	attribute to indicate language information for an element.

	The element's <a>language</a> matches a <a>language range</a> if
	the element's <a>language</a> (normalized to BCP 47 syntax if necessary)
	matches the given <a>language range</a> in an <var>extended filtering</var>
	operation per [[RFC4647]] <cite>Matching of Language Tags</cite> (section 3.3.2).
	The matching is performed case-insensitively within the ASCII range.
	The <a>language range</a> does not need to be a valid language code to
	perform this comparison.

	Note: It is recommended that
	documents and protocols indicate language using codes from BCP 47 [[BCP47]]
	or its successor, and by means of <code>xml:lang</code> attributes in the
	case of XML-based documents [[XML10]]. See <a
	href="http://www.w3.org/International/questions/qa-lang-2or3.html">
	"FAQ: Two-letter or three-letter language codes."</a>

	<div class="example">
		Examples:
		The two following selectors represent an HTML document that is in
		Belgian French or German. The two next selectors represent
		<a element>q</a> quotations in an arbitrary element in Belgian French
		or German.

		<pre>
		html:lang(fr-be)
		html:lang(de)
		:lang(fr-be) > q
		:lang(de) > q
		</pre>
	</div>

	Note: One difference between '':lang(C)'' and the ''|='' operator
	is that the ''|='' operator only performs a comparison against a given
	attribute on the element, while the '':lang(C)'' pseudo-class
	uses the UAs knowledge of the document's semantics to perform the
	comparison.

	<div class=example>
		In this HTML example, only the BODY matches
		''[lang|=fr]'' (because it has a LANG attribute) but both
		the BODY and the P match '':lang(fr)'' (because both are in
		French). The P does not match the ''[lang|=fr]'' because it
		does not have a LANG attribute.

		<pre>
		&lt;body lang=fr>
		  &lt;p>Je suis français.&lt;/p>
		&lt;/body>
		</pre>
	</div>

	<div class=example>
		Another difference between '':lang(C)'' and the ''|='' operator
		is that '':lang(C)'' performs implicit wildcard matching.

		For example, '':lang(de-DE)'' will match all of ''de-DE'',
		''de-DE-1996'', ''de-Latn-DE'', ''de-Latf-DE'', ''de-Latn-DE-1996'',
		whereas of those ''[lang|=de-DE]'' will only match ''de-DE'' and
		''de-DE-1996''.

		To perform wildcard matching on the first subtag (the primary language),
		an asterisk must be used: ''*-CH'' will match all of ''de-CH'',
		''it-CH'', ''fr-CH'', and ''rm-CH''.

		Note that asterisks are not allowed anywhere else in '':lang()'''s
		language range syntax: they only have meaning, and are therefore only allowed,
		at the beginning.
	</div>

	Note: Wildcard language matching is new in Level 4.


<h2 id="location">
Location Pseudo-classes</h2>

<h3 id="the-any-link-pseudo">
The hyperlink pseudo-class: '':any-link''</h3>

	The <dfn id='any-link-pseudo'>:any-link</dfn> pseudo-class represents an element
	that acts as the source anchor of a hyperlink.
	For example, in [[HTML5]], any <a element>a</a>, <a element>area</a>, or <a element>link</a> elements with an <code>href</code> attribute
	are hyperlinks, and thus <a href="http://www.whatwg.org/html/selectors.html#selector-link">match <code>:any-link</code></a>.
	It matches an element if the element would match '':link'' or '':visited'',
	equivalent to '':matches(:link, :visited)''.


	<p class="issue">Any better name suggestions for this pseudo?

<h3 id="link">
The link history pseudo-classes: '':link'' and '':visited''</h3>

	User agents commonly display unvisited <a href="#the-any-link-pseudo">hyperlinks</a> differently from
	previously visited ones. Selectors
	provides the pseudo-classes <dfn id='link-pseudo'>:link</dfn> and
	<dfn id='visited-pseudo'>:visited</dfn> to distinguish them:

	<ul>
		<li>The '':link'' pseudo-class applies to links that have
		not yet been visited.
		<li>The '':visited'' pseudo-class applies once the link has
		been visited by the user.
	</ul>

	After some amount of time, user agents may choose to return a
	visited link to the (unvisited) ':link' state.

	The two states are mutually exclusive.

	<div class="example">
		The following selector represents links carrying class
		<code>footnote</code> and already visited:

		<pre>.footnote:visited </pre>
	</div>

	Note: It is possible for style sheet
	authors to abuse the :link and :visited pseudo-classes to determine
	which sites a user has visited without the user's consent.

	UAs may therefore treat all links as unvisited links, or implement
	other measures to preserve the user's privacy while rendering visited
	and unvisited links differently.


<h3 id="local-pseudo">
The local link pseudo-class '':local-link''</h3>

	The <dfn id='local-link-pseudo'>:local-link</dfn> pseudo-class allows authors to style
	<a href="#the-any-link-pseudo">hyperlinks</a> based on the users current location within a site and to
	differentiate site-internal versus site-external links.

	The (non-functional) '':local-link'' pseudo-class represents an element that is
	the source anchor of a hyperlink whose target's absolute URL
	matches the element's own document URL.
	Any fragment identifiers are stripped before matching the document's URL against the link's URL;
	otherwise all portions of the URL are considered.

	<div class="example">
		For example, the following rule prevents links targetting the
		current page from being underlined when they are part of the
		navigation list:

		<pre>nav :local-link { text-decoration: none; } </pre>
	</div>

	As a functional pseudo-class,
	'':local-link()'' can also accept a non-negative integer as its sole argument,
	which, if the document's URL belongs to a hierarchical scheme,
	indicates the number of path levels to match:

	<ul>
		<li>'':local-link(0)'' represents a link element whose target is in the same origin as the document's URL
		<li>'':local-link(1)'' represents a link element whose target has the same origin and first path segment
		<li>'':local-link(2)'' represents a link element whose target has the same origin, first, and second path segments
		<li>etc.
	</ul>

	<div class="example">
		The following example styles all site-external links with a dashed
			underline.

		<pre>:not(:local-link(0)) { text-decoration-style: dashed; } </pre>
	</div>

	Path segments are portions of the URL's path that are separated by forward slashes (/).
	If a segment is missing from the document's URL,
	a pseudo-class requiring that segment to match does not match anything.

	<div class="example">
		So, given the links:

		<ol>
			<li><code>&lt;a href="http://www.example.com">Home&lt;/a></code>
			<li><code>&lt;a href="http://www.example.com/2011">2011&lt;/a></code>
			<li><code>&lt;a href="http://www.example.com/2011/03">March&lt;/a></code>
			<li><code>&lt;a href="http://www.example.com/2011/03/">March&lt;/a></code>
			<li><code>&lt;a href="http://www.example.com/2011/03/21">21 March&lt;/a></code>
			<li><code>&lt;a href="https://www.example.com/2011/03/">March&lt;/a></code>
			<li><code>&lt;a href="http://example.com/2011/03/">March&lt;/a></code>
		</ol>

		and the styles:

		<ol type=A>
			 <li><code>a:local-link {...}</code>
			 <li><code>a:local-link(0) {...}</code>
			 <li><code>a:local-link(1) {...}</code>
			 <li><code>a:local-link(2) {...}</code>
			 <li><code>a:local-link(3) {...}</code>
			 <li><code>a:local-link(4) {...}</code>
		</ol>

		If the document's URL is <code>http://www.example.com/2011/03/</code>:

		<ol>
			<li>Link 1 would receive Style B
			<li>Link 2 would receive Styles B and C
			<li>Link 3 would receive Styles B, C, and D
			<li>Link 4 would also receive Styles A, B, C, D, and E
			<li>Link 5 would receive Styles B, C, and D
			<li>Link 6 would remain unstyled
			<li>Link 7 would remain unstyled
			<li>Style F would not be applied to anything
		</ol>
	</div>


		The "origin" of the URL is defined by <a href="http://tools.ietf.org/html/rfc6454#section-4">RFC 6454, Section 4</a>.
		The username, password, query string, and fragment portions of the URL are not considered
		when matching against '':local-link(<var>n</var>)''.
		If the document's URL does not belong to a hierarchical scheme,
		the functional pseudo-class matches nothing.

	<p class="issue">
		It's clear that, if the document URL has at least N segments,
		then '':local-link(N)'' only matches links whose URL has at least N segments.
		(This lets you assign consistent semantics to :local-link so that,
		for example, :local-link(2) means a "within-repo" link on GitHub.)
		What about if the document url has less than N segments,
		and the link is same-page?
		Should "null segments" count as matching, or not?


<h3 id="the-target-pseudo">
The target pseudo-class '':target''</h3>

	Some URLs refer to a location within a resource. This kind of URL
	ends with a &quot;number sign&quot; (#) followed by an anchor
	identifier (called the fragment identifier).

	URLs with fragment identifiers link to a certain element within the
	document, known as the target element. For instance, here is a URL
	pointing to an anchor named <code>section_2</code> in an HTML
	document:

	<pre>http://example.com/html/top.html#section_2 </pre>

	The <dfn id='target-pseudo'>:target</dfn> pseudo-class matches the target element of the document's URL.
	If the document's URL has no fragment identifier, then the document has no target element.

	<div class="example">
		Example:

		<pre>p.note:target </pre>

		This selector represents a <a element>p</a> element of class
		<code>note</code> that is the target element of the referring
		URL.
	</div>

	<div class="example">
		CSS example:
		Here, the '':target'' pseudo-class is used to make the
		target element red and place an image before it, if there is one:

		<pre>
		*:target { color : red }
		*:target::before { content : url(target.png) }
		</pre>
	</div>


<h3 id="the-scope-pseudo">
The reference element pseudo-class '':scope''</h3>

	In some contexts, selectors can be matched with an explicit set of <dfn dfn export title=":scope element">:scope elements</dfn>.
	This is is a (potentially empty) set of elements
	that provide a reference point for selectors to match against,
	such as that specified by the <code>querySelector()</code> call in [[DOM]],
	or the parent element of a <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/semantics.html#the-style-element">scoped <code>&lt;style></code> element</a> in [[HTML5]].

	The <dfn id='scope-pseudo'>:scope</dfn> pseudo-class represents any element that is a <a>:scope element</a>.
	If the <a>:scope elements</a> are not explicitly specified,
	but the selector is <a>scoped</a> and the <a>scoping root</a> is an element,
	then '':scope'' represents the <a>scoping root</a>;
	otherwise, it represents the root of the document
	(equivalent to '':root'').
	Specifications intending for this pseudo-class to match specific elements
	rather than the document's root element
	must define either a <a>scoping root</a> (if using <a>scoped selectors</a>) or an explicit set of <a>:scope elements</a>.

<h2 id="useraction-pseudos">
User Action Pseudo-classes</h2>

	Interactive user agents sometimes change the rendering in response to user actions.
	Selectors provides three pseudo-classes for the selection of an element the user is acting on.
	(In non-interactive user agents, these pseudo-classes are valid, but never match any element.)

	These pseudo-classes are not mutually exclusive. An element may
	match several pseudo-classes at the same time.

	<div class="example">
		Examples:

		<pre>
		a:link    /* unvisited links */
		a:visited /* visited links */
		a:hover   /* user hovers */
		a:active  /* active links */
		</pre>

		An example of combining dynamic pseudo-classes:

		<pre>
		a:focus
		a:focus:hover
		</pre>

		The last selector matches <a element>a</a> elements that are in
		the pseudo-class :focus and in the pseudo-class :hover.
	</div>

	Note: The specifics of hit-testing,
	necessary to know when several of the pseudo-classes defined in this section apply,
	are not yet defined,
	but should be in the future.

<h3 id="the-hover-pseudo">
The pointer hover pseudo-class '':hover''</h3>

	The <dfn id='hover-pseudo'>:hover</dfn> pseudo-class applies
	while the user designates an element with a pointing device,
	but does not necessarily activate it.
	For example, a visual user agent could apply this pseudo-class
	when the cursor (mouse pointer) hovers over a box generated by the element.
	Interactive user agents that cannot detect hovering due to hardware limitations
	(e.g., a pen device that does not detect hovering)
	are still conforming.

	The parent of an element that is '':hover'' is also in that state.

	Host languages may define additional ways in which an element can match '':hover''.
	For example, [[HTML5]] defines a <a element>label</a> element as <a href="http://www.whatwg.org/html/selectors.html#selector-hover">matching <code>:hover</code></a>
	when its labelled control is hovered.

	Note: Since the ':hover' state can apply to
	an element because its child is designated by a pointing device, then it is
	possible for ':hover' to apply to an element that is not underneath
	the pointing device.

	The '':hover'' pseudo-class can apply to any pseudo-element.

<h3 id="the-active-pseudo">
The activation pseudo-class '':active''</h3>

	The <dfn id='active-pseudo'>:active</dfn> pseudo-class applies while an element
	is being activated by the user. For example, between the times the
	user presses the mouse button and releases it. On systems with more
	than one mouse button, '':active'' applies only to the
	primary or primary activation button (typically the "left" mouse
	button), and any aliases thereof.

	There may be document language or implementation specific limits on
	which elements can become '':active''.
	For example, [[HTML5]] defines a <a href="http://www.whatwg.org/html/selectors.html#selector-active">list of activatable elements</a>.

	Selectors doesn't define if the parent of an element that is
	':active' is also in that state.

	Note: An element can be both
	':visited' and ':active' (or ':link' and ':active').

<h3 id="the-focus-pseudo">
The input focus pseudo-class '':focus''</h3>

	The <dfn id='focus-pseudo'>:focus</dfn> pseudo-class applies while an element
	has the focus (accepts keyboard or mouse events, or other forms of
	input).

	There may be document language or implementation specific limits on
	which elements can acquire '':focus''.
	For example, [[HTML5]] defines a <a href="http://www.whatwg.org/html/selectors.html#selector-active">list of activatable elements</a>.

<h3 id="drag-pseudos">
The drag-and-drop pseudo-class '':drop'' and '':drop()''</h3>

	The <dfn>:drop</dfn> pseudo-class applies to all elements
	that are drop targets,
	as defined by the host language,
	while the user is “dragging”
	or otherwise conceptually carrying an item
	to be “dropped”.
	For example, in HTML the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#the-dropzone-attribute"><code>dropzone</code></a> attribute
	specified that an element is a drop target.

	The <dfn>:drop()</dfn> functional pseudo-class is identical to '':drop'',
	but allows additional filters to be specified that can exclude some drop targets.
	Its syntax is:

	<pre class='prod'>:drop( [ active || valid || invalid ]? ) </pre>

	The keywords have the following meanings:

	<dl dfn-type="value" dfn-for=":drop()">
		<dt><dfn>active</dfn>
		<dd>
			The drop target is the current drop target for the drag operation.
			That is, if the user were to release the drag,
			it would be dropped onto this drop target.

		<dt><dfn>valid</dfn>
		<dd>
			If the host language has a concept of “valid” and “invalid” drop targets,
			this only matches if the drop target is valid for the object currently being dragged.
			Otherwise, it matches all drop targets.

			For example, HTML's <code>dropzone</code> attribute can specify that the drop target only accepts strings or files that are set to a given type.

		<dt><dfn>invalid</dfn>
		<dd>
			If the host language has a concept of “valid” and “invalid” drop targets,
			this only matches if the drop target is invalid for the object currently being dragged.
			Otherwise, it matches nothing.
	</dl>

	Multiple keywords can be combined in the argument,
	representing only drop targets that satisfy all of the keywords.
	For example, '':drop(valid active)'' will match the active drop target <em>if</em> it's valid,
	but not if it's invalid.

	If no keywords are given in the argument,
	'':drop()'' has the same meaning as '':drop''
	- it matches every drop target.

<h2 id="time-pseudos">
Time-dimensional Pseudo-classes</h2>

	These pseudo-classes classify elements with respect to the
	currently-displayed or active position in some timeline, such as
	during speech rendering of a document, or during the display of
	a video using WebVTT to render subtitles.

	CSS does not define this timeline;
	the host language must do so.
	If there is no timeline defined for an element,
	these pseudo-classes must not match the element.

<h3 id="the-current-pseudo">
The current-element pseudo-class '':current''</h3>

	The <dfn id='current-pseudo'>:current</dfn> pseudo-class represents the
	element, or an ancestor of the element, that is currently being displayed.

	Its alternate form '':current()'', like '':matches()'',
	takes a list of <a>compound selectors</a> as its argument: it represents the
	'':current'' element that matches the argument or, if that does
	not match, the innermost ancestor of the '':current'' element
	that does. (If neither the '':current'' element nor its ancestors
	match the argument, then the selector does not represent anything.)

	<div class="example">
		For example, the following rule will highlight whichever paragraph
		or list item is being read aloud in a speech rendering of the document:

		<pre>
		:current(p, li, dt, dd) {
		  background: yellow;
		}
		</pre>
	</div>

<h3 id="the-past-pseudo">
The past-element pseudo-class '':past''</h3>

	The '':past'' pseudo-class represents any element that is
	defined to occur entirely prior to a '':current'' element.
	For example, the WebVTT spec defines the '':past'' pseudo-class <a href="http://dev.w3.org/html5/webvtt/#the-past-and-future-pseudo-classes">relative to the current playback position of a media element</a>.
	If a time-based order of elements is not defined by the document language,
	then this represents any element that is a (possibly indirect) previous
	sibling of a '':current'' element.

<h3 id="the-future-pseudo">
The future-element pseudo-class '':future''</h3>

	The <dfn id='future-pseudo'>:future</dfn> pseudo-class represents any element that is
	defined to occur entirely after a '':current'' element.
	For example, the WebVTT spec defines the '':future'' pseudo-class <a href="http://dev.w3.org/html5/webvtt/#the-past-and-future-pseudo-classes">relative to the current playback position of a media element</a>.
	If a time-based order of elements is not defined by the document language,
	then this represents any element that is a (possibly indirect) next
	sibling of a '':current'' element.


<h2 id='input-pseudos'>
The Input Pseudo-classes</h2>

	The pseudo-classes in this section mostly apply to elements that take user input,
	such as HTML's <a element>input</a> element.

<h3 id="input-states">
Input Control States</h3>

<h4 id="enableddisabled">
The '':enabled'' and '':disabled'' pseudo-classes</h4>

	The <dfn id='enabled-pseudo'>:enabled</dfn> pseudo-class represents user interface elements
	that are in an enabled state; such elements have a corresponding disabled
	state.

	Conversely, the <dfn id='disabled-pseudo'>:disabled</dfn> pseudo-class represents user
	interface elements that are in a disabled state; such elements have a
	corresponding enabled state.

	What constitutes an enabled state, a disabled state, and a user interface
	element is host-language-dependent. In a typical document most elements will be
	neither '':enabled'' nor '':disabled''.
	For example, [[HTML5]] defines <a href="http://www.whatwg.org/html/selectors.html#selector-enabled">non-disabled interactive elements</a> to be '':enabled'',
	and any such elements that are <a href="http://www.whatwg.org/html/selectors.html#selector-disabled">explicitly disabled</a> to be '':disabled''.

	Note: CSS properties that might affect a user’s ability
	to interact with a given user interface element do not affect whether it
	matches '':enabled'' or '':disabled''; e.g., the
	'display' and 'visibility' properties have no effect
	on the enabled/disabled state of an element.

<h4 id="rw-pseudos">
The mutability pseudo-classes '':read-only'' and '':read-write''</h4>

	An element matches <dfn id="read-write-pseudo">:read-write</dfn> if it is user-alterable,
	as defined by the host language.
	Otherwise, it is <dfn id="read-only-pseudo">:read-only</dfn>.

	For example, in [[HTML5]] a <a href="http://www.whatwg.org/html/selectors.html#selector-read-only">non-disabled non-readonly <code>&lt;input></code> element</a> is '':read-write'',
	as is any element with the <code>contenteditable</code> attribute set to the true state.

<h4 id="placeholder">
The placeholder-shown pseudo-class '':placeholder-shown''</h4>

	Input elements can sometimes show placeholder text
	as a hint to the user on what to type in.
	See, for example, the <code>placeholder</code> attribute in [[HTML5]].
	The <dfn id="placeholder-shown-pseudo">:placeholder-shown</dfn> pseudo-class
	matches an input element that is showing such placeholder text.

<h4 id="the-default-pseudo">
The default-option pseudo-class '':default''</h4>

	The <dfn id='default-pseudo'>:default</dfn> pseudo-class applies to the one or more UI elements
	that are the default among a set of similar elements.  Typically applies to
	context menu items, buttons and select lists/menus.

	One example is the default submit button among a set of buttons.
	Another example is the default option from a popup menu.
	In a select-many group (such as for pizza toppings), multiple elements can match '':default''.
	For example, [[HTML5]] defines that '':default'' matches
	<a href="http://www.whatwg.org/html/selectors.html#selector-default">the “default button” in a form,
	the initially-selected <code>&lt;option></code>(s) in a <code>&lt;select></code>,
	and a few other elements.</a>

<h3 id="input-value-states">
Input Value States</h3>

<h4 id="checked">
The selected-option pseudo-class '':checked''</h4>

	Radio and checkbox elements can be toggled by the user. Some menu
	items are "checked" when the user selects them. When such elements are
	toggled "on" the <dfn id='checked-pseudo'>:checked</dfn> pseudo-class applies.
	For example, [[HTML5]] defines that <a href="http://www.whatwg.org/html/selectors.html#selector-checked">checked checkboxes, radio buttons, and selected <code>&lt;option></code> elements</a> match '':checked''.

	While the '':checked'' pseudo-class is dynamic in nature,
	and can altered by user action,
	since it can also be based on the presence of semantic attributes in the document
	(such as the <code>selected</code> and <code>checked</code> attributes in [[HTML5]]),
	it applies to all media.

	<div class="example">
		An unchecked checkbox can be selected by using the negation
		pseudo-class:

		<pre>:not(:checked)</pre>
	</div>

<h4 id="indeterminate">
The indeterminate-value pseudo-class '':indeterminate''</h4>

	The <dfn id='indetermine-pseudo'>:indeterminate</dfn> pseudo-class applies to UI elements whose
	value is in an indeterminate state.
	For example, radio and checkbox elements can be toggled between checked and unchecked states,
	but are sometimes in an indeterminate state, neither checked nor unchecked.
	Similarly a progress meter can be in an indeterminate state when the percent completion is unknown.
	For example, [[HTML5]] defines how <a href="http://www.whatwg.org/html/selectors.html#selector-indeterminate">checkboxes</a> can be made to match '':indeterminate''.

	Like the '':checked'' pseudo-class, '':indeterminate''
	applies to all media. Components of a radio-group initialized with no
	pre-selected choice, for example, would be '':indeterminate''
	even in a static display.

<h3 id='ui-validity'>
Input Value-checking</h3>

<h4 id="validity-pseudos">
The validity pseudo-classes: '':valid'' and '':invalid''</h4>

	An element is <dfn id="valid-pseudo">:valid</dfn>
	or <dfn id="invalid-pseudo">:invalid</dfn>
	when its contents or value is, respectively,
	valid or invalid with respect to data validity semantics defined by the document language
	(e.g. [[XFORMS11]] or [[HTML5]]).
	An element which lacks data validity semantics is neither '':valid'' nor '':invalid''.

	Note: There is a difference between an element which has no constraints,
	and thus would always be '':valid'',
	and one which has no data validity semantics at all,
	and thus is neither '':valid'' nor '':invalid''.
	In HTML, for example, an <code>&lt;input type="text"></code> element may have no constraints,
	but a <a element>p</a> element has no validity semantics at all,
	and so it never matches either of these pseudo-classes.

<h4 id="range-pseudos">
The range pseudo-classes '':in-range'' and '':out-of-range''</h4>

	The <dfn id="in-range-pseudo">:in-range</dfn> and
	<dfn id="out-of-range-pseudo">:out-of-range</dfn> pseudo-classes
	apply only to elements that have range limitations.  An element is
	'':in-range'' or '':out-of-range'' when the value
	that the element is bound to is in range or out of range with respect
	to its range limits as defined by the document language. An element
	that lacks data range limits or is not a form control is neither
	'':in-range'' nor '':out-of-range''.
	E.g. a slider element with a value of 11 presented as a slider control
	that only represents the values from 1-10 is :out-of-range.  Another
	example is a menu element with a value of "E" that happens to be
	presented in a popup menu that only has choices "A", "B" and "C".

<h4 id="opt-pseudos">
The optionality pseudo-classes '':required'' and '':optional''</h4>

	A form element is <dfn id="required-pseudo">:required</dfn> or
	<dfn id="optional-pseudo">:optional</dfn>
	if a value for it is, respectively, required or optional before the
	form it belongs to can be validly submitted. Elements that are not
	form elements are neither required nor optional.

<h4 id="user-pseudos">
The user-interaction pseudo-class '':user-error''</h4>

	The <dfn id="user-error-pseudo">:user-error</dfn> pseudo-class
	represents an input element with incorrect input, but only
	<em>after</em> the user has significantly interacted with it.
	The '':user-error'' pseudo-class
	must match an '':invalid'', '':out-of-range'', or empty-but-'':required'' form element
	between the time the user has attempted to submit the form
	and before the user has interacted again with the form element.
	User-agents may allow it to match such elements at other times,
	as would be appropriate for highlighting an error to the user.
	For example, a UA may choose to have '':user-error'' match
	an '':invalid'' element once the user has typed some text into it
	and changed the focus to another element,
	and to stop matching only after the user has successfully corrected the input.

	<div class='example'>
		For example, the input in the following document fragment
		would match '':invalid'' as soon as the page is loaded
		(because it the initial value violates the max-constraint),
		but it won't match '':user-error'' until the user significantly interacts with the element,
		or attempts to submit the form it's part of.

		<pre>
		&lt;form>
		  &lt;label>
		    Volume:
		    &lt;input name='vol' type=number min=0 max=10 value=11>
		  &lt;/label>
		  ...
		&lt;/form>
		</pre>
	</div>

<!--
	<p class="issue">
		If it's necessary to distinguish between omitted and invalid values,
		'':user-invalid'' and '':user-omitted'' could be used.
-->

<h2 id="structural-pseudos">
Tree-Structural pseudo-classes</h2>

	Selectors introduces the concept of <dfn>structural pseudo-classes</dfn>
	to permit selection based on extra information that lies in
	the document tree but cannot be represented by other simple selectors or
	combinators.

	Standalone text and other non-element
	nodes are not counted when calculating the position of an element in the list
	of children of its parent. When calculating the position of an element in
	the list of children of its parent, the index numbering starts at 1.


<h3 id="the-root-pseudo">
'':root'' pseudo-class</h3>

	The <dfn id='root-pseudo'>:root</dfn> pseudo-class represents an element that is
	the root of the document.

	For example, in a DOM document,
	the '':root'' pseudo-class matches the root element of the <a interface>Document</a> object.
	In HTML, this would be the <a element>html</a> element
	(unless scripting has been used to modify the document).

<h3 id="the-empty-pseudo">
'':empty'' pseudo-class</h3>

	The <dfn id='empty-pseudo'>:empty</dfn> pseudo-class represents an element that has no children at all.
	In terms of the document tree,
	only element nodes and content nodes
	(such as [[DOM]] text nodes, and entity references)
	whose data has a non-zero length must be considered as affecting emptiness;
	comments, processing instructions, and other nodes
	must not affect whether an element is considered empty or not.

	<div class="example">
		Examples:
		''p:empty'' is a valid representation of the following fragment:

		<pre>&lt;p>&lt;/p></pre>

		''foo:empty'' is not a valid representation for the
		following fragments:

		<pre>&lt;foo>bar&lt;/foo></pre>

		<pre>&lt;foo>&lt;bar>bla&lt;/bar>&lt;/foo></pre>

		<pre>&lt;foo>this is not &lt;bar>:empty&lt;/bar>&lt;/foo></pre>
	</div>

<h3 id='the-blank-pseudo'>
'':blank'' pseudo-class</h3>

	The <dfn id='blank-pseudo'>:blank</dfn> pseudo-class is like the '':empty'' pseudo-class,
	except that it additionally matches elements that only contain
	<a href="http://www.w3.org/TR/css3-text/#white-space-rules">code points affected by whitespace processing</a>. [[!CSS3TEXT]]

	<div class='example'>
		For example, the following element matches '':blank'',
		but not '':empty'',
		because it contains at least one linebreak, and possibly other whitespace:

		<pre>&lt;p><br>&lt;/p></pre>
	</div>


<h3 id='child-index'>
Child-indexed Pseudo-classes</h3>

	The pseudo-classes defined in this section select elements
	based on their index in their list of siblings.

<h4 id="the-nth-child-pseudo">
'':nth-child()'' pseudo-class</h4>

	The <dfn id='nth-child-pseudo' title=":nth-child()">:nth-child(<var>An+B</var>)</dfn>
	pseudo-class notation represents an element that has <var>An+B</var>-1 siblings
	<em>before</em> it in the document tree.
	The CSS Syntax Module [[!CSS3SYN]] defines the <a href="http://dev.w3.org/csswg/css-syntax/#anb"><var>An+B</var> notation</a>.

	For example, this selector could address every other row in a table,
	and could be used to alternate the color of paragraph text in a cycle of four.

	<div class="example">
		Examples:

		<pre>
		:nth-child(10n-1)  /* represents the 9th, 19th, 29th, etc, element */
		:nth-child(10n+9)  /* Same */
		:nth-child(10n+-1) /* Syntactically invalid, and would be ignored */
		</pre>
	</div>

<h4 id="the-nth-last-child-pseudo">
'':nth-last-child()'' pseudo-class</h4>

	The <dfn id='nth-last-child-pseudo' title=":nth-last-child()">:nth-last-child(<var>An+B</var>)</dfn>
	pseudo-class notation represents an element that has <var>An+B</var>-1 siblings
	<em>after</em> it in the document tree.
	The CSS Syntax Module [[!CSS3SYN]] defines the <a href="http://dev.w3.org/csswg/css-syntax/#anb"><var>An+B</var> notation</a>.


	<div class="example">
		Examples:

		<pre>
		tr:nth-last-child(-n+2)    /* represents the two last rows of an HTML table */

		foo:nth-last-child(odd)    /* represents all odd foo elements in their parent element,
		                              counting from the last one */
		</pre>
	</div>

<h4 id="the-first-child-pseudo">
'':first-child'' pseudo-class</h4>

	The <dfn id='first-child-pseudo'>:first-child</dfn> pseudo-class
	represents an element that precedes all of its siblings (if any).
	Same as '':nth-child(1)''.

	<div class="example">
		Examples:
		The following selector represents a <a element>p</a> element that is
		the first child of a <a element>div</a> element:

		<pre>div > p:first-child</pre>

		This selector can represent the <code>p</code> inside the
		<code>div</code> of the following fragment:

		<pre>
		&lt;p> The last P before the note.&lt;/p>
		&lt;div class="note">
			 &lt;p> The first P inside the note.&lt;/p>
		&lt;/div>
		</pre>

		but cannot represent the second <code>p</code> in the following fragment:

		<pre>
		&lt;p> The last P before the note.&lt;/p>
		&lt;div class="note">
			 &lt;h2> Note &lt;/h2>
			 &lt;p> The first P inside the note.&lt;/p>
		&lt;/div>
		</pre>

		The following two selectors are usually equivalent:

		<pre>
		* > a:first-child /* a is first child of any element */
		a:first-child /* Same (assuming a is not the root element) */
		</pre>
	</div>

<h4 id="the-last-child-pseudo">
'':last-child'' pseudo-class</h4>

	The <dfn id='last-child-pseudo'>:last-child</dfn> pseudo-class
	represents an element that follows all of its siblings (if any).
	Same as '':nth-last-child(1)''.

	<div class="example">
		Example:
		The following selector represents a list item <code>li</code> that
		is the last child of an ordered list <code>ol</code>.

		<pre>ol > li:last-child</pre>
	</div>

<h4 id="the-only-child-pseudo">
'':only-child'' pseudo-class</h4>

	The <dfn id='only-child-pseudo'>:only-child</dfn> pseudo-class
	represents an element that has no siblings.
	Same as '':first-child:last-child''
	or '':nth-child(1):nth-last-child(1)'',
	but with a lower specificity.


<h3 id='typed-child-index'>
Typed Child-indexed Pseudo-classes</h3>

	The pseudo-elements in this section are similar to the <a href="#child-index">Child Index Pseudo-classes</a>,
	but they resolve based on an element's index <strong>among elements of the same <a href="#type-selectors">type (tag name)</a></strong> in their sibling list.

<h4 id="the-nth-of-type-pseudo">
'':nth-of-type()'' pseudo-class</h4>

	The <dfn id='nth-of-type-pseudo' title=":nth-of-type()">:nth-of-type(<var>An+B</var>)</dfn> pseudo-class notation
	represents an element that has <var>An+B</var>-1 siblings
	with the same <a href="http://www.w3.org/TR/css3-namespace/#expanded-name">expanded element name</a>
	<em>before</em> it in the document tree.
	The CSS Syntax Module [[!CSS3SYN]] defines the <a href="http://dev.w3.org/csswg/css-syntax/#anb"><var>An+B</var> notation</a>.

	<div class="example">
		CSS example:
		This allows an author to alternate the position of floated images:

		<pre>
		img:nth-of-type(2n+1) { float: right; }
		img:nth-of-type(2n) { float: left; }
		</pre>
	</div>


<h4 id="the-nth-last-of-type-pseudo">
'':nth-last-of-type()'' pseudo-class</h4>

	The <dfn id='nth-last-of-type' title=":nth-last-of-type()">:nth-last-of-type(<var>An+B</var>)</dfn> pseudo-class notation
	represents an element that has <var>An+B</var>-1 siblings
	with the same <a href="http://www.w3.org/TR/css3-namespace/#expanded-name">expanded element name</a>
	<em>after</em> it in the document tree.
	The CSS Syntax Module [[!CSS3SYN]] defines the <a href="http://dev.w3.org/csswg/css-syntax/#anb"><var>An+B</var> notation</a>.

	<div class="example">
		Example:
		To represent all <code>h2</code> children of an XHTML
		<code>body</code> except the first and last, one could use the
		following selector:

		<pre>body > h2:nth-of-type(n+2):nth-last-of-type(n+2) </pre>

		In this case, one could also use '':not()'', although the
		selector ends up being just as long:

		<pre>body > h2:not(:first-of-type):not(:last-of-type) </pre>
	</div>

<h4 id="the-first-of-type-pseudo">
'':first-of-type'' pseudo-class</h4>

	The <dfn id='first-of-type-pseudo'>:first-of-type</dfn> pseudo-class
	represents an element that is the first sibling
	with the same <a href="http://www.w3.org/TR/css3-namespace/#expanded-name">expanded element name</a>
	in its sibling list.
	Same as '':nth-of-type(1)''.

	<div class="example">
		Example:
		The following selector represents a definition title
		<code>dt</code> inside a definition list <code>dl</code>, this
		<code>dt</code> being the first of its type in the list of children of
		its parent element.

		<pre>dl dt:first-of-type</pre>

		It is a valid description for the first two <code>dt</code>
		elements in the following example but not for the third one:

		<pre>
		&lt;dl>
		  &lt;dt>gigogne&lt;/dt>
		  &lt;dd>
		    &lt;dl>
		      &lt;dt>fus&eacute;e&lt;/dt>
		      &lt;dd>multistage rocket&lt;/dd>
		      &lt;dt>table&lt;/dt>
		      &lt;dd>nest of tables&lt;/dd>
		    &lt;/dl>
		  &lt;/dd>
		&lt;/dl>
		</pre>
	</div>

<h4 id="the-last-of-type-pseudo">
'':last-of-type'' pseudo-class</h4>

	The <dfn id='last-of-type-pseudo'>:last-of-type</dfn> pseudo-class
	represents an element that is the last sibling
	with the same <a href="http://www.w3.org/TR/css3-namespace/#expanded-name">expanded element name</a>
	in its sibling list.
	Same as '':nth-last-of-type(1)''.

	<div class="example">
		Example:
		The following selector represents the last data cell
		<code>td</code> of a table row <code>tr</code>.

		<pre>tr > td:last-of-type</pre>
	</div>

<h4 id="the-only-of-type-pseudo">
'':only-of-type'' pseudo-class</h4>

	The <dfn id='only-of-type-pseudo'>:only-of-type</dfn> pseudo-class
	represents an element that has no siblings
	with the same <a href="http://www.w3.org/TR/css3-namespace/#expanded-name">expanded element name</a>.
	Same as '':first-of-type:last-of-type''
	or '':nth-of-type(1):nth-last-of-type(1)'',
	but with a lower specificity.


<h3 id="selected-child-index">
Selected Child-indexed Pseudo-classes</h3>

	The pseudo-classes in this section are also similar to <a href="#child-index">Child Index Pseudo-classes</a>,
	but they resolve based on an element's index in the set of siblings that match a given selector.

	Note: A selector like ''p.foo:nth-child(even)'' means
	"of all the even siblings, select the <a element>p</a> elements that have the class <code>foo</code>",
	because simple selectors match independently,
	rather than the sometimes-desired interpretation of
	"among the <a element>p</a> elements with class <code>foo</code>, select the even ones".
	The '':nth-match()'' and '':nth-last-match()'' pseudo-classes
	allow one to build a selector for the latter interpretation.

	In the <a>fast</a> Selectors profile,
	only lists of <a>compound selectors</a> are allowed within these selectors.
	In the <a>complete</a> profile,
	full <a>complex selectors</a> are allowed.

<h4 id="the-nth-match-pseudo">
'':nth-match()'' pseudo-class</h4>

	The <dfn id='nth-match-pseudo' title=":nth-match()">:nth-match(<var>An+B</var> of <var>&lt;selector></var>)</dfn> pseudo-class notation
	represents an element that has <var>An+B</var>-1 siblings
	that match the given <a>selector list</a>
	<em>before</em> it in the document tree.
	The CSS Syntax Module [[!CSS3SYN]] defines the <a href="http://dev.w3.org/csswg/css-syntax/#anb"><var>An+B</var> notation</a>.

<h4 id="the-nth-last-match-pseudo">
'':nth-last-match()'' pseudo-class</h4>

	The <dfn id='nth-last-match-pseudo' title=":nth-last-match()">:nth-last-match(<var>An+B</var> of <var>&lt;selector></var>)</dfn> pseudo-class notation
	represents an element that has <var>An+B</var>-1 siblings
	that match the given <a>selector list</a>
	<em>after</em> it in the document tree.
	The CSS Syntax Module [[!CSS3SYN]] defines the <a href="http://dev.w3.org/csswg/css-syntax/#anb"><var>An+B</var> notation</a>.


<h2 id="combinators">
Combinators</h2>

<h3 id="descendant-combinators">
Descendant combinator (<code> </code>)</h3>

	At times, authors may want selectors to describe an element that is
	the descendant of another element in the document tree (e.g., "an
	<a element>em</a> element that is contained within an <a element>H1</a> element").
	Descendant combinators express such a relationship. A
	<dfn export>descendant combinator</dfn> is <a href="#whitespace">whitespace</a> that
	separates two <a>compound selectors</a>.  A selector of the form
	''A B'' represents an element <code>B</code> that is an
	arbitrary descendant of some ancestor element <code>A</code>.

	<div class="example">
		Examples:
		For example, consider the following selector:

		<pre>h1 em</pre>

		It represents an <a element>em</a> element being the descendant of
		an <a element>h1</a> element. It is a correct and valid, but partial,
		description of the following fragment:

		<pre>
		&lt;h1>This &lt;span class="myclass">headline
		is &lt;em>very&lt;/em> important&lt;/span>&lt;/h1>
		</pre>

		The following selector:

		<pre>div * p</pre>

		represents a <a element>p</a> element that is a grandchild or later
		descendant of a <a element>div</a> element. Note the whitespace on
		either side of the "*" is not part of the universal selector; the
		whitespace is a combinator indicating that the <code>div</code> must be the
		ancestor of some element, and that that element must be an ancestor
		of the <code>p</code>.
		The following selector, which combines descendant combinators and
		<a href="#attribute-selectors">attribute selectors</a>, represents an
		element that (1) has the <code>href</code> attribute set and (2) is
		inside a <code>p</code> that is itself inside a <code>div</code>:

		<pre>div p *[href]</pre>
	</div>

<h3 id="child-combinators">
Child combinator (<code>></code>)</h3>

	A <dfn export>child combinator</dfn> describes a childhood relationship
	between two elements. A child combinator is made of the
	&quot;greater-than sign&quot; (U+003E, <code>></code>) code point and
	separates two <a>compound selectors</a>.

	<div class="example">
		Examples:
		The following selector represents a <a element>p</a> element that is
		child of <code>body</code>:

		<pre>body > p</pre>

		The following example combines descendant combinators and child
		combinators.

		<pre>div ol>li p</pre>
		<!-- LEAVE THOSE SPACES OUT! see below -->

		It represents a <a element>p</a> element that is a descendant of an
		<a element>li</a> element; the <a element>li</a> element must be the
		child of an <a element>ol</a> element; the <a element>ol</a> element must
		be a descendant of a <code>div</code>. Notice that the optional white
		space around the ">" combinator has been left out.
	</div>

	For information on selecting the first child of an element,
	please see the section on the '':first-child'' pseudo-class above.

<h3 id="adjacent-sibling-combinators">
Next-sibling combinator (<code>+</code>)</h3>

	The <dfn export>next-sibling combinator</dfn> is made of the “plus sign”
	(U+002B, <code>+</code>) code point that separates two
	<a>compound selectors</a>.
	The elements represented by the two <a>compound selectors</a>
	share the same parent in the document tree
	and the element represented by the first <a>compound selector</a>
	immediately precedes the element represented by the second one.
	Non-element nodes (e.g. text between elements)
	are ignored when considering the adjacency of elements.

	<div class="example">
		Examples:
		The following selector represents a <a element>p</a> element
		immediately following a <a element>math</a> element:

		<pre>math + p</pre>

		The following selector is conceptually similar to the one in the
		previous example, except that it adds an attribute selector &mdash; it
		adds a constraint to the <a element>h1</a> element, that it must have
		<code>class="opener"</code>:

		<pre>h1.opener + h2</pre>
	</div>


<h3 id="general-sibling-combinators">
Following-sibling combinator (<code>~</code>)</h3>

	The <dfn export>following-sibling combinator</dfn> is made of the &quot;tilde&quot;
	(U+007E, <code>~</code>) code point that separates two <a>compound selectors</a>.
	The elements represented by the two <a>compound selectors</a> share
	the same parent in the document tree and the element represented by
	the first compound selector precedes (not necessarily immediately) the element
	represented by the second one.

	<div class="example">
		<pre>h1 ~ pre</pre>

		represents a <a element>pre</a> element following an <code>h1</code>. It
		is a correct and valid, but partial, description of:

		<pre>
		&lt;h1>Definition of the function a&lt;/h1>
		&lt;p>Function a(x) has to be applied to all figures in the table.&lt;/p>
		&lt;pre>function a(x) = 12x/13.5&lt;/pre>
		</pre>
	</div>

<h3 id="idref-combinators">
Reference combinators <code>/ref/</code></h3>

	The <dfn export>reference combinator</dfn> consists of two slashes
	with an intervening <a href="http://www.w3.org/TR/css3-namespace/#css-qnames">CSS qualified name</a>,
	and separates two <a>compound selectors</a>,
	e.g. ''A /attr/ B''.
	The element represented by the first <a>compound selector</a>
	explicitly references
	the element represented by the second <a>compound selector</a>.
	Unless the host language defines a different syntax for expressing this relationship,
	this relationship is considered to exist if
	the value of the specified attribute on the first element is an IDREF or an <a>ID selector</a>
	referencing the second element.

	Attribute matching for reference combinators follow the same rules as for <a href="http://www.w3.org/TR/css3-selectors/#attribute-selectors">attribute selectors</a>.

	<div class="example">
		The following example highlights an <a element>input</a> element
		when its <a href="http://www.w3.org/TR/html40/interact/forms.html#h-17.9"><code>&lt;label></code></a>
		is focused or hovered-over:

		<pre>
		label:matches(:hover, :focus) /for/ input,       /* association by "for" attribute */
		label:matches(:hover, :focus):not([for]) input { /* association by containment */
			box-shadow: yellow 0 0 10px;
		}
		</pre>
	</div>

<h2 id="table-pseudos">
Grid-Structural Selectors</h2>

	The double-association of a cell in a 2D grid (to its row and column)
	cannot be represented by parentage in a hierarchical markup language.
	Only one of those associations can be represented hierarchically: the
	other must be explicitly or implicitly defined in the document language
	semantics. In both HTML and DocBook, two of the most common hierarchical
	markup languages, the markup is row-primary (that is, the row associations
	are represented hierarchically); the columns must be implied.
	To be able to represent such implied column-based relationships, the
	<a>column combinator</a> and the
	'':nth-column()'' and '':nth-last-column()'' pseudo-classes
	are defined.
	In a column-primary format, these pseudo-classes match against row associations instead.

<h3 id="column-combinator">
Column combinator</h3>

	The <dfn export>column combinator</dfn>, which consists of two pipes (''||'')
	represents the relationship of a column element
	to a cell element belonging to the column it represents.
	Column membership is determined based on the semantics of the document language only:
	whether and how the elements are presented is not considered.
	If a cell element belongs to more than one column,
	it is represented by a selector indicating membership in any of those columns.

	<div class="example">
		The following example makes cells C, E, and G yellow.

		<pre>
		col.selected || td {
			background: gray;
			color: white;
			font-weight: bold;
		}
		</pre>

		<pre>
		&lt;table>
			&lt;col span="2">
			&lt;col class="selected">
			&lt;tr>&lt;td>A &lt;td>B &lt;td>C
			&lt;tr>&lt;td colspan="2">D &lt;td>E
			&lt;tr>&lt;td>F &lt;td colspan="2">G
		&lt;/table>
		</pre>
	</div>

<h3 id="the-nth-column-pseudo">
'':nth-column()'' pseudo-class</h3>

	The <dfn id='nth-column-pseudo' title=":nth-column()">:nth-column(<var>An+B</var>)</dfn>
	pseudo-class notation represents a cell element belonging to a column
	that has <var>An+B</var>-1 columns
	<strong>before</strong> it, for any positive
	integer or zero value of <code>n</code>. Column membership is determined
	based on the semantics of the document language only: whether and how the
	elements are presented is not considered. If a cell element belongs to
	more than one column, it is represented by a selector indicating any of
	those columns.

	The CSS Syntax Module [[!CSS3SYN]] defines the <a href="http://dev.w3.org/csswg/css-syntax/#anb"><var>An+B</var> notation</a>.



<h3 id="the-nth-last-column-pseudo">
'':nth-last-column()'' pseudo-class</h3>

	The <dfn id='nth-last-column-pseudo' title=":nth-last-column()">:nth-last-column(<var>An+B</var>)</dfn>
	pseudo-class notation represents a cell element belonging to a column
	that has <var>An+B</var>-1 columns
	<strong>after</strong> it, for any positive
	integer or zero value of <code>n</code>. Column membership is determined
	based on the semantics of the document language only: whether and how the
	elements are presented is not considered. If a cell element belongs to
	more than one column, it is represented by a selector indicating any of
	those columns.

	The CSS Syntax Module [[!CSS3SYN]] defines the <a href="http://dev.w3.org/csswg/css-syntax/#anb"><var>An+B</var> notation</a>.

<h2 id="specificity">
Calculating a selector's specificity</h2>

	A selector's specificity is calculated for a given element as follows:

	<ul>
		<li>count the number of ID selectors in the selector (= <var>A</var>)
		<li>count the number of class selectors, attributes selectors, and pseudo-classes in the selector (= <var>B</var>)
		<li>count the number of type selectors and pseudo-elements in the selector (= <var>C</var>)
		<li>ignore the universal selector
	</ul>

	In most cases, a selector has the same specificity for every element it applies to.
	The specificity of a <a href="#matches">:matches()</a> pseudo-class, however,
	is the specificity of the most specific complex selector that matched the given element.
	(The full selector's specificity is equivalent to expanding out all the combinations in full, without '':matches()''.)
	The specificity of a <a href="#negation">:not()</a> pseudo-class is
	the specificity of the most specifc complex selector in its selector list.
	In either case, the pseudo-class itself does not contribute any additional specificity.
	For example, '':matches(em, strong)'' has a specificity of (0,0,1), like a tag selector.

	Specificities are compared by comparing the three components in order:
	the specificity with a larger <var>A</var> value is more specific;
	if the two <var>A</var> values are tied,
	then the specificity with a larger <var>B</var> value is more specific;
	if the two <var>B</var> values are also tied,
	then the specificity with a larger <var>C</var> value is more specific;
	if all the values are tied,
	the two specifities are equal.

	Due to storage limitations,
	implementations may have limitations on the size of <var>A</var>, <var>B</var>, or <var>C</var>.
	If so, values higher than the limit must be clamped to that limit,
	and not overflow.

	<div class="example">
		Examples:
		<pre>
		*               /* a=0 b=0 c=0 */
		LI              /* a=0 b=0 c=1 */
		UL LI           /* a=0 b=0 c=2 */
		UL OL+LI        /* a=0 b=0 c=3 */
		H1 + *[REL=up]  /* a=0 b=1 c=1 */
		UL OL LI.red    /* a=0 b=1 c=3 */
		LI.red.level    /* a=0 b=2 c=1 */
		#x34y           /* a=1 b=0 c=0 */
		#s12:not(FOO)   /* a=1 b=0 c=1 */
		.foo :matches(.bar, #baz)
		                /* Either a=1 b=1 c=0
		                   or a=0 b=2 c=0, depending
		                   on the element being matched. */
		</pre>
	</div>

	Note: Repeated occurrences of the
	same simple selector are allowed and do increase specificity.

	Note: The specificity of the styles
	specified in an HTML <code>style</code> attribute <a href="http://www.w3.org/TR/css-style-attr/#interpret">is described in CSS Style Attributes</a>. [[CSSSTYLEATTR]]

<h2 id="grammar"><span id="formal-syntax"></span>
Grammar</h2>

	The grammar below defines the syntax of Selectors.
	It is applied to a stream of tokens,
	as returned by the tokenizer defined in [[!CSS3SYN]].
	It is globally LL(1) and can be locally LL(2)
	(but note that most UAs should not use it directly,
	since it doesn't express the parsing conventions).
	The format of the productions is optimized for human consumption
	and some shorthand notations beyond Yacc (see [[!YACC]]) are used:

	<ul>
		<li><b>*</b>: 0 or more
		<li><b>+</b>: 1 or more
		<li><b>?</b>: 0 or 1
		<li><b>|</b>: separates alternatives
		<li><b>[ ]</b>: grouping
	</ul>

	The productions in uppercase are defined by CSS Syntax [[!CSS3SYN]],
	and correspond to the tokens of the same name.
	Literal strings correspond to delim tokens with the given value.
	Unlike other grammars in CSS, whitespace is not ignored
	The production "S" represents a whitespace token.
	The wqname_prefix production comes from the Namespaces spec [[!CSS3NAMESPACE]]

	The productions are:

	<pre>
		complex_selector_list
			: complex_selector [ COMMA S* complex_selector ]*
			;

		scope_relative_selector_list
			: scope_relative_selector [ COMMA s* scope_relative_selector ]*

		scope_relative_selector
			: combinator? complex_selector
			;

		complex_selector
			: compound_selector [ combinator compound_selector ]* S*
			;

		combinator
			/* combinators can be surrounded by whitespace */
			: S+ | S* [ '>' | '+' | '~' | COLUMN | '/' IDENT '/' ] S*
			;

		compound_selector_list
			: compound_selector S* [ COMMA S* compound_selector ]* S*

		compound_selector
			: type_selector [ id | class | attrib | pseudo ]*
				| [ id | class | attrib | pseudo ]+
			;

		simple_selector_list
			: simple_selector S* [ COMMA S* simple_selector ] S*

		simple_selector
			: type_selector | id | class | attrib | pseudo

		type_selector
			: wqname_prefix? element_name
			;

		element_name
			: IDENT | '*'
			;

		id
			: HASH
			;

		class
			: '.' IDENT
			;

		attrib
			: '[' S* attrib_name ']'
				| '[' S* attrib_name attrib_match [ IDENT | STRING ] S* attrib_flags? ']'
			;

		attrib_name
			: wqname_prefix? IDENT S*

		attrib_match
			: [ '=' |
					PREFIX-MATCH |
					SUFFIX-MATCH |
					SUBSTRING-MATCH |
					INCLUDE-MATCH |
					DASH-MATCH
				] S*

		attrib_flags
			: IDENT S*

		pseudo
			/* '::' starts a pseudo-element, ':' a pseudo-class */
			/* Exceptions: :first-line, :first-letter, :before and :after. */
			/* Note that pseudo-elements are restricted to one per selector and */
			/* occur only in the last compound_selector. */
			: ':' ':'? [ IDENT | functional_pseudo ]
			;

		functional_pseudo
			: FUNCTION S* value ')'
			;
	</pre>

	To aid with the authoring of property grammars,
	the following CSS grammar productions are defined:

	<dl>
		<dt><dfn><var>&lt;selector></var></dfn>
		<dd>
			A <code>complex_selector_list</code> production representing
			a <a>selector list</a>.

		<dt><dfn><var>&lt;relative-selector></var></dfn>
		<dd>
			A <code>scope_relative_selector_list</code> production representing
			a <a>selector list</a> comprised of <a>relative selectors</a>.

		<dt><dfn><var>&lt;compound-selector></var></dfn>
		<dd>
			A <code>compound_selector_list</code> production representing
			a <a>selector list</a> comprised of <a>compound selectors</a>.

		<dt><dfn><var>&lt;id-selector></var></dfn>
		<dd>
			An <code>id</code> production representing
			an <a>ID selector</a>
	</dl>

<h2 id='api-hooks'>
API Hooks</h2>

	To aid in the writing of specs that use Selectors concepts,
	this section defines several API hooks that can be invoked by other specifications.

<h3 id='parse-a-selector'>
Parse A Selector</h3>

	This section defines how to <dfn export>parse a selector</dfn> from a string <var>source</var>.
	It returns either a complex selector list,
	or failure.

	<ol>
		<li>
			Let <var>selector</var> be the result of parsing <var>source</var> against the <code>complex_selector_list</code> grammar.
			If it does not match the grammar,
			return failure.

		<li>
			Otherwise,
			if any simple selectors in <var>selector</var> are not recognized by the user agent,
			or <var>selector</var> is otherwise invalid in some way
			(such as, for example, containing an undeclared namespace prefix),
			return failure.

		<li>
			Otherwise,
			return <var>selector</var>.
	</ol>

<h3 id='parse-a-relative-selector'>
Parse A Relative Selector</h3>

	This section defines how to <dfn export>parse a relative selector</dfn> from a string <var>source</var>,
	against <a>:scope elements</a> <var>refs</var>.
	It returns either a complex selector list,
	or failure.

	<ol>
		<li>
			Let <var>selector</var> be the result of parsing <var>source</var> against the <code>scope_relative_selector_list</code> grammar.
			If it does not match the grammar,
			return failure.

		<li>
			Otherwise,
			if any simple selectors in <var>selector</var> are not recognized by the user agent,
			or <var>selector</var> is otherwise invalid in some way
			(such as, for example, containing an undeclared namespace prefix),
			return failure.

		<li>
			Otherwise,
			<a title="absolutize a relative selector list">absolutize <var>selector</var></a> with <var>refs</var> as the <a>:scope elements</a>.

		<li>
			Return <var>selector</var>.
	</ol>


<h2 id="changes">
Changes</h2>

	Significant changes since the <a href="http://www.w3.org/TR/2013/WD-selectors4-20130502/">2 May 2013 Working Draft</a> include:

	<ul>
		<li>Split out <a>relative selectors</a> from <a>scoped selectors</a>,
			as these are different concepts that can be independently invoked.
	</ul>


<h2 id="acknowledgements">
Acknowledgements</h2>

	The CSS working group would like to thank everyone who contributed
	to the <a href="http://www.w3.org/TR/css3-selectors">previous Selectors</a> specifications over the years,
	as those specifications formed the basis for this one.
	In particular, the working group would like to extend special thanks
	to the following for their specific contributions to Selectors Level 4:
	L. David Baron,
	Andrew Fedoniouk,
	Ian Hickson,
	Grey Hodge,
	Lachlan Hunt,
	Jason Cranford Teague
