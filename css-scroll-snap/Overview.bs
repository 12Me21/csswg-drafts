<pre class='metadata'>
Title: CSS Scroll Snapping Change Proposal
Shortname: css-scroll-snap
Level: 1
Status: UD
Work Status: exploring
Group: CSSWG
ED: https://drafts.csswg.org/css-scroll-snap/
Editor: Tab Atkins-Bittner, Google, http://xanthir.com/contact/
Editor: Elika J. Etemad / fantasai, Invited Expert, http://fantasai.inkedblade.net/contact
Abstract: A brief description of an alternate model for scroll-snapping.
Ignored Terms: snap position, snap positions, inertial scroll, inertial scrolls, semantic scroll, semantic scrolls, scrollable area, scroll-group-align, containing block chain
At Risk: ''point'' value of 'scroll-snap-type'
</pre>

<pre class="link-defaults">
spec: css-shapes-1; type: value; for: <shape-box>
	text: border-box
	text: margin-box
spec: css-writing-modes-3; type: dfn
	text: start
	text: end
</pre>

Introduction {#intro}
=====================

We think scroll snapping is a great idea, and fully support exposing this functionality through CSS. However, a major weakness of the current spec is the way it conceives snapping on a coordinate model rather than a box model. This requires a lot of manual calculations in figuring out the correct coordinates from the box model; and also makes sensible scroll-snap settings dependent on the relative sizes of the viewport and the snappable contents, causing problems for users are unexpectedly large and/or small screens (a problem commonly ignored by many authors).

This proposal builds off of roc's model, using an area-snapping model to intelligently handle adaptation to multiple screen sizes. It also adds group alignment as a built-in concept, rather than requiring authors to build one in JavaScript.

Use Cases {#use-cases}
======================

<div class="example">
	Use Case 1: Snapping to the start or middle of each box
	e.g. address book (start) or photo album (middle)

	1. Snapping to 0.25rem above the top of each heading

		<pre class="lang-css">
		:root { scroll-snap-type: proximity; }
		h1, h2, h3, h4, h5, h6 {
			scroll-snap-align: start;
			scroll-snap-area: 0.25em;
		}
		</pre>

	2. Snapping to the center of each photo

		<pre class="lang-css">
		:root { scroll-snap-type: mandatory; }
		img { scroll-snap-align: center; }
		</pre>
</div>

<div class="example">
	Use Case 2: Snapping to boxes (or points) in 2D
	e.g. on a map, where you want to snap points of interest to the
	center, or a flow-chart diagram, where you want to snap the edges
	of each box into the visible area. In both cases, you don't want
	objects wholly outside the visible area to influence snapping.

	1. Snapping each flow chart entry to within the viewport when it falls near the edge:

		<pre class="lang-css">
		:root {
			scroll-snap-type: proximity;
		}
		li {
			scroll-snap-align: edges;
		}
		</pre>

	2. Snapping each city on a map to the center of the viewport,
		but only once it gets near the center in both dimensions:

		<pre class="lang-css">
		:root {
			scroll-snap-type: proximity;
		}
		.city {
			scroll-snap-align: center;
		}
		</pre>
</div>

<div class="example">
	Use Case 3: Slideshow, where successive slides are arranged horizontally,
	and sometimes "detail" slides are placed below the "main" slide for that point.

	<pre class="lang-html">
		&lt;div class="slides">
			&lt;div class="slide">...&lt;/div>
			&lt;div class="slide">...&lt;/div>
			&lt;div class="slide details">
				&lt;div class="slide">...&lt;/div>
				&lt;div class="slide">...&lt;/div>
			&lt;/div>
			&lt;div class="slide">...&lt;/div>
		&lt;/div>
		&lt;style>
		.slides {
			display: flex;
			flex-flow: row;
			scroll-snap-type: mandatory;
			overflow-x: scroll;
			width: 100vw;
			height: 100vh;
		}
		.slide {
			scroll-snap-align: edges;
			width: 100vw;
			min-height: 100vh;
		}
		.slide.details {
			display: flex;
			flex-flow: column;
			scroll-snap-type: mandatory;
			overflow-y: scroll;
		}
		&lt;/style>
	</pre>
</div>

Overview of Change {#proposal}
==============================

On the scroll container:

<table class=data>
	<thead>
		<tr>
			<th>Spec
			<th>Proposal
			<th>Priority
	<tbody>
		<tr>
			<td>''scroll-snap-type: none | mandatory | proximity''
			<td>''scroll-snap-type: none | [ mandatory | proximity ] || [ x | y | block | inline | both | point]''
			<td>High priority
		<tr>
			<td>''scroll-snap-destination: <<position>>''
			<td>''scroll-snap-padding: [ <<length>> | <<percentage>> ]{1,4}''
			<td>
</table>

On the children:

<table class=data>
	<thead>
		<tr>
			<th>Spec
			<th>Proposal
			<th>Priority
	<tbody>
		<tr>
			<td>''scroll-snap-coordinate: <<position>>#''
			<td>''scroll-snap-align: [ none | start | end | center | edges ]{1,2}''
			<td>High priority
		<tr>
			<td>n/a
			<td>''scroll-snap-area: <<length>>{1,4}''
			<td>High priority
</table>

Scroll Snapping Model {#snap-model}
=====================

	This module introduces control over <dfn lt="scroll snap position" local-lt="snap position">scroll snap positions</dfn>,
	which are scroll positions that produce particular alignments
	of content within a scrollable viewport.
	Using the 'scroll-snap-type' propoperty on the relevant <a>scroll container</a>,
	the author can request a particular bias
	for the viewport to land on a valid <a>snap position</a>
	during scrolling operations.

	Valid <a>snap positions</a> can be specified
	as a particular alignment ('scroll-snap-align')
	of an element's <a>scroll snap area</a> ('scroll-snap-area', defaulting to its border box)
	within the <a>scroll container</a>’s <a>snap viewport</a>
	(its viewport, as reduced by 'scroll-snap-padding').
	This is conceptually equivalent to specifying the alignment of
	an <a>alignment subject</a> within an <a>alignment container</a>.
	The scroll position that satisfies the specified alignment
	is a valid <a>snap position</a>.

	<a>Snap positions</a> must only affect the nearest ancestor
	(on the element's <a>containing block chain</a>)
	<a>scroll container</a>.

Scroll Snapping Container {#snap-container}
=========================

<!--
████████ ██    ██ ████████  ████████
   ██     ██  ██  ██     ██ ██
   ██      ████   ██     ██ ██
   ██       ██    ████████  ██████
   ██       ██    ██        ██
   ██       ██    ██        ██
   ██       ██    ██        ████████
-->

Scroll Snapping Rules: the 'scroll-snap-type' property {#snap-type}
----------------------


	<pre class="propdef">
	Name: scroll-snap-type
	Value: none | [ proximity | mandatory ] || [ x | y | block | inline | both | point ]
	Initial: none
	Applies to: all elements
	Inherited: no
	Percentages: n/a
	Computed value: as specified
	Animatable: no
	Media: interactive
	</pre>

	The 'scroll-snap-type' property is used to specify
	whether and how strictly <a>snap positions</a> are intepreted on the <a>scroll container</a>,
	and which axes are considered.

	Issue: <a href="https://lists.w3.org/Archives/Public/www-style/2015Nov/0328.html">We're considering splitting this into subproperties.</a>
	Current proposed names are <css>scroll-snap</css> for the current grammar,
	<css>scroll-snap-affinity</css> for the proximity/mandatory distinction,
	and <css>scroll-snap-axis</css> for the x/y/etc distinction.

	The strictness values (''scroll-snap-type/none'', ''proximity'', ''mandatory'') specify
	how strictly <a>snap positions</a> are enforced on the <a>scroll container</a>
	(by forcing an adjustment to the scroll offset).
	It intentionally does not specify nor mandate
	any precise animations or physics used to enforce those <a>snap positions</a>;
	this is left up to the user agent.
	Values are defined as follows:

	<dl dfn-type=value dfn-for=scroll-snap-type>
		<dt><dfn>none</dfn>
		<dd>
			If specified on a <a>scroll container</a>,
			the visual viewport of this <a>scroll container</a>
			must ignore <a>snap positions</a>, if any, when scrolled:
			all scroll positions are equally valid.

			If specified on a non-<a>scroll container</a>,
			this value has no effect.

		<dt><dfn>proximity</dfn>
		<dd>
			If specified on a <a>scroll container</a>,
			the visual viewport of this <a>scroll container</a>
			may come to rest at a <a>snap position</a> at the termination of a scroll
			at the discretion of the UA given the parameters of the scroll.

			If specified on a non-<a>scroll container</a>,
			this value “traps” descendant boxes’ <a>snap positions</a>,
			preventing them from affecting any ancestor <a>scroll containers</a>.

			If the content of the <a>scroll container</a> changes
			(e.g. content is added, moved, deleted, resized),
			the UA must re-snap as if the user explicitly scrolled to the current scroll offset
			once the positions of the content and any active scrolling actions have restabilized.
			(This can result in no snapping,
			if there are no nearby <a>snap positions</a>.)
			In addition, if the previously-snapped <a>snap position</a>
			(associated with the same element)
			still exists after such changes,
			the UA must re-snap to it
			(even if the changes would place a different <a>snap position</a>
			closer to the current scroll offset).

			Issue: Should the element-follow behavior be MUST or SHOULD here?

		<dt><dfn>mandatory</dfn>
		<dd>
			If specified on a <a>scroll container</a>,
			the visual viewport of this <a>scroll container</a>
			is guaranteed to rest at a <a>snap position</a>
			when there are no active scrolling operations.
			That is, it must come to rest at a <a>snap position</a>
			at the termination of a scroll, if any exist.
			(If none exist, then no snapping occurs.)

			If specified on a non-<a>scroll container</a>,
			this value “traps” descendant boxes’ <a>snap positions</a>,
			preventing them from affecting any ancestor <a>scroll containers</a>.

			If the content changes such that the visual viewport
			would no longer rest at a <a>snap position</a>
			(e.g. content is added, moved, deleted, resized),
			the scroll offset must be modified to maintain this guarantee,
			once the positions of the content and any active scrolling actions have restabilized.
			In addition, if the previously-snapped <a>snap position</a>
			(associated with the same element)
			still exists after such changes,
			the UA must re-snap to it.
	</dl>

	Advisement:
	Authors should use mandatory snap positions with consideration of
	varyingly-sized screens and (if applicable) varying-sized content.
	In particular, although access to snapped elements larger than the viewport
	is <a href="#snap-overflow">handled by the UA</a>,
	if authors assign mandatory snapping to non-adjacent siblings,
	content in between can become inaccessible
	in cases where it is longer than the screen.

	<div class="example">
		For example, if an author wishes to force snapping to the top of each section heading,
		s/he could accomplish this in two ways: snapping the headings
		<pre>h1, h2, h3, h4, h5, h6 { scroll-snap-align: start; } /* snap headings - but not section content */</pre>
		or snapping the section elements.
		<pre>section { scroll-snap-align: start; }                /* snap entire section - including content */</pre>
		If the author chooses mandatory snapping of the headings,
		and one section is longer than the viewport,
		then the reader will have difficulty accessing the content that overflows the screen,
		because mandatory snapping does not allow the scroll position to rest
		on the content between the snapped headings.

		However, if the author chooses mandatory snapping of the section element
		(which contains all the content of the section)
		then the UA can allow the reader to scroll freely through the entire section
		in the cases where the content is longer than the screen.
	</div>

	The axis values specifies what axis(es) are affected by <a>snap positions</a>,
	and whether <a>snap positions</a> are evaluated per-axis independently (<a>1d snap positions</a>)
	or together (<a>2d snap positions</a>).
	Values are defined as follows:

	<dl dfn-type=value dfn-for="scroll-snap-type">
		<dt><dfn>x</dfn>
		<dd>
			The <a>scroll container</a> pays attention to <a>snap positions</a> in its horizontal axis only.

		<dt><dfn>y</dfn>
		<dd>
			The <a>scroll container</a> pays attention to <a>snap positions</a> in its vertical axis only.

		<dt><dfn>block</dfn>
		<dd>
			The <a>scroll container</a> pays attention to <a>snap positions</a> in its block axis only.

		<dt><dfn>inline</dfn>
		<dd>
			The <a>scroll container</a> pays attention to <a>snap positions</a> in its inline axis only.

		<dt><dfn>both</dfn>
		<dd>
			The <a>scroll container</a> pays attention to <a>snap positions</a> in both of its axises independently,
			as <a>1D snap positions</a>.

		<dt><dfn>point</dfn>
		<dd>
			The <a>scroll container</a> pays attention to <a>snap positions</a> in both of its axises together,
			as <a>2D snap positions</a>.
	</dl>

	If no axis value is specified, then the axis is automatically computed:
		*	If the box is only scrollable in one axis
			(only one axis has its 'overflow' set to ''overflow/auto'' or ''overflow/scroll'')
			the scrollable axis is chosen.
		*	Otherwise, the box’s <a>block axis</a> is chosen.

<!--
████████     ███    ████████  ████████  ████ ██    ██  ██████
██     ██   ██ ██   ██     ██ ██     ██  ██  ███   ██ ██    ██
██     ██  ██   ██  ██     ██ ██     ██  ██  ████  ██ ██
████████  ██     ██ ██     ██ ██     ██  ██  ██ ██ ██ ██   ████
██        █████████ ██     ██ ██     ██  ██  ██  ████ ██    ██
██        ██     ██ ██     ██ ██     ██  ██  ██   ███ ██    ██
██        ██     ██ ████████  ████████  ████ ██    ██  ██████
-->

Scroll Snapping Window: the 'scroll-snap-padding' property {#snap-padding}
-----------------------

	<pre class="propdef">
	Name: scroll-snap-padding
	Value: [ <<length>> | <<percentage>> ]{1,4}
	Initial: 0
	Applies to: <a>scroll containers</a>
	Inherited: no
	Percentages: relative to the corresponding axis of the element's visual viewport
	Computed value: as specified
	Animatable: see individual properties
	Media: interactive
	</pre>

	The 'scroll-snap-padding' property defines the <dfn local-lt="snap viewport">scroll snap viewport</dfn>--
	the area of the viewport that is used as the <a>alignment container</a>
	when aligning a <a>scroll snap area</a> to a <a>snap position</a>.
	Values are interpreted as for 'padding',
	and specify inward offsets from each side of the viewport.

	<div class="example">
		In this example, points of interest in a map are centered
		within the portion of the viewport that does not include the toolbar overlay.

		<pre>
			map {
			  overflow: scroll;
			  scroll-snap-type: proximity;
			  scroll-snap-padding: 3em 0 0 0;
			}
			toolbar {
				position: absolute;
				margin: 0.5em;
				top: 0; left: 0; right: 0;
				height: 2em;
			}
			city {
				scroll-snap-align: center;
			}
		</pre>
	</div>

	This property is a <a>shorthand property</a> that sets
	all of the <a href="#longhands"><css>scroll-snap-padding-*</css> longhands</a>
	in one declaration.

Element-based Snapping {#element}
======================

<!--
   ███    ████████  ████████    ███
  ██ ██   ██     ██ ██         ██ ██
 ██   ██  ██     ██ ██        ██   ██
██     ██ ████████  ██████   ██     ██
█████████ ██   ██   ██       █████████
██     ██ ██    ██  ██       ██     ██
██     ██ ██     ██ ████████ ██     ██
-->

Scroll Snapping Area: the 'scroll-snap-area' property {#scroll-snap-areas}
---------------------

	<pre class="propdef">
	Name: scroll-snap-area
	Value: <<length>>{1,4}
	Initial: 0
	Applies to: all elements
	Inherited: no
	Computed value: as specified, with lengths made absolute
	Animatable: see individual properties
	Media: interactive
	</pre>

	Specifies the <dfn lt="scroll snap area" local-lt="snap area">scroll snap area</dfn>
	that is used for snapping this box to the viewport.
	<<length>> values give outsets (similar to 'margin' or 'border-image-outset').
	The <a>scroll snap area</a> is the bounding box of the transformed border box,
	in the <a>scroll container’s</a> coordinate space.
	Outsets are applied to the bounding box,
	not the border box.

	Note: This ensures that the <a>scroll snap area</a> is always rectangular and axis-aligned
	to the <a>scroll container’s</a> coordinate space.

	This property is a <a>shorthand property</a> that sets
	all of the <a href="#longhands"><css>scroll-snap-area-*</css> longhands</a>
	in one declaration.

<!--
   ███    ██       ████  ██████   ██    ██
  ██ ██   ██        ██  ██    ██  ███   ██
 ██   ██  ██        ██  ██        ████  ██
██     ██ ██        ██  ██   ████ ██ ██ ██
█████████ ██        ██  ██    ██  ██  ████
██     ██ ██        ██  ██    ██  ██   ███
██     ██ ████████ ████  ██████   ██    ██
-->

Scroll Snapping Alignment: the 'scroll-snap-align' property {#scroll-snap-alignment}
--------------------------

	<pre class="propdef">
	Name: scroll-snap-align
	Value: [ none | edges | start | end | center ]{1,2}
	Initial: none
	Applies to: all elements
	Inherited: no
	Percentages: n/a
	Computed value: two keywords
	Animatable: no
	Media: interactive
	</pre>

	Specifies the element's <a>snap position</a> as an alignment of
	its <a>snap area</a> (as the <a>alignment subject</a>)
	within the viewport's <a>snap viewport</a> (as the <a>alignment container</a>).
	The two values specify the snapping behavior in the <a>inline axis</a> and <a>block axis</a>,
	respectively.
	If only one value is specified,
	the second value defaults to the same value.

	<div class="example">
		The following example aligns the start edge of the box's <a>snap area</a>
		to the start edge of the scroll container's <a>snap viewport</a>:

		<pre>section { scroll-snap-align: start; }</pre>

		The following example aligns the center of each city
		to the center of the scroll container's <a>snap viewport</a>,
		snapping only when the city is centered in both axes:

		<pre>
			.map { scroll-snap-type: proximity point; }
			.map .city { scroll-snap-align: center; }
		</pre>

		The following example aligns the center of each photo
		to the center of the scroll container's <a>snap viewport</a>,
		snapping independently in each axis:

		<pre>
			.photos { scroll-snap-type: mandatory both; }
			img { scroll-snap-align: center; }
		</pre>
	</div>

	The <dfn export>scroll alignment values</dfn> are defined as follows:

	<dl dfn-type=value dfn-for="scroll-snap-align">
		<dt><dfn>none</dfn>
		<dd>
			This box does not define a <a>snap position</a> in the specified axis.

		<dt><dfn>start</dfn>
		<dd>
			Start alignment of this box's <a>scroll snap area</a>
			within the <a>scroll container</a>'s <a>snap viewport</a>
			is a valid <a>snap position</a>.

		<dt><dfn>end</dfn>
		<dd>
			End alignment of this box's <a>scroll snap area</a>
			within the <a>scroll container</a>'s <a>snap viewport</a>
			is a valid <a>snap position</a>.

		<dt><dfn>center</dfn>
		<dd>
			Center alignment of this box's <a>scroll snap area</a>
			within the <a>scroll container</a>'s <a>snap viewport</a>
			is a valid <a>snap position</a>.

		<dt><dfn>edges</dfn>
		<dd>
			Both start alignment and end alignment of this box's <a>scroll snap area</a>
			within the <a>scroll container</a>'s <a>snap viewport</a>
			are valid <a>snap positions</a>.

			Issue: It's not 100% clear if this value is necessary, given handling for <a href="#snap-overflow">over-large elements</a>.
	</dl>

	If the element's <a>scroll container</a> is set to ''point'',
	and this property does not specify a single valid <a>snap position</a> in both axises
	(that is, it contains ''scroll-snap-align/none'' or ''edges''),
	the element does not contribute any <a>snap positions</a> at all.

	For all of these values,
	the <a>block</a> or <a>inline</a> axis
	is relative to the element's parent's <a>writing mode</a>.

	Issue: Is this the correct writing mode to compute against?
	Or should it be the scroll container's writing mode?

	<details class="why">
		<summary>Why no <<length>> or <<position>> values?</summary>

		The values here represent alignments
		(in the sense of 'align-self' and 'justify-self'),
		so are consistent with that syntax.
		We chose to use this simpler syntax without lengths or percentages
		because the 'scroll-snap-area' concept already provides length offsets--
		but does so in a smarter way, that degrades better on small screens
		(see above) because it provides more information (a box, rather than a point) to the UA.
		We could have also added lengths here,
		but it would provide multiple ways to do the same thing,
		which is additional overhead for implementation, testing, and (most importantly) author learning.
		It also introduces more room for cascading errors,
		and guides authors in the wrong direction--
		away from 'scroll-snap-area'.
	</details>

<h4 id="snap-scope">
Scoping Valid Snap Positions to Visible Boxes</h4>

	Since the purpose of scroll snapping is to align content within the viewport
	for optimal viewing:
	in all cases, the specified alignment creates a valid <a>snap position</a>
	only if at least part of the <a>snap area</a> is within the <a>snap viewport</a>.
	For example, a <a>snap area</a> is top-aligned to the <a>snap viewport</a>
	if its top edge is coincident with the <a>snap viewport</a>’s top edge;
	however, this alignment is nonetheless not a valid <a>snap position</a>
	if the entire <a>snap area</a> is outside the <a>snap viewport</a>.

	<details class="why">
		<summary>Why limit snapping to only when the element is visible?</summary>
		As the <a href="https://www.webkit.org/blog/4017/scroll-snapping-with-css-snap-points/">WebKit implementers point out</a>,
		extending a snap edge infinitely across the canvas
		only allows for snapping gridded layouts,
		and produces odd behavior for the user
		when off-screen elements do not align
		with on-screen elements.
		(If this requirement is onerous for implementers however,
		we can default to a gridded behavior
		and introduce a switch to get smarter behavior.)
	</details>

<h4 id="snap-overflow">
Snapping Boxes that Overflow the Scrollport</h4>

	If the <a>snap area</a> is larger than the <a>snap viewport</a> in a particular axis,
	and there are no other <a>snap areas</a> within the <a>snap viewport</a>,
	then any scroll position in which the <a>snap area</a> covers the <a>snap viewport</a>
	is a valid <a>snap position</a> in that axis.
	The UA may use the specified alignment as a more precise target
	for certain scroll operations (e.g. inertial scrolling or explicit paging).

	<div class="example">
		For example, take the third code fragment in the previous example,
		which had a photo as the area.
		The author wants mandatory snapping from item to item,
		but if the item happens to be larger than your viewport,
		you want to be able to scroll around the whole thing once you're over it.

		Since the <a>snap area</a> is larger than the <a>snap viewport</a>,
		while the area fully fills the viewport,
		the container can be scrolled arbitrarily and will not try to snap back to its aligned position.
		However, if the container is scrolled such that the area
		no longer fully fills the viewport in an axis,
		the area resists outward scrolling
		until you fling out or pull it sufficiently to trigger snapping to a different <a>snap position</a>.
	</div>

<!--
 ██████  ████████  ███████  ████████
██    ██    ██    ██     ██ ██     ██
██          ██    ██     ██ ██     ██
 ██████     ██    ██     ██ ████████
      ██    ██    ██     ██ ██
██    ██    ██    ██     ██ ██
 ██████     ██     ███████  ██
-->

Scroll Snap Limits: the 'scroll-snap-stop' property {#scroll-snap-stop}
--------------------------

	<pre class="propdef">
	Name: scroll-snap-stop
	Value: normal | always
	Initial: normal
	Applies to: all elements
	Inherited: no
	Percentages: n/a
	Computed value: as specified
	Animatable: no
	Media: interactive
	</pre>

	This property specifies whether the <a>snap position</a>
	absorbs all remaining inertia during an <a>inertial scroll</a>,
	or allows the <a>inertial scroll</a> to pass multiple <a>snap positions</a> before coming to rest.
	Values are defined as follows:

	<dl dfn-type=value dfn-for=scroll-snap-stop>
		<dt><dfn>normal</dfn>
		<dd>
			A <a>snap position</a> defined by this element
			does not interfere with the inertia
			of an <a>inertial scroll</a> that is passing across it,
			unless it is the landing <a>snap position</a>.

		<dt><dfn>always</dfn>
		<dd>
			A <a>snap position</a> defined by this element,
			when encountered by an <a>inertial scroll</a>,
			absorbs all remaining inertia from an <a>inertial scroll</a>,
			forcing a stop at this <a>snap position</a>,
			exactly as if the scroll had enough inertia to reach the <a>snap position</a>,
			but not enough to escape it.

			Note: This means that if all snap positions in a scroller
			have ''scroll-snap-stop: always'',
			an inertial scroll can only move one <a>snap position</a>
			per inertial scroll action.
	</dl>

Snapping Mechanics {#snap}
==========================

	The precise model algorithm to select a <a>snap position</a> to snap to
	is intentionally left mostly undefined,
	so that user agents can take into account sophisticated models of user intention and interaction
	and adjust how they respond over time,
	to best serve the user.

	This section defines some useful concepts to aid in discussing scroll-snapping mechanics,
	and provides some guidelines for what an effective scroll-snapping strategy might look like.
	User agents are encouraged to adapt this guidance
	and apply their own best judgement
	when defining their own snapping behavior.
	It also provides a small number of behavior requirements,
	to ensure a minimum reasonable behavior that authors can depend on
	when designing their interfaces with scroll-snapping in mind.

<!--
████████ ██    ██ ████████  ████████  ██████
   ██     ██  ██  ██     ██ ██       ██    ██
   ██      ████   ██     ██ ██       ██
   ██       ██    ████████  ██████    ██████
   ██       ██    ██        ██             ██
   ██       ██    ██        ██       ██    ██
   ██       ██    ██        ████████  ██████
-->

Types of Scrolling Methods {#scroll-types}
------------------------------------------

	There are at least three distinct form of scroll methods that a user might perform on a page,
	which can reasonably trigger different snapping behaviors:

	: <dfn export local-lt="explicit" lt="explicit scroll">explicit scrolling</dfn>
	:: A scroll is <a>explicit</a> if the user is explicitly scrolling to a well-defined and obvious end-point.
		This includes methods such as:

		* a panning gesture,
			released without momentum
		* manipulating the scrollbar "thumb" explicitly
		* programmatically scrolling via APIs such as {{Window/scrollTo()}}.

	: <dfn export local-lt="inertial" lt="inertial scroll">inertial scrolling</dfn>
	:: A scroll is <a>inertial</a> if it is a method where the user "flings" the scroll position,
		indicating a direction and a momentum for the scroll,
		but no well-defined and intentional end-point.
		User agents tend to implement <a>inertial</a> scrolls
		by simulating a "friction" force that gradually reduces the scroll's momentum,
		or by otherwise gradually reducing the speed in a way feels "natural"
		and respects the user's intention.

		The scroll position that an <a>inertial</a> scroll would naturally land on
		without further intervention is the <dfn noexport>natural end-point</dfn>.

	: <dfn export local-lt="semantic" lt="semantic scroll">semantic scrolling</dfn>
	:: A scroll is <a>semantic</a> if it expresses a preferred direction to scroll in,
		but not a geometric amount of scrolling,
		or a specific "momentum" to a fling.
		This is most commonly from pressing an arrow key;
		for example, pressing the Down key indicates that you want to scroll down some amount.

	Additionally, because page layouts usually align things vertically and/or horizontally,
	UAs sometimes <dfn export>axis-lock</dfn> a scroll when its direction
	is sufficiently vertical or horizontal.
	An <a>axis-locked</a> scroll is bound to only scroll along that axis.
	This prevents,
	for example,
	a <em>nearly</em> horizontal fling gesture from gradually drifting up or down as well,
	because it is very difficult to fling in a precisely horizontal line.

	<div class="issue">
		Rewrite this section to be clearer,
		perhaps by classifying scroll methods into those that have
		<ul>
			<li>a preferred direction
			<li>a preferred position
			<li>both a preferred direction and a preferred position
		</ul>
		?
	</div>

<!--
   ██   ████████         ███████  ████████
 ████   ██     ██       ██     ██ ██     ██
   ██   ██     ██              ██ ██     ██
   ██   ██     ██        ███████  ██     ██
   ██   ██     ██       ██        ██     ██
   ██   ██     ██       ██        ██     ██
 ██████ ████████        █████████ ████████
-->

1D vs 2D Snap Position {#snap-dimensions}
-----------------------------------------

	There are two distinct forms of <a>snap positions</a> that a <a>scroll container</a> might contain:

	: <dfn export local-lt="1D" lt="1D snap position">1D snap position</dfn>
	:: A <a>1D snap position</a> indicates a desired scroll position
		in one axis of the <a>scroll container</a> only,
		with no preference for what the other axis's scroll position should be.

		Note:
		This is the “default” type of <a>snap position</a>
		that most elements will want to use,
		and so the ''scroll-snap-align'' property intentionally makes it the simplest to specify.

		Note: An element can declare two <a>1D snap positions</a>,
		one in each axis.
		These represent two independent <a>snap position</a> preferences,
		not a single <a>2D snap position</a>:
		if one of the element's snap positions is chosen in one axis,
		this has no bearing on the other dimension's <a>snap position</a>--
		it might be chosen,
		or another element's <a>snap position</a> might be chosen for that axis,
		or that axis might not snap at all.

	: <dfn export local-lt="2D" lt="2D snap position">2D snap position</dfn>
	:: A <a>2d snap position</a> indicates a desired <a>snap position</a>
		in both axises at once,
		aligning the <a>snap area</a> of an element
		to the specified 2D position in the <a>scroll container</a>’s <a>snap viewport</a>.

		This type of <a>snap position</a> is intended for "two-dimensional" panning-type layouts,
		such as cities on a map
		(using ''proximity'' 2D snap positions to snap a city to the center of the display when it gets close),
		or a tiled image gallery
		(using ''mandatory'' 2D snap positions to force each image to be centered on the screen).

<!--
 ██████  ██     ██  ███████   ███████   ██████  ████ ██    ██  ██████
██    ██ ██     ██ ██     ██ ██     ██ ██    ██  ██  ███   ██ ██    ██
██       ██     ██ ██     ██ ██     ██ ██        ██  ████  ██ ██
██       █████████ ██     ██ ██     ██  ██████   ██  ██ ██ ██ ██   ████
██       ██     ██ ██     ██ ██     ██       ██  ██  ██  ████ ██    ██
██    ██ ██     ██ ██     ██ ██     ██ ██    ██  ██  ██   ███ ██    ██
 ██████  ██     ██  ███████   ███████   ██████  ████ ██    ██  ██████
-->

Choosing Snap Positions {#choosing}
-----------------------------------

	A <a>scroll container</a> can have many <a>snap areas</a>
	scattered throughout its <a>scrollable area</a>.
	A naive algorithm for selecting a <a>snap position</a>
	can produce behavior that is unintuitive for users,
	so care is required when designing a selection algorithm.
	Here are a few pointers that can aid in the selection process:

	* <a>Snap positions</a> should be chosen to minimize the distance between the end-point
		(or the <a>natural end-point</a>)
		and the final snapped scroll position,
		subject to the additional constraints listed in this section.

	* <a>2D snap positions</a> are all-or-nothing;
		if a <a>2D snap position</a> is chosen to align to,
		the <a>scroll container</a> must set its scroll position
		according to the snap positions's preferred scroll position in <em>both</em> axises;
		the <a>scroll container</a> <em>must not</em> “partially align” to a <a>2D snap position</a>
		by taking its <a>snap position</a> in one axis
		and aligning the other axis according to something else.

	* If a scroll is <a>axis-locked</a>,
		any <a>1D</a> snap positions in the other axis should be ignored.
		<a>2D</a> snap positions should be penalized in the selection process
		according to the amount of other-axis scrolling they would cause.

	* <a>Snap positions</a> should be ignored if their elements are far outside of the “corridor”
		that the <a>snap viewport</a> defines as it moves through the <a>scrollable area</a>
		during an <a>inertial scroll</a>,
		or a hypothetical “corridor” in the direction of a <a>semantic scroll</a>,
		or the <a>snap viewport</a> after an <a>explicit scroll</a>.
		(This is to prevent a far-offscreen element
		from having difficult-to-understand effects
		on the scroll position.)

	* User agents <em>must</em> ensure that a user can “escape” a <a>snap position</a>,
		regardless of the scroll method.
		For example, if the snap type is ''mandatory''
		and the next <a>snap position</a> is more than two screen-widths away,
		a naïve “always snap to nearest” selection algorithm would “trap” the user
		if they were panning with a touch gesture;
		a sufficiently large distance would even trap fling scrolling!
		Instead, a smarter algorithm that only returned to the starting <a>snap position</a>
		if the end-point was a fairly small distance from it,
		and otherwise ignored the starting snap position,
		would give better behavior.

		(This implies that a <a>semantic scroll</a> must always ignore the starting <a>snap positions</a>.)

	* If the most appropriate <a>snap position</a> is unreachable,
		such that aligning to it would require scrolling the <a>scroll container</a>’s viewport
		past the edge of its <a>scrollable area</a>,
		the <a>scroll container</a> must be scrolled <em>as much as possible</em> in each relevant axis
		toward the desired <a>snap position</a>.
		This is the <em>used</em> <a>snap position</a> corresponding to that <a>snap position</a>;
		that is, the UA must “snap” to this position just as it would have if it were the actual specified alignment.

	* If a page is navigated to a fragment that defines a target element
		(one that would be matched by '':target''),
		and that element defines some <a>snap positions</a>,
		the user agent should snap to one of that element's <a>snap positions</a>.
		The user agent may do this even when the <a>scroll container</a> has ''scroll-snap-type: none''.

<!--
Group-based Snapping {#group}
========================

Issue: This section will likely be dropped.

Collects the <a>scroll snap areas</a> of all group-snapped boxes,
segments them into groups that will fit within the viewport,
then creates synthesized <a>scroll snap areas</a> to represent each group.
The <a>snap positions</a> introduced by these boxes
is then the 'scroll-group-align' alignment of each such group
within the viewport.
(Note that such areas may overlap,
if group-snapped boxes are arranged in an overlapping pattern.)

This is a simple form of “scrolling by pages”.

<div class="example">
	Use Case 1: Snapping to the top of each “page” of address book entries in a list of entries.

	<pre class="lang-css">
	:root {
		scroll-snap-type: proximity;
		scroll-group-align: start;
	}
	article {
		scroll-snap-align: group;
	}
	</pre>
</div>

<div class="example">
	Use Case 2: Scrolling an article to the first paragraph that hasn't been completely read.

	<pre class="lang-css">
	article {
		scroll-snap-type: proximity;
		scroll-group-align: start;
	}
	article > * {
		scroll-snap-align: group;
	}
	</pre>
</div>

<div class="example">
	Use Case 3: Scrolling image gallery, a la Pinterest, where images are packed tightly on the page.

	<pre class="lang-css">
	.gallery {
		scroll-snap-type: proximity;
		scroll-group-align: center;
	}
	.gallery > img {
		scroll-snap-align: group;
	}
	</pre>
</div>

Turning On Group Snapping: the ''group'' value of 'scroll-snap-align' {#scroll-snap-align-group}
-------------------------

	<pre class="propdef partial">
	Name: scroll-snap-align
	New values: group
	</pre>

	The <dfn value for=scroll-snap-align>group</dfn> value
	specifies that this element's scroll snap area should be group-aligned to the viewport.

Aligning the Group: the 'scroll-snap-group' property {#scroll-snap-group}
-----------------

	<pre class="propdef">
	Name: scroll-snap-group-align
	Value: <'scroll-snap-align'>
	Initial: start
	Applies to: all elements
	Inherited: no
	Computed value: as specified
	Animatable: no
	Media: interactive
	</pre>

	Specifies the alignment of a group-snapped group's area within the viewport.
-->

<!--
██        ███████  ██    ██  ██████   ██     ██    ███    ██    ██ ████████   ██████
██       ██     ██ ███   ██ ██    ██  ██     ██   ██ ██   ███   ██ ██     ██ ██    ██
██       ██     ██ ████  ██ ██        ██     ██  ██   ██  ████  ██ ██     ██ ██
██       ██     ██ ██ ██ ██ ██   ████ █████████ ██     ██ ██ ██ ██ ██     ██  ██████
██       ██     ██ ██  ████ ██    ██  ██     ██ █████████ ██  ████ ██     ██       ██
██       ██     ██ ██   ███ ██    ██  ██     ██ ██     ██ ██   ███ ██     ██ ██    ██
████████  ███████  ██    ██  ██████   ██     ██ ██     ██ ██    ██ ████████   ██████
-->

Appendix A: Longhands {#longhands}
=====================

Physical Longhands for 'scroll-snap-padding' {#padding-longhands-physical}
--------------------------------------------

	<pre class="propdef">
	Name: scroll-snap-padding-top, scroll-snap-padding-right, scroll-snap-padding-bottom, scroll-snap-padding-left
	Value: <<length>> | <<percentage>>
	Initial: 0
	Applies to: all elements
	Inherited: no
	Computed value: as specified, with lengths made absolute
	Animatable: as length, percentage, or calc
	Media: interactive
	</pre>

	These <a>longhands</a> of 'scroll-snap-padding' specify
	the top, right, bottom, and left
	edges of the <a>snap viewport</a>,
	respectively.

Flow-relative Longhands for 'scroll-snap-padding'  {#padding-longhands-logical}
-------------------------------------------------

	<pre class="propdef">
	Name: scroll-snap-padding-inline-start, scroll-snap-padding-block-start, scroll-snap-padding-inline-end, scroll-padding-block-end
	Value: <<length>> | <<percentage>>
	Initial: 0
	Applies to: all elements
	Inherited: no
	Computed value: as specified, with lengths made absolute
	Animatable: as length, percentage, or calc
	Media: interactive
	</pre>

	These <a>longhands</a> of 'scroll-snap-padding' specify
	the block-start, inline-start, block-end, and inline-end
	edges of the <a>snap viewport</a>,
	respectively.

	<pre class="propdef">
	Name: scroll-snap-padding-block, scroll-snap-padding-inline
	Value: [ <<length>> | <<percentage>> ]{1,2}
	Initial: 0
	Applies to: all elements
	Inherited: no
	Computed value: as specified, with lengths made absolute
	Animatable: as length, percentage, or calc
	Media: interactive
	</pre>

	These <a>shorthands</a> of 'scroll-snap-area-block-start' + 'scroll-snap-area-block-end'
	and 'scroll-snap-area-inline-start' + 'scroll-snap-area-inline-end'
	are <a>longhands</a> of 'scroll-snap-padding', and
	specify the block-axis and inline-axis
	edges of the <a>snap viewport</a>,
	respectively.
	If two values are specified, the first gives the start value
	and the second gives the end value.

Physical Longhands for 'scroll-snap-area'  {#area-longhands-physical}
-----------------------------------------

	<pre class="propdef">
	Name: scroll-snap-area-top, scroll-snap-area-right, scroll-snap-area-bottom, scroll-snap-area-left
	Value: <<length>>
	Initial: 0
	Applies to: all elements
	Inherited: no
	Computed value: as specified, with lengths made absolute
	Animatable: as length
	Media: interactive
	</pre>

	These <a>longhands</a> of 'scroll-snap-area' specify
	the top, right, bottom, and left
	edges of the <a>scroll snap area</a>,
	respectively.

Flow-relative Longhands for 'scroll-snap-area'  {#area-longhands-logical}
--------------------------------------------

	<pre class="propdef">
	Name: scroll-snap-area-block-start, scroll-snap-area-inline-start, scroll-snap-area-block-end, scroll-snap-area-inline-end
	Value: <<length>>
	Initial: 0
	Applies to: all elements
	Inherited: no
	Computed value: as specified, with lengths made absolute
	Animatable: as length
	Media: interactive
	</pre>

	These <a>longhands</a> of 'scroll-snap-area' specify
	the block-start, inline-start, block-end, and inline-end
	edges of the <a>scroll snap area</a>,
	respectively.

	<pre class="propdef">
	Name: scroll-snap-area-block, scroll-snap-area-inline
	Value: <<length>>{1,2}
	Initial: 0
	Applies to: all elements
	Inherited: no
	Computed value: as specified, with lengths made absolute
	Animatable: as length
	Media: interactive
	</pre>

	These <a>shorthands</a> of 'scroll-snap-area-block-start'/'scroll-snap-area-block-end'
	and 'scroll-snap-area-inline-start'/'scroll-snap-area-inline-end'
	are <a>longhands</a> of 'scroll-snap-area', and specify
	the block-axis and inline-axis
	edges of the <a>scroll snap area</a>,
	respectively.
	If two values are specified, the first gives the start value
	and the second gives the end value.
