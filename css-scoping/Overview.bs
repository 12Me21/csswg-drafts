<h1>CSS Scoping Module Level 1</h1>
<pre class='metadata'>
Level: 1
Shortname: css-scoping
Group: CSSWG
Status: ED
Work Status: Exploring
TR: https://www.w3.org/TR/css-scoping-1/
ED: https://drafts.csswg.org/css-scoping/
Previous Version: https://www.w3.org/TR/2014/WD-css-scoping-1-20140403/
Editor: Tab Atkins Jr., Google, http://xanthir.com/contact/
Editor: Elika J Etemad / fantasai, Invited Expert, http://fantasai.inkedblade.net/contact
Abstract: This specification defines various scoping/encapsulation mechanisms for CSS, including scoped styles and the ''@scope'' rule, Shadow DOM selectors, and page/region-based styling.
Ignored Vars: root elements
Ignored Terms: tree-of-trees order, slot
Issue Tracking: Bugzilla https://www.w3.org/Bugs/Public/buglist.cgi?component=Scoping&list_id=47685&product=CSS&resolution=---
</pre>

<pre class="link-defaults">
spec:dom; type:dfn;
	text:host
	text:shadow root; for:/
spec:html; type:element; text:style
</pre>

<h2 id="intro">
Introduction</h2>

	...


<!--
 ██████   ██████   ███████  ████████  ████ ██    ██  ██████
██    ██ ██    ██ ██     ██ ██     ██  ██  ███   ██ ██    ██
██       ██       ██     ██ ██     ██  ██  ████  ██ ██
 ██████  ██       ██     ██ ████████   ██  ██ ██ ██ ██   ████
      ██ ██       ██     ██ ██         ██  ██  ████ ██    ██
██    ██ ██    ██ ██     ██ ██         ██  ██   ███ ██    ██
 ██████   ██████   ███████  ██        ████ ██    ██  ██████
-->

<h2 id='scope'>
Scoped Styles</h2>

	<a>Scoped</a> style rules apply only within a subtree of a document,
	rather than matching against the entire document.
	Scoping has two primary effects:

	* The selector of the <a>scoped</a> style rule is restricted to match only elements within scope.
		See <a href="https://www.w3.org/TR/selectors4/#scoping">Scoped Selectors</a> in [[SELECTORS4]].
	* The cascade prioritizes scoped rules over unscoped ones, regardless of specificity.
		See <a href="https://www.w3.org/TR/css-cascade/#cascade-scope">Cascading by Scope</a> in [[CSS3CASCADE]].

<h3 id='scoping-mechanisms'>
Scoping Mechanisms</h3>

	Style rules can be scoped using constructs defined in the document language
	or using the ''@scope'' rule in CSS.

	“Scoping” consists of three somewhat independent concepts,
	which are in practice generally used together:

	* A declaration can be scoped to a <a>scoping root</a>,
		which <a href="https://drafts.csswg.org/css-cascade/#cascade-scope">affects its cascading behavior</a>. [[!CSS3CASCADE]]
		(Alternately, a style rule can be scoped to a <a>scoping root</a>,
		which scopes all of the declarations it contains to that <a>scoping root</a>.)

	* A selector can be either <a>scope-contained</a> or <a>scope-filtered</a> to a <a>scoping root</a>,
		which <a href="https://drafts.csswg.org/selectors/#evaluating-selectors">limits what elements it is allowed to match</a>. [[!SELECTORS4]]

	* The '':scope'' pseudo-class matches whatever the context sets as the <a>:scope elements</a>,
		and is used by several features, such as relative selectors.
		In the absence of any anything explicitly setting the <a>:scope elements</a> to something,
		the '':scope'' pseudo-class matches the selector's <a>scoping root</a>.

<h4 id='scoping-markup'>
Document Markup for Scoping</h4>

	Document languages may define a mechanism for a stylesheet to be scoped to some element in the document.
	For example, in HTML,
	a <a element>style</a> element with a <a element-attr for="style">scoped</a> attribute
	defines a stylesheet that is scoped to the <a element>style</a> element’s parent element.
	[[HTML]]

	The element that the stylesheet is scoped to
	is the <a>scoping root</a> for all the style rules in the stylesheet,
	and selectors of style rules in the stylesheet
	are <a>scope-contained</a> to the <a>scoping root</a>.

<!--
 ███████   ██████   ██████   ███████  ████████  ████████
██     ██ ██    ██ ██    ██ ██     ██ ██     ██ ██
██ ███ ██ ██       ██       ██     ██ ██     ██ ██
██ ███ ██  ██████  ██       ██     ██ ████████  ██████
██ █████        ██ ██       ██     ██ ██        ██
██        ██    ██ ██    ██ ██     ██ ██        ██
 ███████   ██████   ██████   ███████  ██        ████████
-->

<h4 id='scope-atrule'>
CSS Syntax for Scoping: the ''@scope'' rule</h4>

	The <dfn>@scope</dfn> at-rule allows authors to create scoped style rules using CSS syntax.
	The syntax of the ''@scope'' rule is:

	<pre class='prod'>
	@scope <<selector-list>> {
		<<stylesheet>>
	}
	</pre>

	where the elements matched by the <<selector-list>>
	are <a>scoping roots</a> for the style rules in <<stylesheet>>,
	and selectors of style rules scoped by ''@scope'' are
	<a>scope-contained</a> to their <a>scoping root</a>.

	<p class="issue">
	This rule makes it very easy for authors to create scoped style sheets,
	which could affect the optimization strategies for implementing scoped styles.

	If multiple elements match the <<selector-list>>,
	the <<stylesheet>> is effectively duplicated
	and scoped independently to each one.
	Authors should avoid using overly-generic selectors
	as it can have confusing interactions with the cascade.

	<div class="example">
		A scoped stylesheet is attached not only to the outermost scoping element,
		but to all matching elements.
		For example, given the style sheet below

		<pre>
		@scope div {
			span {
				color: blue;
			}
		}
		@scope section {
			span {
				color: orange;
			}
		}
		</pre>

		and the following document fragment

		<pre>
		&lt;div>
			&lt;section>
				&lt;div>
					&lt;span>text&lt;/span>
				&lt;/div>
			&lt;/section>
		&lt;/div>
		</pre>

		the text will be blue.
	</div>

	''@scope'' rules can be nested.
	In this case, just as with the nested style rules,
	the selector of an outer ''@scope'' scope-contains
	the selector of the inner one.

	The specificity of selectors inside the ''@scope'' rule is calculated locally:
	the selector specifying the scoping element is ignored.
	However, because scoped styles override non-scoped styles,
	style rules inside the ''@scope'' will override rules outside of it.

	<div class="example">
		In the following example, the text would be green:

		<pre>
			@scope aside {
				p { color: green; }
			}
			aside#sidebar p { color: red; }
		</pre>
	</div>

	Issue: If multiple ''@scope'' rules apply to an element,
	should they be cascaded by specificity?

<!--
 ██   ██████   ██████   ███████  ████████  ████████
████ ██    ██ ██    ██ ██     ██ ██     ██ ██
 ██  ██       ██       ██     ██ ██     ██ ██
      ██████  ██       ██     ██ ████████  ██████
 ██        ██ ██       ██     ██ ██        ██
████ ██    ██ ██    ██ ██     ██ ██        ██
 ██   ██████   ██████   ███████  ██        ████████
-->

<h3 id='scoping-context'>
Querying the Scoping Context</h3>

<h4 id='scope-pseudo'>
Selecting the Scoping Root: '':scope'' pseudo-class</h4>

	In a scoped stylesheet,
	the '':scope'' pseudo-class,
	defined in [[SELECTORS4]],
	matches the <a>scoping root</a>.

<h4 id='scope-content-pseudo'>
Selecting Outside the Scope: '':scope-context()'' pseudo-class</h4>

	<div class='issue'>
		This would be defined similarly to '':host-context()'',
		but matching the ancestors of the <a>scoping root</a> instead.

		However, since for scoped stylesheets you may want the ability to match complex selectors against the outside tree,
		rather than a single compound selector,
		we may want to instead use a more general mechanism that doesn't syntactically invert the order of tree elements.

		Possible ideas:

		<pre>
		:scope-context(<<selector-list>>) div {...}
		scope(<<selector-list>>) div {...}
		\scope <<selector-list>>\ div {...}
		<<selector-list>> \scope\ div {...}
		</pre>

		This functionality would replace ''@global'', which is a poor excuse for a selector.
	</div>

<!--
 ██████  ██     ██    ███    ████████   ███████  ██      ██
██    ██ ██     ██   ██ ██   ██     ██ ██     ██ ██  ██  ██
██       ██     ██  ██   ██  ██     ██ ██     ██ ██  ██  ██
 ██████  █████████ ██     ██ ██     ██ ██     ██ ██  ██  ██
      ██ ██     ██ █████████ ██     ██ ██     ██ ██  ██  ██
██    ██ ██     ██ ██     ██ ██     ██ ██     ██ ██  ██  ██
 ██████  ██     ██ ██     ██ ████████   ███████   ███  ███
-->

<h2 id='shadow-dom'>
Shadow Encapsulation</h2>

	The Shadow DOM spec augments the DOM with several new concepts,
	several of which are relevant to CSS.

	A <a>shadow tree</a> is a document fragment
	that can be attached to any element in the DOM.
	The root of the <a>shadow tree</a> is a <a>shadow root</a>,
	a non-element node which is associated with a <a>shadow host</a>.
	An element can have any number of <a>shadow trees</a>,
	which are ordered by creation time.

	An element with a <a>shadow tree</a> is a <dfn export>shadow host</dfn>.
	It is the <a>host</a> for its <a>shadow trees</a>.

	The descendants of a <a>shadow host</a>
	(its <a>light tree</a>)
	must not generate boxes in the formatting tree.
	Instead, the contents of the <a>shadow tree</a> generate boxes
	as if they were the contents of the <a>shadow host</a> instead.

	In several instances in shadow DOM,
	elements don't have element parents
	(instead, they may have a <a>shadow root</a> as parent,
		or something else).
	An element without a parent,
	or whose parent is not an element,
	is called a <dfn export>top-level element</dfn>.

	While a <a>shadow host's</a> <a>light tree</a> does not generate boxes normally,
	its <a>light tree</a> direct <a>children</a> can be explicitly pulled into a <a>shadow tree</a>
	and forced to render normally.
	This is done by marking the child as <a>slotable</a>
	and then,
	in the <a>shadow tree</a>,
	creating a <a>slot</a> set to receive the <a>slotable</a>,
	making the element <dfn export lt="slot-assign|assigned to a slot|assigned to the slot" local-lt="assign">assigned to the slot</dfn>.
	(Anonymous text nodes that are direct children are always <a>slotable</a>.)

	Note: The DOM specification [[!DOM]] defines how to make elements <a>slotable</a>,
	what elements are <a>slots</a>,
	and how the two are matched together.


<h3 id='selectors-data-model'>
Shadow DOM Selection Model</h3>

	Elements in the DOM
	have zero or more <a>shadow trees</a>.

	Note: The "descendants" of an element
	are based on the <a>light tree</a> children of the element,
	which does not include the <a>shadow trees</a> of the element.

	When a selector is matched against a <a>shadow tree</a>,
	the <a>selector match list</a>
	is initially the <a>shadow host</a>,
	followed by all the <a>top-level elements</a> of the <a>shadow tree</a>
	and their descendants,
	ordered by a pre-order traversal.

	A selector is <dfn>in the context of a shadow tree</dfn> if,
	when <a>match a selector against a tree</a> is called for it,
	one of its <var>root elements</var> are in a <a>shadow tree</a>.

	<div class="example">
		For example,
		any selector in a stylesheet embedded in or linked from an an element in a <a>shadow tree</a>
		is <a>in the context of a shadow tree</a>.
		So is the argument to {{querySelector()}} when called from a <a>shadow root</a>.
	</div>

<h4 id='host-element-in-tree'>
Shadow Hosts in a Shadow Tree</h4>

	A <a>shadow host</a> is outside of the <a>shadow trees</a> it hosts,
	but it is sometimes useful to be able to style it from inside the <a>shadow tree</a> context.

	For the purpose of Selectors,
	a <a>shadow host</a> also appears in each of its <a>shadow trees</a>,
	with the contents of the <a>shadow tree</a> treated as its children.
	If an element has multiple <a>shadow trees</a>,
	it appears in each <a>shadow tree's</a> context independently;
	each <a>shadow tree</a> sees <em>itself</em> as the contents of the <a>shadow host</a>,
	not the other <a>shadow trees</a>.

	When considered within its own <a>shadow trees</a>,
	the <a>shadow host</a> is <a>featureless</a>.
	Only the '':host'', '':host()'', and '':host-context()'' pseudo-classes are allowed to match it.

	<details class='why'>
		<summary>Why is the shadow host so weird?</summary>

		The <a>shadow host</a> lives outside the <a>shadow tree</a>,
		and its markup is in control of the page author,
		not the component author.

		It would not be very good if a component used a particular class name
		internally in a <a>shadow tree</a>,
		and the page author using the component accidentally <em>also</em>
		used the the same class name and put it on the <a>shadow host</a>.
		Such a situation would result in accidental styling
		that is impossible for the component author to predict,
		and confusing for the page author to debug.

		However, there are still some reasonable use-cases for letting a stylesheet in a <a>shadow tree</a>
		style its <a>shadow host</a>.
		So, to allow this situation but prevent accidental styling,
		the <a>shadow host</a> appears but is completely featureless
		and unselectable except through '':host''.
	</details>

<h4 id='slots-in-shadow-tree'>
Slots and Slotted Elements in a Shadow Tree</h4>

	<a>Slots</a> must act as if they were assigned ''display: contents'' in the <a>UA origin</a>.
	This must be possible to override via 'display',
	so they <em>do</em> generate boxes if desired.

	If a <a>slot</a> is not <a>assigned</a> any of its <a>shadow host's</a> children,
	that <a>slot's</a> own <a>children</a>
	are <a>assigned</a> to it.
	Otherwise, a <a>slot's</a> DOM <a>children</a>
	must not generate any boxes,
	as if they were ''display:none''.

	<a>Slots</a> can, themselves, be <a>assigned</a> to a <a>slot</a> in a deeper shadow tree.
	If this occurs,
	the elements <a>assigned</a> to the first slot
	are also treated as being <a>assigned</a> to the deeper <a>slot</a>.
	The deepest <a>slot</a> that an element is <a>assigned</a> to is its <dfn export>final assigned slot</dfn>.

	Elements <a>assigned</a> to a <a>slot</a>
	must generate boxes as if they were children of their <a>final assigned slot</a>
	(rather than children of their actual parent in a <a>shadow host's</a> <a>light tree</a>).


<h3 id='selectors'>
Shadow DOM Selectors</h3>

	Shadow DOM defines a few new selectors
	to help select elements in useful way related to Shadow DOM.

	Issue: This section is still under discussion.
	Feedback and advice on intuitive syntax for the following functionality
	would be appreciated.

<!--
 ██  ██     ██  ███████   ██████  ████████
████ ██     ██ ██     ██ ██    ██    ██
 ██  ██     ██ ██     ██ ██          ██
     █████████ ██     ██  ██████     ██
 ██  ██     ██ ██     ██       ██    ██
████ ██     ██ ██     ██ ██    ██    ██
 ██  ██     ██  ███████   ██████     ██
-->

<h4 id='host-selector'>
Selecting Into the Light: the '':host'', '':host()'', and '':host-context()'' pseudo-classes</h4>

	The <dfn selector>:host</dfn> pseudo-class,
	when evaluated <a>in the context of a shadow tree</a>,
	matches the <a>shadow tree's</a> <a>shadow host</a>.
	In any other context,
	it matches nothing.

	The <dfn selector id="selectordef-host-function" lt=':host()'>:host()</dfn> function pseudo-class
	has the syntax:

	<pre>:host( <<compound-selector>> )</pre>

	When evaluated <a>in the context of a shadow tree</a>,
	it matches the <a>shadow tree's</a> <a>shadow host</a>
	if the <a>shadow host</a>,
	in its normal context,
	matches the selector argument.
	In any other context,
	it matches nothing.

	<div class='example'>
		For example, say you had a component with a <a>shadow tree</a> like the following:

		<pre>
			&lt;x-foo class="foo">
				&lt;"shadow tree">
					&lt;div class="foo">...&lt;/div>
				&lt;/>
			&lt;/x-foo>
		</pre>

		For a stylesheet within the <a>shadow tree</a>:

		* '':host'' matches the <code>&lt;x-foo></code> element.
		* ''x-foo'' matches nothing.
		* ''.foo'' matches only the <code>&lt;div></code> element.
		* ''.foo:host'' matches nothing
		* '':host(.foo)'' matches the <code>&lt;x-foo></code> element.
	</div>

	Ordinary, selectors within a <a>shadow tree</a>
	can't see elements outside the <a>shadow tree</a> at all.
	Sometimes, however, it's useful to select an ancestor that lies somewhere outside the shadow tree,
	above it in the document.

	<div class='example'>
		For example, a group of components can define a handful of color themes
		they they know how to respond to.
		Page authors could opt into a particular theme
		by adding a specific class to the components,
		or higher up in the document.
	</div>

	The <dfn selector>:host-context()</dfn> functional pseudo-class tests whether there is an ancestor,
	outside the <a>shadow tree</a>,
	which matches a particular selector.
	Its syntax is:

	<pre>:host-context( <<compound-selector>> )</pre>

	When evaluated <a>in the context of a shadow tree</a>,
	the '':host-context()'' pseudo-class matches the <a>shadow host</a>,
	if the <a>shadow host</a> or one of its ancestors matches the provided <<compound-selector>>.
	For the purpose of this pseudo-class,
	the "ancestor" of an element is:

	: if the element is <a>assigned to a slot</a>
	:: the <a element>slot</a> element it is ultimately distributed to.
	: if the element is a top-most element in a shadow tree
	:: the <a>shadow host</a>
	: otherwise
	:: the element's parent,
		if it has one.

	Note: This means that the selector pierces through shadow boundaries on the way up,
	looking for elements that match its argument,
	until it reaches the document root.


<!--
 ██   ██   ██████  ██        ███████  ████████ ████████ ████████ ████████
████ ████ ██    ██ ██       ██     ██    ██       ██    ██       ██     ██
 ██   ██  ██       ██       ██     ██    ██       ██    ██       ██     ██
           ██████  ██       ██     ██    ██       ██    ██████   ██     ██
 ██   ██        ██ ██       ██     ██    ██       ██    ██       ██     ██
████ ████ ██    ██ ██       ██     ██    ██       ██    ██       ██     ██
 ██   ██   ██████  ████████  ███████     ██       ██    ████████ ████████
-->

<h4 id='slotted-pseudo'>
Selecting Slot-Assigned Content: the ''::slotted()'' pseudo-element</h4>

	The <dfn selector>::slotted()</dfn> pseudo-element
	represents the elements <a>assigned</a> to a <a>slot</a>.
	This pseudo-element only exists on <a>slots</a>.

	The ''::slotted()'' pseudo-element is an <em>alias</em> for other elements in the tree,
	and does not generate any boxes itself.

	The grammar of the ''::slotted()'' pseudo-element is:

	<pre class=prod>::slotted( <<compound-selector>>? )</pre>

	If the <<compound-selector>> is omitted,
	it defaults to the <a>universal selector</a>.

	The ''::slotted()'' pseudo-element represents the elements that are:

	* <a>assigned</a> to its <a>originating element</a>
	* <a lt="match a selector against an element">matched</a> by its <<compound-selector>> argument

	<div class="example">
		For example, say you had a component with both children and a shadow tree,
		like the following:

		<pre>
			&lt;x-foo>
				&lt;div id="one" slot="foo" class="foo">...&lt;/div>
				&lt;div id="two" slot="foo">...&lt;/div>
				&lt;div id="three" class="foo">
					&lt;div id="four" slot="foo">...&lt;/div>
				&lt;/div>
				&lt;"shadow tree">
					&lt;div id="five">...&lt;/div>
					&lt;div id="six">...&lt;/div>
					&lt;slot name="foo">&lt;/content>
				&lt;/"shadow tree">
			&lt;/x-foo>
		</pre>

		For a stylesheet within the <a>shadow tree</a>,
		a selector like ''::slotted()''
		selects ''#one'' and ''#two'' only,
		as they're the elements <a>assigned</a> to the sole <{slot}> element.
		It will <em>not</em> select ''#three''
		(no <code>slot</code> attribute)
		nor ''#four''
		(only direct <a>children</a> of a <a>shadow host</a> can be <a>assigned</a> to a <a>slot</a>).

		A selector like ''::slotted(.foo)'',
		on the other hand,
		will only select ''#one'',
		as it matches ''.foo'',
		but ''#two'' doesn't.

		Note: Note that a selector like ''::slotted()''
		is equivalent to ''*::slotted'',
		where the ''*'' selects many more elements that just the <{slot}> element.
		However, since only the <{slot}> elements are <a>slots</a>,
		they're the only elements with a ''::slotted()'' pseudo-element as well.
	</div>

<!--
██    ██    ██
 ██    ██    ██
  ██    ██    ██
   ██    ██    ██
  ██    ██    ██
 ██    ██    ██
██    ██    ██
-->

<h4 id='deep-combinator'>
Selecting Through Shadows: the ''>>>'' combinator</h4>

	Issue: It's currently disputed whether this combinator should exist.

	When a <dfn selector id="selectordef-shadow-piercing-descendant-combinator">>>></dfn> combinator
	(or <dfn export>shadow-piercing descendant combinator</dfn>)
	is encountered in a selector,
	replace every element in the <a>selector match list</a>
	with every element reachable from the original element
	by traversing any number of child lists or shadow trees.

	<div class='example'>
		For example, say you had a component with a <a>shadow tree</a> like the following:

		<pre>
			&lt;x-foo>
				&lt;"shadow tree">
					&lt;div>
						&lt;span id="not-top">...&lt;/span>
					&lt;/div>
					&lt;span id="top">...&lt;/span>
					&lt;x-bar>
						&lt;"shadow tree">
							&lt;span id="nested">...&lt;/span>
						&lt;/>
					&lt;/x-bar>
				&lt;/>
			&lt;/x-foo>
		</pre>

		For a stylesheet in the outer document,
		the selector ''x-foo >>> span''
		selects all three of <code>&lt;span></code> elements:
		''#top'', ''#not-top'', <em>and</em> ''#nested''.
	</div>

<!--
 ██████     ███     ██████   ██████     ███    ████████  ████████
██    ██   ██ ██   ██    ██ ██    ██   ██ ██   ██     ██ ██
██        ██   ██  ██       ██        ██   ██  ██     ██ ██
██       ██     ██  ██████  ██       ██     ██ ██     ██ ██████
██       █████████       ██ ██       █████████ ██     ██ ██
██    ██ ██     ██ ██    ██ ██    ██ ██     ██ ██     ██ ██
 ██████  ██     ██  ██████   ██████  ██     ██ ████████  ████████
-->

<h3 id='shadow-cascading'>
Shadow Cascading & Inheritance</h3>

<h4 id='cascading'>
Cascading</h4>

	To address the desired cascading behavior of rules targetting elements in shadow roots,
	this specification extends the <a href="https://drafts.csswg.org/css-cascade/#cascading">cascade order</a>
	defined in the Cascade specification. [[!CSS3CASCADE]]

	An additional cascade criteria must be added,
	between Origin and Scope,
	called Shadow Tree.

	* When comparing two declarations
		that are in different <a>shadow trees</a>,
		then for normal rules the declaration earlier in the <a>tree-of-trees order</a> wins,
		and for important rules the declaration coming later in the <a>tree-of-trees order</a> wins.

		Note: This is the <em>opposite</em> of how scoped styles work.

<h4 id='inheritance'>
Inheritance</h4>

	The <a>top-level elements</a> of a <a>shadow tree</a>
	inherit from their <a>shadow host</a>.

	Elements <a>assigned</a> to a slot inherit from their <a>final assigned slot</a>,
	rather than from their normal parent.

<!--
████████ ████████     ███     ██████   ██     ██ ████████ ██    ██ ████████  ██████
██       ██     ██   ██ ██   ██    ██  ███   ███ ██       ███   ██    ██    ██    ██
██       ██     ██  ██   ██  ██        ████ ████ ██       ████  ██    ██    ██
██████   ████████  ██     ██ ██   ████ ██ ███ ██ ██████   ██ ██ ██    ██     ██████
██       ██   ██   █████████ ██    ██  ██     ██ ██       ██  ████    ██          ██
██       ██    ██  ██     ██ ██    ██  ██     ██ ██       ██   ███    ██    ██    ██
██       ██     ██ ██     ██  ██████   ██     ██ ████████ ██    ██    ██     ██████
-->

<h2 id="fragment-scoping">
Fragmented Styling</h2>

	Fragmented content can be styled differently
	based on which line, column, page, region, etc.
	it appears in.
	This is done by using an appropriate <dfn export>fragment pseudo-element</dfn>,
	which allows targetting individual fragments of an element
	rather than the entire element.

	<div class="example">
		In our example,
		the designer wants to make
		text flowing into #region1
		dark blue and bold.
		This design can be expressed as shown below.

		<pre>
		#region1::region p {
			color: #0C3D5F;
			font-weight: bold;
		}
		</pre>

		The ''::region'' pseudo-element
		is followed by a ''p'' relative selector in this example.
		The color and font-weight declarations will apply
		to any fragments of paragraphs that are
		displayed in ''#region1''.
		The following figure shows how
		the rendering changes
		if we apply this styling specific to ''#region1''.
		Note how less text fits into this box
		now that the 'font-weight!!property' is
		bold instead of normal.

		<figure>
			<img src="images/region-styling.png" width="450" alt= "Illustrate how changing region styling affects the flow of content.">

			<figcaption>Different rendering with a different region styling</figcaption>
		</figure>
	</div>

	Note: This feature is an extension of ''::first-line'' styling.

<h3 id="the-region-pseudo-element">
Region-based Styling: the ''::region'' pseudo-element</h3>

	<div class="issue">
		Extend this to specify:

		* ''&lt;region-element-selector>::region''
		* ''&lt;paginated-element-selector>::page(&lt;page-selector>)''
		* ''&lt;multicol-element>::column(&lt;AnB>)''
		* ''&lt;fragmented-element-selector>::nth-fragment(&lt;AnB>)''
		* ''::first-line''
	</div>

	A ::region pseudo-element represents a relationship between
	a selector that matches a <span>CSS Region</span>,
	and a relative selector that matches some named flow content.
	This allows style declarations to be applied
	to fragments of named flow content flowing
	into particular regions.

	<pre>
	&lt;region selector&gt;::region &lt;content selector&gt;  {
		... CSS styling declarations ...
	}
	</pre>

	When the ::region pseudo-element is appended to a
	<a href="https://www.w3.org/TR/css3-selectors/#selector-syntax">selector</a>
	that matches one or more CSS Regions,
	this creates a 'flow fragment' selector.
	The flow fragment selector specifies
	which range of elements in the flow
	can be matched by the relative selector.
	The relative selector can match elements
	in the range(s) (see [[!DOM]]) of the named flow
	that are displayed fully or partially
	in the selected region(s).

	Elements that are fully or partially
	in the flow fragment range may match the relative selector.
	However, the style declarations only apply
	to the fragment of the element
	that is displayed in the corresponding region(s).

	Only a limited list of properties apply to a ::region pseudo-element:

	Issue: Either this list should be all functionally inheritable properties,
	or all properties.
	Why is it a seemingly-arbitrary subset of all properties, including box properties?

	1. <a href="https://www.w3.org/TR/CSS2/fonts.html">font properties</a></li>
	2. <a href="https://www.w3.org/TR/CSS2/colors.html">color property</a></li>
	3. <a href="https://www.w3.org/TR/css3-color/#transparency">opacity property</a></li>
	4. <a href="https://www.w3.org/TR/css3-background/#backgrounds">background property</a></li>
	5. 'word-spacing'</li>
	6. 'letter-spacing'</li>
	7. 'text-decoration'</li>
	8. 'text-transform'</li>
	9. 'line-height'</li>
	10. <a href="https://www.w3.org/TR/css3-text/#justification">alignment and justification properties</a></li>
	11. <a href="https://www.w3.org/TR/css3-background/#borders">border properties</a></li>
	12. <a href="https://www.w3.org/TR/css3-background/#corners">rounded corner properties</a></li>
	13. <a href="https://www.w3.org/TR/css3-background/#border-images">border images properties</a></li>
	14. <a href="https://www.w3.org/TR/CSS2/box.html#margin-properties">margin properties</a></li>
	15. <a href="https://www.w3.org/TR/CSS2/box.html#padding-properties">padding properties</a></li>
	16. 'text-shadow'</li>
	17. 'box-shadow'</li>
	18. 'box-decoration-break'</li>
	19. 'width'</li>

	<div class="example" id="region-style-example">
		In the following example, the <span>named flow</span> “article-flow” flows
		into “region-1” and “region-2”.
		<pre>
		&lt;style&gt;
		  #div-1 {
			<strong>flow-into: article-flow;</strong>
		  }

		  #region-1, #region-2 {
			<strong>flow-from: article-flow;</strong>
		  }

		  /* region styling */
		  <strong>#region-1::region p </strong> {
			margin-right: 5em;
		  }
		&lt;/style&gt;

		&lt;body&gt;
		  &lt;div id="div-1"&gt;
			  &lt;p id="p-1"&gt;...&lt;/p&gt;
			  &lt;p id="p-2"&gt;...&lt;/p&gt;
		  &lt;/div&gt;
		  &lt;div id="region-1"&gt;&lt;/div&gt;
		  &lt;div id="region-2"&gt;&lt;/div&gt;
		&lt;/body&gt;
		</pre>

		<div id="region_styling_illustration">
			<img id="region_styling_img_2" src="images/region-styling-2.png" alt= "Example showing how a named flow content fits into regions to illustrate region styling.">

			<ul class="swatch-list">
				<li><span class="swatch" style= "background:#1C75BC">&nbsp;</span>div div-1
				<li><span class="swatch" style= "background:crimson">&nbsp;</span>paragraph p-1
				<li><span class="swatch" style= "background:white">&nbsp;</span>paragraph p-2
				<li><span class="swatch" style= "background:#E6E7E8">&nbsp;</span>range of flow that fits into region-1
				<li><span class="swatch" style= "background:#BCBEC0">&nbsp;</span>range of flow that fits into region-2
			</ul>
		</div>

		The region styling applies
		to flow content that fits in ''region-1''.
		The relative selector matches ''p-1'' and ''p-2''
		because these paragraphs
		flow into ''region-1''.
		Only the fragment of ''p-2''
		that flows into ''region-1''
		is styled with the pseudo-element.
	</div>

	All of the selectors
	in a ::region pseudo-element
	contribute to its <a href="https://www.w3.org/TR/css3-selectors/#specificity">specificity</a>.
	So the specificity of the ::region pseudo-element
	in the example above would combine
	the id selector's specificity
	with the specificity of the type selector,
	resulting in a specificity of 101.

	Selectors that match a given element or element fragment (as described above),
	participate in the <a href="https://www.w3.org/TR/2011/REC-CSS2-20110607/cascade.html#cascading-order">CSS Cascading
	order</a> as defined in [[!CSS21]].

	Note: Region styling does not apply to nested regions. For example, if a region
	''A'' receives content from a flow that contains region ''B'', the content that
	flows into ''B'' does not receive the region styling specified for region ''A''.

	Issue: We'll need some way to query the styles of a fragment in a particular region.
	<code>getComputedStyle()</code> isn't enough,
	because an element can exist in multiple regions, for example,
	with each fragment receiving different styles.

<h2 id="changes">
Changes</h2>

	The following significant changes were made since the
	<a href="https://www.w3.org/TR/2014/WD-css-scoping-1-20140403/">3 April 2014 Working Draft</a>.

	* Renamed <css>::content</css> to ''::slotted''.

