
<html>
 <body>
  <h1>CSS Custom Properties for Cascading Variables Module Level 1</h1>

  <pre class=metadata>
Status: LCWD
Shortname: css-variables
Level: 1
TR: http://www.w3.org/TR/css-variables-1/
ED: http://dev.w3.org/csswg/css-variables/
Previous Version: http://www.w3.org/TR/2013/WD-css-variables-20130312/
Previous Version: http://www.w3.org/TR/2012/WD-css-variables-20120410/
Editor: Tab Atkins Jr., Google, http://xanthir.com/contact
Abstract: This module introduces cascading variables as a new primitive value type that is accepted by all CSS properties, and custom properties for defining them.
Ignored Properties: var-0, var-foo, var-main-color, color, var-Bar, var-two, margin-top, var-header-color, var-accent-background, var-foo-bar, var-bar, background-color, var-one, all
Ignored Terms: <color>, <bad-url>, <bad-string>, <semicolon>
Date: 2013-05-16
Deadline: 2013-06-13
</semicolon></bad-string></bad-url></color></pre>

  <h2 id=introduction><span class=secno>1. </span> Introduction</h2>

  <p><em>This section is not normative.</em> Large documents or applications
   (and even small ones) can contain quite a bit of CSS. Many of the values
   in the CSS file will be duplicate data; for example, a site may establish
   a color scheme and reuse three or four colors throughout the site.
   Altering this data can be difficult and error-prone, since it's scattered
   throughout the CSS file (and possibly across multiple files), and may not
   be amenable to Find-and-Replace. This module introduces a family of custom
   author-defined properties known collectively as <a>custom properties</a>,
   which allow an author to assign arbitrary values to a property with an
   author-chosen name, and <a>variables</a>, which allow an author to then
   use those values in other properties elsewhere in the document. This makes
   it easier to read large files, as seemingly-arbitrary values now have
   informative names, and makes editing such files much easier and less
   error-prone, as one only has to change the value once, in the <a>custom
   property</a>, and the change will propagate to all uses of that variable
   automatically.

  <h3 id=module-interactions><span class=secno>1.1. </span> Module
   Interactions</h3>

  <p> This module defines a new type of primitive value, the <a>variable</a>,
   which is accepted by all properties.

  <h3 id=values><span class=secno>1.2. </span> Values</h3>

  <p> This specification follows the <a
   href="http://www.w3.org/TR/CSS21/about.html#property-defs">CSS property
   definition conventions</a> from <a href="#CSS21"
   rel=biblioentry>[CSS21]<!--{{!CSS21}}--></a>. Value types not defined in
   this specification are defined in CSS Level 2 Revision 1 <a
   href="#CSS21" rel=biblioentry>[CSS21]<!--{{!CSS21}}--></a>. Other CSS
   modules may expand the definitions of these value types: for example if
   the <<color>> type was used in this specification, then <a
   href="#CSS3COLOR" rel=biblioentry>[CSS3COLOR]<!--{{CSS3COLOR}}--></a>
   would expand its definition.

  <h2 id=defining-variables><span class=secno>2. </span> Defining Custom
   Properties: the ‘<code class=css>var-*</code>’ family of properties</h2>

  <p> This specification defines an open-ended set of properties called
   <a>custom properties</a>, which are used to define <a>variables</a>.

  <pre class=propdef>
	Name: var-*
	Value: <<any-value>>
	Initial: (nothing, see prose)
	Applies to: all elements
	Inherited: yes
	Computed value: specified value with variables substituted (but see prose for "invalid variables")
	Media: all
	Animatable: no
	</pre>

  <p class=issue> Should variables have special animation behavior, such that
   they just never animate, not even with the "just flip at 50% progress"
   like everything else?

  <p class=issue> Should the global values initial/inherit/default be
   interpreted? I'm guessing no, because we're not meant to interpret
   *anything*. You can get switch it back to inheriting by setting it to a
   guaranteed-invalid value, like ‘<code class=css>var-foo:
   var(foo);</code>’, but you can't get ‘<code
   class=css>default</code>’ behavior.

  <p class=issue> What's the relationship of custom properties and the
   ‘<code class=property>all</code>’ property? Does it reset all the
   variables? If ‘<code class=css>var-foo: initial;</code>’ isn't
   interpreted by CSS, what effect does ‘<code class=css>all:
   initial;</code>’ have? A <dfn id=custom-property>custom property</dfn>
   is any property whose name starts with "var-", and contains at least one
   additional character. <a>Custom properties</a> are solely for use by
   authors and users; CSS will never give them a meaning beyond what is
   presented here. Note: Authors are recommended to choose custom property
   names so that the part after the "var-" is an identifier by itself, so
   that it can be referenced without <a
   href="http://www.w3.org/TR/CSS21/syndata.html#escaped-characters">character
   escaping</a>. For example, ‘<code class=css>var-0</code>’ needs to be
   referenced as ‘<code class=css>var(\30)</code>’, because ‘<code
   class=css>0</code>’ isn't a valid identifier. (U+0030 is the hexadecimal
   code for the ‘<code class=css>0</code>’ character.)

  <div class=example> Custom properties define variables, referenced with the
   ‘<a href="#variable-type"><code class=css>var()</code></a>’ notation,
   which can be used for many purposes. For example, a page that consistently
   uses a small set of colors in its design can store the colors in custom
   properties and use them with variables:
   <pre>
		:root {
			var-main-color: #06c;
			var-accent-color: #006;
		}
		/* The rest of the CSS file */
		#foo h1 {
			color: var(main-color);
		}
		</pre>
   The naming provides a mnemonic for the colors, prevents difficult-to-spot
   typos in the color codes, and if the theme colors are ever changed,
   focuses the change on one simple spot (the custom property value) rather
   than requiring many edits across all stylesheets in the webpage.</div>

  <p> Unlike other CSS properties, custom property names are
   <strong>case-sensitive</strong>. The "var-" prefix <strong>must</strong>
   be written in lower-case.

  <div class=example> For example, ‘<code class=css>VAR-FOO</code>’ is
   invalid, because the prefix isn't "var-". While both ‘<code
   class=css>var-foo</code>’ and ‘<code class=css>var-FOO</code>’ are
   valid, they are distinct properties - using ‘<code
   class=css>var(foo)</code>’ will refer to the first one, while using
   ‘<code class=css>var(FOO)</code>’ will refer to the second.</div>

  <p> The allowed syntax for <a>custom properties</a> is extremely
   permissive. The <dfn id=ltany-value>&lt;any-value></dfn> production
   matches <em>any</em> sequence of one or more tokens, so long as the
   sequence does not contain <<bad-string>>, <<bad-url>>, unmatched <<)>>,
   <<]>>, or <<}>>, or top-level <<semicolon>> tokens. Note: This definition,
   along with the general CSS syntax rules, imply that a custom property
   value never includes an unmatched quote or bracket, and so cannot have any
   effect on larger syntax constructs, like the enclosing style rule, when
   reserialized. Note: Custom properties can contain a trailing ‘<code
   class=css>!important</code>’, but this is automatically removed from the
   property's value by the CSS parser, and makes the custom property
   "important" in the CSS cascade. Note: While <<any-value>> must represent
   at least one token, that one token may be whitespace. This implies that
   ‘<code class=css>var-foo: ;</code>’ is valid, and the corresponding
   ‘<code class=css>var(foo)</code>’ call would have a single space as
   its substitution value, but ‘<code class=css>var-foo:;</code>’ is
   invalid.

  <div class=example> For example, the following is a valid custom property:
   <pre>
		var-foo: if(x > 5) this.width = 10;
		</pre>
   While this value is obviously useless as a <a
   href="#variable-type"><em>variable</em></a>, as it would be invalid in any
   normal property, it might be read and acted on by JavaScript.</div>

  <p> The values of custom properties, and the values of <a>variables</a>
   substituted into custom properties, are <em>case-sensitive</em>, and must
   be preserved in their original author-given casing. (Many CSS values are
   case-insensitive, which user agents can take advantage of by
   "canonicalizing" them into a single casing, but that isn't allowed for
   custom properties.) The initial value of a <a>custom property</a> is an
   empty value; that is, nothing at all. This initial value has a special
   interaction with the ‘<a href="#variable-type"><code
   class=css>var()</code></a>’ notation, which is explained in the section
   defining ‘<a href="#variable-type"><code class=css>var()</code></a>’.
   The primary purpose of <a>custom properties</a> is to define <a>cascading
   variables</a>. In CSS, a <dfn id=cascading-variable
   title="variable|cascading variable">cascading variable</dfn> is a value
   that can be substituted into other properties, allowing authors to
   "abstract" parts of their page's CSS out and reuse it in several places.
   Every <a>custom property</a> defines a corresponding <a>variable</a> with
   the same name, minus the "var-" prefix. For example, the custom property
   ‘<code class=property>var-foo</code>’ defines a variable named
   ‘<code class=css>foo</code>’. See the next chapter for details on how
   to use variables. Note: <a>Custom properties</a> can be put to several
   other uses, of course. For example, they can be used to conveniently
   attach values to elements so that JavaScript can later use those values.
   Another example is providing "custom CSS" by treating "var-" as a kind of
   "author prefix" (similar to a vendor prefix) that allows an author to
   write custom CSS properties without having them thrown away as invalid by
   the CSS parser, and then having JavaScript come along afterward to
   actually implement the functionality.

  <div class=example> This style rule:
   <pre>
		:root {
			var-header-color: #06c;
		}
		</pre>
   declares a <a>custom property</a> named "var-header-color" on the root
   element, and assigns to it the value "#06c". This property is then
   inherited to the elements in the rest of the document. Its value can be
   referenced via the "header-color" variable:
   <pre>
		h1 { background-color: var(header-color); }
		</pre>
   The preceding rule is equivalent to writing ‘<code
   class=css>background-color: #06c;</code>’, except that the variable name
   makes the origin of the color clearer, and if ‘<code
   class=css>var(header-color)</code>’ is used on other elements in the
   document, all of the uses can be updated at once by changing the ‘<code
   class=property>var-header-color</code>’ property on the root element.</div>

  <p> Custom properties are ordinary properties, so they can be declared on
   any element, are resolved with the normal inheritance and cascade rules,
   can be made conditional with ‘<code class=css>@media</code>’ and other
   conditional rules, can be used in HTML's <code>style</code> attribute, can
   be read or set using the CSSOM, etc..

  <div class=example> If a <a>custom property</a> is declared multiple times,
   the standard cascade rules help resolve it. Variables always draw from the
   computed value of the associated custom property on the same element:
   <pre>
		:root { var-color: blue; }
		div { var-color: green; }
		#alert { var-color: red; }
		* { color: var(color); }

		&lt;p>I inherited blue from the root element!&lt;/p>
		&lt;div>I got green set directly on me!&lt;/div>
		&lt;div id='alert'>
			While I got red set directly on me!
			&lt;p>I'm red too, because of inheritance!&lt;/p>
		&lt;/div>
		</pre>
  </div>

  <p><a>Custom properties</a> may use variables in their own values to build
   up composite variables. This can create cyclic dependencies where two or
   more <a>custom properties</a> each attempt to use the variable that the
   other defines; doing so makes all the <a>custom properties</a> involved in
   the cycle compute to their initial value (which is a guaranteed-invalid
   value).

  <div class=example> This example shows a custom property safely using a
   variable:
   <pre>
		:root {
			var-main-color: #c06;
			var-accent-background: linear-gradient(to top, var(main-color), white);
		}
		</pre>
   The ‘<code class=property>var-accent-background</code>’ property
   (along with any other properties that use ‘<code
   class=css>var(main-color)</code>’) will automatically update when the
   ‘<code class=property>var-main-color</code>’ property is changed.</div>

  <div class="example invalid-example"> On the other hand, this example shows
   an invalid instance of variables depending on each other:
   <pre>
		:root {
			var-one: calc(var(two) + 20px);
			var-two: calc(var(one) - 20px);
		}
		</pre>
   Both ‘<code class=property>var-one</code>’ and ‘<code
   class=property>var-two</code>’ now define <a>invalid variables</a>
   rather than lengths.</div>

  <p> It is important to note that <a>custom properties</a> resolve any
   <a>variables</a> in their values at computed-value time, which occurs <em
   title="">before</em> the value is inherited. In general, cyclic
   dependencies occur only when multiple custom properties on the same
   element refer to each other; custom properties defined on elements higher
   in the element tree can never cause a cyclic reference with properties
   defined on elements lower in the element tree.

  <div class=example> For example, given the following structure, these
   custom properties are <strong>not</strong> cyclic, and all define valid
   variables:
   <pre>
		&lt;one>&lt;two>&lt;three />&lt;/two>&lt;/one>
		one   { var-foo: 10px; }
		two   { var-bar: calc(var(foo) + 10px); }
		three { var-foo: calc(var(bar) + 10px); }
		</pre>
   The &lt;one> element defines a value for ‘<code
   class=property>var-foo</code>’. The &lt;two> element inherits this
   value, and additionally assigns a value to ‘<code
   class=property>var-bar</code>’ using the ‘<code
   class=css>foo</code>’ variable. Finally, the &lt;three> element inherits
   the ‘<code class=property>var-bar</code>’ value <em>after</em>
   variable substitution (in other words, it sees the value ‘<code
   class=css>calc(10px + 10px)</code>’), and then redefines ‘<code
   class=property>var-foo</code>’ in terms of that value. Since the value
   it inherited for ‘<code class=property>var-bar</code>’ no longer
   contains a reference to the ‘<code class=property>var-foo</code>’
   property defined on &lt;one>, defining ‘<code
   class=property>var-foo</code>’ using the ‘<code
   class=css>var(bar)</code>’ variable is not cyclic, and actually defines
   a value that will eventually (when referenced as a variable in a normal
   property) resolve to ‘<code class=css>30px</code>’.</div>
  <!--
UUUUUUUU     UUUUUUUU                  iiii
U::::::U     U::::::U                 i::::i
U::::::U     U::::::U                  iiii
UU:::::U     U:::::UU
 U:::::U     U:::::U    ssssssssss   iiiiiiinnnn  nnnnnnnn       ggggggggg   ggggg
 U:::::D     D:::::U  ss::::::::::s  i:::::in:::nn::::::::nn    g:::::::::ggg::::g
 U:::::D     D:::::Uss:::::::::::::s  i::::in::::::::::::::nn  g:::::::::::::::::g
 U:::::D     D:::::Us::::::ssss:::::s i::::inn:::::::::::::::ng::::::ggggg::::::gg
 U:::::D     D:::::U s:::::s  ssssss  i::::i  n:::::nnnn:::::ng:::::g     g:::::g
 U:::::D     D:::::U   s::::::s       i::::i  n::::n    n::::ng:::::g     g:::::g
 U:::::D     D:::::U      s::::::s    i::::i  n::::n    n::::ng:::::g     g:::::g
 U::::::U   U::::::Ussssss   s:::::s  i::::i  n::::n    n::::ng::::::g    g:::::g
 U:::::::UUU:::::::Us:::::ssss::::::si::::::i n::::n    n::::ng:::::::ggggg:::::g
  UU:::::::::::::UU s::::::::::::::s i::::::i n::::n    n::::n g::::::::::::::::g
    UU:::::::::UU    s:::::::::::ss  i::::::i n::::n    n::::n  gg::::::::::::::g
      UUUUUUUUU       sssssssssss    iiiiiiii nnnnnn    nnnnnn    gggggggg::::::g
                                                                          g:::::g
                                                              gggggg      g:::::g
                                                              g:::::gg   gg:::::g
                                                               g::::::ggg:::::::g
                                                                gg:::::::::::::g
                                                                  ggg::::::ggg
                                                                     gggggg
-->

  <h2 id=using-variables><span class=secno>3. </span> Using Cascading
   Variables: the ‘<a href="#variable-type"><code
   class=css>var()</code></a>’ notation</h2>

  <p> Every <a>custom property</a> automatically defines a corresponding
   <a>cascading variable</a>, which can then be substituted into another
   property with the ‘<a href="#variable-type"><code
   class=css>var()</code></a>’ function. The syntax of ‘<a
   href="#variable-type"><code class=css>var()</code></a>’ is:

  <pre class=prod>
	<dfn id=variable-type
   title="<variable>|var()">&lt;variable></dfn> = var( <var>variable-name</var> [, <<any-value>> ]? )
	</pre>

  <p> A variable can be used in place of any part of a value in any property
   on an element. Variables can not be used as property names, selectors, or
   anything else besides property values. (Doing so usually produces invalid
   syntax, or else a value whose meaning has no connection to the variable.)
   The second argument to the function, if provided, is a fallback value,
   which is used as the substitution value when the referenced variable is
   invalid. Note: The syntax of the fallback, like that of <a>custom
   properties</a>, allows commas. For example, ‘<code class=css>var(foo,
   red, blue)</code>’ defines a fallback of ‘<code class=css>red,
   blue</code>’; that is, anything between the first comma and the end of
   the function is considered a fallback value. A property value containing a
   variable must be assumed to be valid at parse time. It is only
   syntax-checked at computed-value time, after variable references have been
   <a title="resolve a variable">resolved</a>. To <dfn
   id=resolve-a-variable>resolve a variable</dfn> in a property's value:

  <ol>
   <li> If the variable named by the first argument to the ‘<a
    href="#variable-type"><code class=css>var()</code></a>’ function is a
    valid variable, replace the ‘<a href="#variable-type"><code
    class=css>var()</code></a>’ function by the value of the corresponding
    <a>custom property</a>.

   <li> Otherwise, if the ‘<a href="#variable-type"><code
    class=css>var()</code></a>’ function has a fallback value as its second
    argument, replace the ‘<a href="#variable-type"><code
    class=css>var()</code></a>’ function by the fallback value. If there
    are any ‘<a href="#variable-type"><code class=css>var()</code></a>’
    references in the fallback, <a title="resolve a variable">resolve</a>
    them as well.

   <li> Otherwise, the property containing the ‘<a
    href="#variable-type"><code class=css>var()</code></a>’ function is
    <a>invalid at computed-value time</a>. Note: Other things can also make a
    property <a>invalid at computed-value time</a>.
  </ol>

  <div class=example> The fallback value allows for some types of defensive
   coding. For example, an author may create a component intended to be
   included in a larger application, and use variables to style it so that
   it's easy for the author of the larger application to theme the component
   to match the rest of the app. Without fallback, the app author must supply
   a value for every variable that your component uses. With fallback, the
   component author can supply defaults, so the app author only needs to
   supply values for the variables they wish to override.
   <pre>
		/* In the component's style: */
		.component .header { 
			color: var(header-color, blue); 
		}
		.component .text { 
			color: var(text-color, black); 
		}

		/* In the larger application's style: */
		.component {
			var-text-color: #080;
			/* header-color isn't set, 
			   and so remains blue, 
			   the fallback value */
		}
		</pre>
  </div>

  <div class=example> For example, the following code incorrectly attempts to
   use a variable as a property name:
   <pre>
		.foo {
			var-side: margin-top;
			var(side): 20px;
		}
		</pre>
   This is <em>not</em> equivalent to setting ‘<code class=css>margin-top:
   20px;</code>’. Instead, the second declaration is simply thrown away as
   a syntax error for having an invalid property name. Similarly, you can't
   build up a single token where part of it is provided by a variable:
   <pre>
		.foo {
			var-gap: 20;
			margin-top: var(gap)px;
		}
		</pre>
   Again, this is <em>not</em> equivalent to setting ‘<code
   class=css>margin-top: 20px;</code>’ (a length). Instead, it's equivalent
   to ‘<code class=css>margin-top: 20 px;</code>’ (a number followed by
   an ident), which is simply an invalid value for the ‘<code
   class=property>margin-top</code>’ property. Note, though, that ‘<code
   class=css>calc()</code>’ can be used to validly achieve the same thing,
   like so:
   <pre>
		.foo {
		  var-gap: 20;
		  margin-top: calc(var(gap) * 1px);
		}
		</pre>
  </div>

  <p> A variable is substituted for its value in the property value at
   computed-value time. If a declaration, once all variables are substituted
   in, is invalid, the declaration is <a>invalid at computed-value time</a>.

  <div class=example> For example, the following usage is fine from a syntax
   standpoint, but results in nonsense when the variable is substituted in:
   <pre>
		:root { var-looks-valid: 20px; }
		p { background-color: var(looks-valid); }
		</pre>
   Since ‘<code class=css>20px</code>’ is an invalid value for ‘<code
   class=property>background-color</code>’, this instance of the property
   computes to ‘<code class=css>transparent</code>’ (the initial value
   for ‘<code class=property>background-color</code>’) instead. If the
   property was one that's inherited by default, such as ‘<code
   class=property>color</code>’, it would compute to the inherited value
   rather than the initial value.</div>

  <h3 id=invalid-variables><span class=secno>3.1. </span> Invalid Variables</h3>

  <p> When a <a>custom property</a> has its initial value, the
   <a>variable</a> it defines represents an <dfn id=invalid-variable>invalid
   variable</dfn>. Using an <a>invalid variable</a> in a property value
   (including other <a>custom properties</a>) makes the declaration
   <a>invalid at computed-value time</a>. A declaration can be <dfn
   id=invalid-at-computed-value-time>invalid at computed-value time</dfn> if
   it uses an invalid <a>variable</a>, as explained above, or if it uses a
   valid <a>variable</a>, but the property value, after substituting its
   <a>variables</a>, is invalid. When this happens, the computed value of the
   property is either the property's inherited value or its initial value
   depending on whether the property is inherited or not, respectively.

  <div class=example> For example, in the following code:
   <pre>
		:root { var-not-a-color: 20px; }
		p { background-color: red; }
		p { background-color: var(not-a-color); }
		</pre>
   the &lt;p> elements will have transparent backgrounds (the initial value
   for ‘<code class=property>background-color</code>’), rather than red
   backgrounds. The same would happen if the variable itself was invalid.
   Note the difference between this and what happens if the author had just
   written ‘<code class=css>background-color: 20px</code>’ directly in
   their stylesheet - that would be a normal syntax error, which would cause
   the rule to be discarded, so the ‘<code class=css>background-color:
   red</code>’ rule would be used instead.</div>

  <p> Note: The <a>invalid at computed-value time</a> concept exists because
   variables can't "fail early" like other syntax errors can, so by the time
   the user agent realizes a property value is invalid, it's already thrown
   away the other cascaded values. <!--
               AAA               PPPPPPPPPPPPPPPPP   IIIIIIIIII
              A:::A              P::::::::::::::::P  I::::::::I
             A:::::A             P::::::PPPPPP:::::P I::::::::I
            A:::::::A            PP:::::P     P:::::PII::::::II
           A:::::::::A             P::::P     P:::::P  I::::I
          A:::::A:::::A            P::::P     P:::::P  I::::I
         A:::::A A:::::A           P::::PPPPPP:::::P   I::::I
        A:::::A   A:::::A          P:::::::::::::PP    I::::I
       A:::::A     A:::::A         P::::PPPPPPPPP      I::::I
      A:::::AAAAAAAAA:::::A        P::::P              I::::I
     A:::::::::::::::::::::A       P::::P              I::::I
    A:::::AAAAAAAAAAAAA:::::A      P::::P              I::::I
   A:::::A             A:::::A   PP::::::PP          II::::::II
  A:::::A               A:::::A  P::::::::P          I::::::::I
 A:::::A                 A:::::A P::::::::P          I::::::::I
AAAAAAA                   AAAAAAAPPPPPPPPPP          IIIIIIIIII
-->

  <h2 id=cssom><span class=secno>4. </span> APIs</h2>

  <h3 id=the-cssstyledeclaration-interface><span class=secno>4.1. </span>
   Extensions to the <a
   href="#cssstyledeclaration"><code>CSSStyleDeclaration</code></a> Interface</h3>

  <p> The <dfn id=cssstyledeclaration><code>CSSStyleDeclaration</code></dfn>
   interface is amended as follows:

  <pre class=idl>
	partial interface CSSStyleDeclaration {
		readonly attribute CSSVariablesMap var;
	}
	</pre>

  <p> A <a href="#cssstyledeclaration"><code>CSSStyleDeclaration</code></a>
   is the <dfn id=associated-style-declaration>associated style
   declaration</dfn> for the <a
   href="#cssvariablesmap"><code>CSSVariablesMap</code></a> assigned to its
   <code>var</code> attribute. While the CSSStyleDeclaration interface
   normally contains attributes that are camel-cased name variants of all CSS
   properties (and sometimes also attributes for their canonical names), it
   must not contain any such attributes for custom properties. The camel-case
   trick does not work, as custom property names are case-sensitive, and
   there are potentially an infinity of custom properties, which is
   incompatible with the normal behavior of exposing every property whether
   it was set in the corresponding declaration block or not.

  <h4 id=serializing-custom-props><span class=secno>4.1.1. </span>
   Serializing Custom Properties</h4>

  <p> Custom property names must be serialized with the casing as provided by
   the author.

  <p class=note> Ordinarily, property names are restricted to the ASCII range
   and are case-insensitive, so implementations typically serialize the name
   lowercased.

  <h3 id=the-CSSVariablesMap-interface><span class=secno>4.2. </span> The <a
   href="#cssvariablesmap"><code>CSSVariablesMap</code></a> Interface</h3>

  <p> The <dfn id=cssvariablesmap><code>CSSVariablesMap</code></dfn>
   interface exposes the <a>custom properties</a> declared in the parent
   declaration block that have a non-initial value.

  <pre class=idl>
	[MapClass(DOMString, DOMString)]
	interface CSSVariablesMap {
		DOMString get(DOMString varName);
		boolean has(DOMString varName);
		void set(DOMString varName, DOMString varValue);
		boolean delete(DOMString varName);
	}
	</pre>

  <p> The <a href="http://dev.w3.org/2006/webapi/WebIDL/#REPLACE-ME">map
   tuples</a> on a CSSVariablesMap object are the property names of all the
   <a>custom properties</a> in the <a
   href="http://dev.w3.org/csswg/cssom/#css-declaration-block-declarations"><dfn
   id=css-declaration-block-declarations>CSS declaration block
   declarations</dfn></a> with a non-initial value, with the "var-" prefix
   removed, paired with their values.

  <h4 id=cssvariablesmap-methods><span class=secno>4.2.1. </span>
   <code>CSSVariablesMap Methods</code></h4>

  <dl>
   <dt>get(DOMString varName), returns DOMString

   <dd> Prepend "var-" to <var>varName</var>. Invoke
    <code>getPropertyValue()</code> on the <a>associated style
    declaration</a> by passing <var>varName</var> as its argument, and return
    its returned value.

   <dt>has(DOMString varName), returns boolean

   <dd> Invoke get() on the CSSVariablesMap object by passing
    <var>varName</var> as its argument. If the return value is the empty
    string, return <code>false</code>; otherwise, return <code>true</code>.

   <dt>set(DOMString varName, DOMString varValue), returns void

   <dd> Prepend "var-" to <var>varName</var>. Invoke
    <code>setProperty()</code> on the <a>associated style declaration</a> by
    passing <var>varName</var> and <var>varValue</var> as its two arguments,
    in that order.

   <dt>delete(DOMString varName), return DOMString

   <dd> Prepend "var-" to <var>varName</var>. Invoke
    <code>removeProperty()</code> on the <a>associated style declaration</a>
    by passing <var>varName</var> as its argument. If the returned value is
    the empty string, return <code>false</code>; otherwise, return
    <code>true</code>.
  </dl>

  <div class=example></div>

 <head profile="http://dublincore.org/documents/2008/08/04/dc-html/ ">
  <style scoped=scoped>
		#var-code-examples td { padding: 2px; }
		#var-code-examples code { background: rgba(0,0,0,.05); display: inline-block; padding: 1px 2px; white-space: pre; }
		</style>

<html>
 <body>
  <p> For example, given the following style sheet:

  <pre>
		div {
			var-foo: 16px;
			var-Bar: red;
			var-foo-bar: 50%;
		}
		</pre>

  <p> Here are the results of several JavaScript expressions, assuming that
   <code>el</code> is a JavaScript variable holding an element that the above
   style rule applies to:

  <table id=var-code-examples>
   <thead>
    <tr>
     <th>Code

     <th>Value

     <th>Notes

   <tbody>
    <tr>
     <td><code>el.style.var.get("foo")</code>

     <td><code>"16px"</code>

     <td>The value of ‘<code class=property>var-foo</code>’.

    <tr>
     <td><code>el.style.var.get("Bar")</code>

     <td><code>"red"</code>

     <td>The value of ‘<code class=property>var-Bar</code>’.

    <tr>
     <td><code>el.style.var.get("foo-bar")</code>

     <td><code>"50%"</code>

     <td>The value of ‘<code class=property>var-foo-bar</code>’.

    <tr>
     <td><code>el.style.varFoo</code>

     <td>n/a

     <td>Custom properties don't exist directly on "style"

    <tr>
     <td><code>el.style.varBar</code>

     <td>n/a

     <td>Not even if the casing matches.
  </table>

  <div class=example> Iterating over all of the custom properties (for
   example, for a JS library to find the ones it knows about and wants to
   respond to) is also simple with the <code>var</code> property:
   <pre>
		var customProps = el.style.var;
		for(customPropName in customProps) {
			if( knownCustomPropName(customPropName) ) {
				var customPropValue = customProps[customPropName];
				/* Processing code here. */
			}
		}
		</pre>
  </div>

  <h2 id=changes><span class=secno>5. </span> Changes from 10 April 2012
   Working Draft</h2>

  <ul>
   <li>The value syntax for custom properties has been nailed down more
    precisely.

   <li>Case-sensitivity of custom property names has been defined.

   <li>The fallback argument was added to the var() function.

   <li>A property that is invalid at computed-value time now either goes
    inherit or initial, rather than always initial.

   <li>CSSVariableComponentValue interface has been dropped, pending the
    *ComponentValue interfaces being created at all.

   <li>The CSSVariablesMap interface has been added, which stores all the
    variables defined by a style rule.
  </ul>

  <h2 id=acknowledgments><span class=secno>6. </span> Acknowledgments</h2>

  <p> Many thanks to several people in the CSS Working Group for keeping the
   dream of variables alive over the years, particularly Daniel Glazman and
   David Hyatt. Thanks to multiple people on the mailing list for helping
   contribute to the development of this incarnation of variables,
   particularly Brian Kardell, David Baron, François Remy, Roland Steiner,
   and Shane Stephens.
