<h1>Media Queries Level 4</h1>

<pre class='metadata'>
Group: csswg
Shortname: mediaqueries
Level: 4
Status: ED
ED: http://dev.w3.org/csswg/mediaqueries4/
Editor: Florian Rivoal, Invited Expert, florian@rivoal.net
Former Editor: Håkon Wium Lie, Opera, howcome@opera.com
Former Editor: Tantek Çelik, Mozilla, tantek@cs.standard.edu
Former Editor: Daniel Glazman, Samsung, daniel@glazman.org
Former Editor: Anne van Kesteren, Mozilla, annevk@annevk.nl
!Issue Tracking: Inline, and <a href="http://www.w3.org/Style/CSS/Tracker/products/7">http://www.w3.org/Style/CSS/Tracker/products/7</a>
Abstract: <a>Media Queries</a> allow authors to test and query values or features of the user agent or display device, independent of the document being rendered.  They are used in the CSS @media rule to conditionally apply styles to a document, and in various other contexts and languages, such as HTML and Javascript.
Abstract: Media Queries Level 4 describes the mechanism and syntax of media queries, media types, and media features. It extends and supersedes the features defined in Media Queries Level 3.
Ignored Terms: min-resolution, max-resolution, none
</pre>

<h2 id="intro">
Introduction</h2>

	<em>This section is not normative.</em>

	HTML4 [[HTML401]] defined a mechanism to support media-dependent style sheets,
	tailored for different <a>media types</a>.
	For example, a document may use different style sheets for screen and for print.
	In HTML, this can be written as:

	<div class="example">
		<pre>
			&lt;link rel="stylesheet" type="text/css" media="screen" href="style.css">
			&lt;link rel="stylesheet" type="text/css" media="print" href="print.css">
		</pre>
	</div>

	CSS adapted and extended this functionality with its ''@media'' and ''@import'' rules.

	<div class="example">
		Inside a CSS style sheet,
		one can declare that sections apply to certain <a>media types</a>:

		<pre>
			@media screen {
				* { font-family: sans-serif }
			}
		</pre>

		Similarly, stylesheets can be conditionally imported based on media queries:

		<pre>@import "print-styles.css" print;</pre>
	</div>

	<a>Media queries</a> can be used with HTML, XHTML, XML [[XMLSTYLE]] and the @import and @media rules of CSS.

	<div class="example">
		Here is the same example written in HTML, XHTML, XML, @import and @media:

		<pre>
			&lt;link media="screen and (color), projection and (color)"
			      rel="stylesheet" href="example.css">

			&lt;link media="screen and (color), projection and (color)"
			      rel="stylesheet" href="example.css" />

			&lt;?xml-stylesheet media="screen and (color), projection and (color)"
			                 rel="stylesheet" href="example.css" ?>

			@import url(example.css) screen and (color), projection and (color);

			@media screen and (color), projection and (color) { … }
		</pre>

		Note: The [[XMLSTYLE]] specification has not yet been updated to
		use media queries in the <code>media</code> pseudo-attribute.
	</div>

<h3 id="placement">
Module interactions</h3>

	This module replaces and extends the Media Queries, Media Type and Media Features
	defined in [[!CSS21]] sections 7 and in [[!MEDIAQ]].

<h3 id="values">
Values</h3>

	Value types not defined in this specification, such as <<integer>>,
	<<number>> or <<resolution>>, are defined in [[!CSS3VAL]].  Other CSS
	modules may expand the definitions of these value types.

	This specification also introduces some new value types.

	The <dfn type>&lt;ratio></dfn> value type is a positive (not zero or negative)
	<<integer>> followed by optional whitespace, followed by a solidus ('/'),
	followed by optional whitespace, followed by a positive <<integer>>.

	The <dfn type>&lt;mq-boolean></dfn> value type is an <<integer>>
	with the value ''0'' or ''1''.
	Any other integer value is invalid.
	<span class='note'>Note that ''-0'' is always equivalent to ''0'' in CSS,
	and so is also accepted as a valid <<mq-boolean>> value.</span>

<h3 id="units">
Units</h3>

	The units used in media queries are the same as in other parts of CSS, as
	defined in [[!CSS3VAL]]. For example, the pixel unit represents CSS pixels and
	not physical pixels.

	Relative units in media queries are based on the initial value, which means
	that units are never based on results of declarations. For example, in HTML,
	the ''em'' unit is relative to the initial value of 'font-size',
	defined by the user agent or the user's preferences,
	not any styling on the page.


<h2 id="media">
Media Queries</h2>

	A <dfn>media query</dfn> is a method of testing certain aspects of the user agent
	or device that the document is being displayed in.
	<a>Media queries</a> are always independent of the contents of the document,
	its styling,
	or any other internal aspect;
	they're only dependent on "external" information.

	The syntax of a <a>media query</a> consists of
	an optional <a>media query modifier</a>,
	an optional <a>media type</a>,
	and zero or more <a>media features</a>:

	<pre class='railroad'>
	Diagram(
		Or(1,
			Skip(),
			And(
				Opt("not", skip=True),
				Plus(NT("media feature"), "and")),
			And(
				Or(1,
					"only",
					Skip(),
					"not"),
				NT("media type"),
				Star(NT("media feature"), "and"))))
	</pre>

	A <a>media query</a> is a logical expression that is either true or false.
	A media query is true if:

	<ul>
		<li>
			the <a>media type</a>,
			if specified,
			matches the media type of the device where the user agent is running, and

		<li>
			all specified <a>media features</a> are true.
	</ul>

	Statements regarding media queries in this section assume the
	<a href="#syntax">syntax section</a> is followed. Media queries that do not
	conform to the syntax are discussed in the
	<a href="#error-handling">error handling section</a>. I.e. the syntax takes
	precedence over requirements in this section.

	<div class="example">
		Here is a simple example written in HTML:

		<pre>&lt;link rel="stylesheet" media="screen and (color)" href="example.css" /></pre>

		This example expresses that a certain style sheet
		(<code>example.css</code>) applies to devices of a certain media type
		(''screen'') with certain feature (it must be a color screen).

		Here is the same media query written in an @import-rule in CSS:

		<pre>@import url(example.css) screen and (color);</pre>
	</div>

	User agents should re-evaluate <a>media queries</a> in response to changes in the user environment,
	for example if the device is tiled from landscape to portrait orientation,
	and change the behavior of any constructs dependent on those <a>media queries</a> accordingly.

	Unless otherwise specified, it is never necessary to apply a style sheet in order to evaluate expressions.

	Note: CSS Device Adaptation [[CSS-DEVICE-ADAPT]]]
	defines how ''@viewport'' rules interact with Media Queries.

<h3 id='mq-list'>
Combining Media Queries</h3>

	Several <a>media queries</a> can be combined into a comma-separated <dfn export>media query list</dfn>.

	<pre class='railroad'>
	Diagram(
		Star("media query", ","))
	</pre>

	A <a>media query list</a> is true if <em>any</em> of its component <a>media queries</a> are true,
	and false only if <em>all</em> of its component <a>media queries</a> are false.

	<div class="example">
		For example, the following <a>media query list</a> is true if either
		the <a>media type</a> is ''screen'' and it's a color device,
		<strong>or</strong> the <a>media type</a> is ''projection'' and it's a color device:

		<pre>
		@media screen and (color), projection and (color) { … }
		</pre>
	</div>

	An empty <a>media query list</a> evaluates to true.

	<div class="example">
		For example, these are equivalent:

		<pre>
		@media all { … }
		@media { … }
		</pre>
	</div>

<h3 id='mq-prefix'>
Media Query Modifiers</h3>

	A <a>media query</a> may optionally be prefixed by a single <dfn export>media query modifier</dfn>,
	which is a single keyword which alters the meaning of the following <a>media query</a>.

<h4 id='mq-not'>
Negating a Media Query: the ''not'' keyword</h4>

	An individual <a>media query</a> can have its result negated
	by prefixing it with the keyword <dfn value for="@media">not</dfn>.
	If the <a>media query</a> would normally evaluate to true,
	prefixing it with ''not'' makes it evaluate to false,
	and vice versa.

	<div class="example">
		For example, the following will apply to everything except color-capable screens.
		Note that the entire media query is negated,
		not just the <a>media type</a>.

		<pre>&lt;link rel="stylesheet" media="not screen and (color)" href="example.css" /></pre>
	</div>

<h4 id='mq-only'>
Hiding a Media Query From Legacy User Agents: the ''only'' keyword</h4>

	The concept of <a>media queries</a> originates from HTML4 [[HTML401]].
	That specification only defined <a>media types</a>,
	but had a forward-compatible syntax that accommodated the addition of future concepts like <a>media features</a>:
	it would consume the characters of a <a>media query</a> up to the first non-alphanumeric character,
	and interpret that as a <a>media type</a>,
	ignoring the rest.
	For example, the <a>media query</a> ''screen and (color)''
	would be truncated to just ''screen''.

	Unfortunately, this means that legacy user agents using this error-handling behavior
	will ignore any <a>media features</a> in a <a>media query</a>,
	even if they're far more important than the <a>media type</a> in the query.
	This can result in styles accidentally being applied in inappropriate situations.

	To hide these <a>media queries</a> from legacy user agents,
	the <a>media query</a> can be prefixed with the keyword <dfn value for="@media">only</dfn>.
	The ''only'' keyword <strong>has no effect</strong> on the <a>media query</a>’s result,
	but will cause the <a>media query</a> to be parsed by legacy user agents
	as specifying the unknown <a>media type</a> “only”,
	and thus be ignored.

	<div class="example">
		In this example, the stylesheet specified by the <code>&lt;link></code> element
		will not be used by legacy user agents,
		even if they would normally match the ''screen'' <a>media type</a>.

		<pre>&lt;link rel="stylesheet" media="only screen and (color)" href="example.css" /></pre>
	</div>

	Note: Note that the ''only'' keyword is only necessary if the <a>media query</a> contains a <a>media type</a>
	and no other <a>media query modifier</a>.
	A <a>media query</a> consisting only of <a>media features</a>,
	or one with another <a>media query modifier</a> like ''not'',
	will be treated as false by legacy user agents automatically.

	Note: At the time of publishing this specification,
	such legacy user agents are extremely rare,
	and so using the ''only'' modifier is rarely, if ever, necessary.

<h3 id='media-types'>
Media Types</h3>

	A <dfn export>media type</dfn> is a broad category of user-agent devices
	on which a document may be displayed.
	The original set of <a>media types</a> were defined in HTML4,
	for the <code>media</code> attribute on <code>&lt;link></code> elements.

	Unfortunately, <a>media types</a> have proven insufficient as a way of discriminating between devices with different styling needs.
	Some categories which were originally quite distinct,
	such as ''screen'' and ''handheld'',
	have blended significantly in the years since their invention.
	Others, such as ''tty'' or ''tv'',
	expose useful differences from the norm of a full-featured computer monitor,
	and so are potentially useful to target with different styling,
	but the definition of <a>media types</a> as mutually exclusive
	makes it difficult to use them in a reasonable manner;
	instead, their exclusive aspects are better expressed as <a>media features</a>
	such as 'grid' or 'scan'.

	As such, the following <a>media types</a> are defined for use in <a>media queries</a>:

	<dl dfn-type=value dfn-for="@media">
		<dt><dfn>all</dfn>
		<dd>Matches all devices.

		<dt><dfn>print</dfn>
		<dd>Matches printers, and devices intended to reproduce a printed display,
			such as a web browser showing a document in “Print Preview”.

		<dt><dfn>screen</dfn>
		<dd>Matches all devices that aren't matched by ''print''.

		<dt><dfn>speech</dfn>
		<dd>Matches screenreaders and similar devices that “read out” a page.
	</dl>

	In addition, the following <strong>deprecated</strong> <a>media types</a> are defined.
	Authors must not use these <a>media types</a>;
	instead, it is recommended that they select appropriate <a>media features</a>
	that better represent the aspect of the device that they are attempting to style against.

	User agents must recognize the following <a>media types</a> as valid,
	but must make them match nothing.

	<ul dfn-type=value dfn-for="@media">
		<li><dfn>tty</dfn>
		<li><dfn>tv</dfn>
		<li><dfn>projection</dfn>
		<li><dfn>handheld</dfn>
		<li><dfn>braille</dfn>
		<li><dfn>embossed</dfn>
		<li><dfn>aural</dfn>
	</ul>

	Note: It is expected that all of the media types will also be deprecated in time,
	as appropriate <a>media features</a> are defined which capture their important differences.


<h3 id='mq-features'>
Media Features</h3>

	A <dfn export>media feature</dfn> is a more fine-grained test than <a>media types</a>,
	testing a single, specific feature of the user agent or display device.

	Syntactically, <a>media features</a> resemble CSS properties:
	they consist of a feature name, a colon, and a value to test for.
	They may also be written in boolean form as just a feature name,
	or in range form with a comparison operator.

	<pre class='railroad'>
		Diagram(
			"(",
			Choice(0,
				And(
					NT("feature name"),
					":",
					NT("feature value")),
				NT("feature name"),
				And(NT("range form"), C("(see below)"))),
			")")
	</pre>

	There are, however, several important differences between properties and media features:

	<ul>
		<li>
			Properties are used to give information about how to present a document.
			Media features are used to describe requirements of the output device.

		<li>
			Media features are always wrapped in parentheses
			and combined with the ''and'' keyword,
			like ''(color) and (min-width: 600px)'',
			rather than being separated with semicolons.

		<li>
			A media feature may be given with <em>only</em> its name
			(omitting the colon and value)
			to evaluate the feature in a <a>boolean context</a>.
			This is a convenient shorthand for features that have a reasonable value representing 0 or “none”.
			For example, ''(color)'' is true is the 'color' <a>media feature</a> is non-zero.

		<li>
			<a>Media features</a> with “range” type can be written in a <a>range context</a>,
			which uses standard mathematical comparison operators rather than a colon,
			or have their feature names <a href=#mq-min-max>prefixed with “min-” or “max-”</a>.

		<li>
			Properties sometimes accept complex values,
			e.g., calculations that involve several other values.
			<a>Media features</a> only accept single values: one keyword, one number, etc.
	</ul>

	If a media feature does not apply to the device where the UA is running,
	that <a>media feature</a> will always be false.

	<div class="example">
		The media feature ''device-aspect-ratio'' only applies to
		visual devices. On an ''speech'' device, expressions involving
		''device-aspect-ratio'' will therefore always be false:

		<pre>
			&lt;link media="speech and (device-aspect-ratio: 16/9)"
			      rel="stylesheet" href="example.css">
		</pre>
	</div>

<h4 id='mq-ranges'>
Media Feature Types: “range” and “discrete”</h4>

	Every media feature defines its “type” as either “range” or “discrete” in its definition table.

	“Discrete” media features,
	like 'luminosity' or 'script',
	take their values from a set.
	The values may be keywords
	or boolean numbers (0 and 1),
	but the common factor is that there's no intrinsic “order” to them--
	none of the values are “less than” or “greater than” each other.

	“Range” media features like 'width', on the other hand,
	take their values from a range.
	Any two values can be compared to see which is lesser and which is greater.

	The only significant difference between the two types is that “range” <a>media features</a>
	can be evaluated in a <a>range context</a>
	and accept “min-” and “max-” prefixes on their name.
	Doing either of these changes the meaning of the feature--
	rather than the <a>media feature</a> being true when the feature exactly matches the given value,
	it matches when the feature is greater than/less than/equal to the given value.

	<div class='example'>
		A <span class=css data-link-type=maybe>(width >= 600px)</span> <a>media feature</a> is true
		when the viewport's width is ''600px'' <em>or more</em>.

		On the other hand, ''(width: 600px)'' by itself is only true
		when the viewport's width is <em>exactly</em> ''600px''.
		If it's less or greater than ''600px'', it'll be false.
	</div>

<h4 id='mq-boolean-context'>
Evaluating Media Features in a Boolean Context</h4>

	While <a>media features</a> normally have a syntax similar to CSS properties,
	they can also be written more simply as just the feature name,
	like ''(color)''.

	When written like this, the <a>media feature</a> is evaluated in a <dfn export>boolean context</dfn>.
	If the feature would be true for the number ''0'',
	a dimension with the value ''0'',
	or the keyword ''none'',
	the <a>media feature</a> is false.
	Otherwise, it's true.

	<div class='example'>
		Some <a>media features</a> are designed to be written like this,
		and only accept the values ''0'' and ''1''.

		For example, 'script' is typically written as ''(script)'' to test if scripting is enabled,
		or ''not (script)'' to see if it's disabled.

		It can still be given an explicit value as well,
		with ''(script: enabled)'' equal to ''(script)'',
		and ''(script: none)'' equal to ''not (script)''.
	</div>

	<div class='example'>
		Some numeric <a>media features</a>, like 'width',
		are rarely if ever useful to evaluate in a <a>boolean context</a>,
		as their values are almost always greater than zero.
		Others, like 'color', have meaningful zero values:
		''(color)'' is identical to ''(color > 0)'',
		indicating that the device is capable of displaying color at all.
	</div>

	<div class='example'>
		Only some of the <a>media features</a> that accept keywords are meaningful in a <a>boolean context</a>.

		For example, ''(pointer)'' is useful,
		as 'pointer' has a ''pointer/none'' value to indicate there's no pointing device at all on the device.
		On the other hand, ''(scan)'' is just always true, as there's no value that means “false”.
	</div>


<h4 id="mq-range-context">
Evaluating Media Features in a Range Context</h4>


	<a>Media features</a> with a “range” type can be alternately written in a <dfn export>range context</dfn>
	that takes advantage of the fact that their values are ordered,
	using ordinary mathematical comparison operators:

	<pre class='railroad'>
	Diagram(
		'(',
		Or(0,
			Sequence(
				NT("feature name"),
				Choice(3,"<", "<=", ">", ">="),
				NT("value")),
			Sequence(
				NT("value"),
				Choice(0, "<", "<="),
				NT("feature name"),
				Choice(0, "<", "<="),
				NT("value")),
			Sequence(
				NT("value"),
				Choice(0, ">", ">="),
				NT("feature name"),
				Choice(0, ">", ">="),
				NT("value"))),
		')')
	</pre>

	The basic form,
	consisting of a feature name,
	a comparison operator,
	and a value,
	returns true if the relationship is true.

	<div class='example'>
		For example, <span class=css data-link-type=maybe>(height >= 600px)</span> returns true if the viewport height is greater than or equal to ''600px''.
	</div>

	The remaining forms,
	with the feature name nested between two value comparisons,
	returns true if both comparisons are true.

	<div class='example'>
		For example, ''(400px < width < 1000px)'' returns true if the viewport width is between ''400px'' and ''1000px''
		(but not equal to either).
	</div>

<h4 id='mq-min-max'>
Using “min-” and “max-” Prefixes On Range Features</h4>

	Rather than evaluating a “range” type <a>media feature</a> in a range context,
	as described above,
	the feature may be written as a normal <a>media feature</a>,
	but with a “min-” or “max-” prefix on the feature name.

	This is equivalent to evaluating the feature in a <a>range context</a>,
	as follows:

	<ul>
		<li>
			Using a “min-” prefix on a feature name is equivalent to using the “>=” operator.
			For example, ''(min-height: 600px)'' is equivalent to <span class=css data-link-type=maybe>(height >= 600px)</span>.

		<li>
			Using a “max-” prefix on a feature name is equivalent to using the “<=” operator.
			For example, ''(max-width: 40em)'' is equivalent to <span class=css data-link-type=maybe>(width <= 40em)</span>.
	</ul>

	“Discrete” type properties do not accept “min-” or “max-” prefixes.
	Adding such a prefix to a “discrete” type <a>media feature</a> simply results in an unknown feature name.

	<div class='example'>
		For example,
		''(min-grid: 1)'' is invalid,
		because 'grid' is a “discrete” <a>media feature</a>,
		and so doesn't accept the prefixes.
		(Even though the 'grid' <a>media feature</a> appears to be numeric,
		as it accepts the values ''0'' and ''1''.)
	</div>


<h2 id='mq-syntax'>
Syntax</h2>

	The media query syntax is described in terms of the
	<a href="http://www.w3.org/TR/CSS21/grammar.html">CSS2 grammar</a>. As such,
	rules not defined here are defined in CSS2. The
	<code>media_query_list</code> production defined below replaces the
	<code>media_list</code> production from CSS2. [[!CSS21]]

	<pre>
	media_query_list
		: S* [media_query [ ',' S* media_query ]* ]?
		;
	media_query
		: [ONLY S+ | NOT S+]? media_type [ S+ AND S+ expression ]* S*
		| expression [ S+ AND S+ expression ]* S*
		;
	media_type
		: IDENT
		;
	expression
		: '(' S* media_feature S* [ ':' S* expr ]? ')'
		;
	media_feature
		: IDENT
		;
	</pre>

	COMMENT tokens, as defined by CSS2, do not occur in the grammar (to keep
	it  readable), but any number of these tokens may appear anywhere between
	other tokens. [[!CSS21]]

	The following new definitions are introduced:

	<pre>
	L  l|\\0{0,4}(4c|6c)(\r\n|[ \t\r\n\f])?|\\l
	Y  y|\\0{0,4}(59|79)(\r\n|[ \t\r\n\f])?|\\y
	</pre>

	The following new tokens are introduced:

	<pre>
	{O}{N}{L}{Y}      {return ONLY;}
	{N}{O}{T}         {return NOT;}
	{A}{N}{D}         {return AND;}
	{num}{D}{P}{I}    {return RESOLUTION;}
	{num}{D}{P}{C}{M} {return RESOLUTION;}
	</pre>

	<code>RESOLUTION</code> is to be added to the CSS2
	<code>term</code> production.

	CSS style sheets are generally case-insensitive, and this is
	also the case for media queries.

	In addition to conforming to the syntax, each media query needs to use
	media types and media features according to their respective specification
	in order to be considered conforming.

	<div class="example">
		Only the first media query is conforming in the example below because the
		"example" media type does not exist.

		<pre>
		@media all { body { background:lime } }
		@media example { body { background:red } }
		</pre>
	</div>

<h3 id=error-handling>
Error Handling</h3>

	For media queries that are not conforming user agents need to follow the
	rules described in this section.

	<ul>
	 <li>
		<strong>Unknown media types.</strong> Unknown media types evaluate to
		false. Effectively, they are treated identically to known media types
		that do not match the media type of the device. However, an exception is made
		for media types ''not'', ''and'', ''only'' and ''or''. Even though they do
		match the IDENT production, they must not be treated as unknown media types,
		but rather trigger the malformed query clause.

		<div class="example">
			The media query "<code>unknown</code>" will evaluate to false, unless
			<code>unknown</code> is actually a supported media type. Similarly,
			"<code>not unknown</code>" will evaluate to true.
		</div>

		Note: Unknown media types are distinct from media types that do
		not actually match the IDENT production. Those fall under the malformed
		media query clause.

	 <li>
		<strong>Unknown media features.</strong> User agents are to represent a
		media query as "<code>not all</code>" when one of the specified media
		features is not known.

		<div class="example">
			<pre>&lt;link rel="stylesheet" media="screen and (max-weight: 3kg) and (color), (color)" href="example.css" /&gt;</pre>

			In this example, the first media query will be represented as
			"<code>not all</code>" and evaluate to false and the second media query
			is evaluated as if the first had not been specified, effectively.
		</div>

		<div class="example">
			<pre>@media (min-orientation:portrait) { … }</pre>

			Is represented as "<code>not all</code>" because the ''orientation''
			feature does not accept the ''min-'' prefix.
		</div>

	 <li>
		<strong>Unknown media feature values.</strong> As with unknown media
		features, user agents are to represent a media query as
		"<code>not all</code>" when one of the specified media feature values is
		not known.

		<div class="example">
			The media query <code>(color:20example)</code> specifies an unknown
			value for the ''color'' media feature and is therefore represented as
			"<code>not all</code>".
		</div>

		<div class="example">
			This media query is represented as "<code>not all</code>" because
			negative lengths are not allowed for the ''width'' media feature:

			<pre>@media (min-width: -100px) { … }</pre>
		</div>

	 <li>
		<strong>Malformed media query.</strong> User agents are to handle
		unexpected tokens encountered while parsing a media query by reading until
		the end of the media query, while observing
		<a href="http://www.w3.org/TR/CSS21/syndata.html#block">the rules for
		matching pairs</a> of (), [], {}, "", and &#39;&#39;, and correctly handling
		escapes. Media queries with unexpected tokens are represented as
		"<code>not all</code>". [[!CSS21]]

		<div class="example">
			<pre>
			@media (example, all,), speech { /* only applicable to speech devices */ }
			@media &amp;test, screen           { /* only applicable to screen devices */ }
			</pre>
		</div>

		<div class="example">
			The following is an malformed media query because having no space
			between ''and'' and the expression is not allowed. (That is reserved for
			the functional notation syntax.)
			<pre>@media all and(color) { … }</pre>
		</div>

		<div class="example">
			The following is a malformed media query because it uses ''only'' and ''or'' as media types.
			<pre>@media only and or { … }</pre>
		</div>

		Media queries are expected to follow the error handling rules of the
		host language as well.

		<div class="example">
			<pre>@media test;,all { body { background:lime } }</pre>

			… will not apply because the semicolon terminates the
			<code>@media</code> rule in CSS.
		</div>
	</ul>

<h2 id="media-features">
Media features</h2>

<h3 id="width">
width</h3>

	<pre class='descdef mq'>
	Name: width
	Value: <<length>>
	For: @media
	Type: range
	</pre>

	The '@media/width' media feature describes the width of the targeted display
	area of the output device. For continuous media, this is the width
	of the viewport (as described by CSS2, section 9.1.1 [[!CSS21]]) including
	the size of a rendered scroll bar (if any). For paged media, this is the
	width of the page box (as described by CSS2, section 13.2 [[!CSS21]]).

	A specified <<length>> cannot be negative.

	<div class="example">
		For example, this media query expresses that the style sheet is
		usable on printed output wider than 25cm:

		<pre>&lt;link rel="stylesheet" media="print and (min-width: 25cm)" href="http://…" /></pre>
	</div>

	<div class="example">
		This media query expresses that the style sheet is usable on
		devices with viewport (the part of the screen/paper where the
		document is rendered) widths between 400 and 700 pixels:

		<pre>@media screen and (min-width: 400px) and (max-width: 700px) { … }</pre>
	</div>

	<div class="example">
		This media query expresses that style sheet is usable on screen
		and handheld devices if the width of the viewport is greater than
		20em.

		<pre>
		@media handheld and (min-width: 20em),
			screen and (min-width: 20em) { … }
		</pre>

		The ''em'' value is relative to the initial value of
		‘font-size’.
	</div>


<h3 id="height">
height</h3>

	<pre class='descdef mq'>
	Name: height
	Value: <<length>>
	For: @media
	Type: range
	</pre>

	The 'height' media feature describes the height of the targeted display
	area of the output device. For continuous media, this is the height
	of the viewport including the size of a rendered scroll bar (if any). For
	paged media, this is the height of the page box.

	A specified <<length>> cannot be negative.

<h3 id="device-width">
device-width</h3>

	<pre class='descdef mq'>
	Name: device-width
	Value: <<length>>
	For: @media
	Type: range
	</pre>

	The 'device-width' media feature describes the width of the rendering
	surface of the output device. For continuous media, this is the width
	of the screen. For paged media, this is the width of the page sheet
	size.

	A specified &lt;length> cannot be negative.

	<div class="example">
		<pre>@media screen and (device-width: 800px) { … }</pre>

		In the example above, the style sheet will apply only to screens
		that currently displays exactly 800 horizontal pixels. The ''px'' unit is
		of the logical kind, as described in the <a href="#units">Units</a>
		section.
	</div>



<h3 id="device-height">
device-height</h3>

	<pre class='descdef mq'>
	Name: device-height
	Value: <<length>>
	For: @media
	Type: range
	</pre>

	The 'device-height' media feature describes the height of the rendering
	surface of the output device. For continuous media, this is the height
	of the screen. For paged media, this is the height of the page sheet
	size.

	A specified &lt;length> cannot be negative.

	<div class="example">
		<pre>&lt;link rel="stylesheet" media="screen and (device-height: 600px)" /&gt;</pre>

		In the example above, the style sheet will apply only to screens
		that have exactly 600 vertical pixels. Note that the definition of the
		''px'' unit is the same as in other parts of CSS.
	</div>


<h3 id='orientation'>
orientation</h3>

	<pre class='descdef mq'>
	Name: orientation
	Value: portrait | landscape
	For: @media
	Type: discrete
	</pre>

	The 'orientation' media feature is ''portrait'' when the value of the
	'height' media feature is greater than or equal to the value of the
	'width' media feature. Otherwise 'orientation' is ''landscape''.

	<div class="example">
		<pre>
		@media all and (orientation:portrait) { … }
		@media all and (orientation:landscape) { … }
		</pre>
	</div>


<h3 id='aspect-ratio'>
aspect-ratio</h3>

	<pre class='descdef mq'>
	Name: aspect-ratio
	Value: <<ratio>>
	For: @media
	Type: range
	</pre>

	The 'aspect-ratio' media feature is defined as the ratio of the value
	of the ''width'' media feature to the value of the ''height'' media
	feature.


<h3 id='device-aspect-ratio'>
device-aspect-ratio</h3>

	<pre class='descdef mq'>
	Name: device-aspect-ratio
	Value: <<ratio>>
	For: @media
	Type: range
	</pre>

	The 'device-aspect-ratio media feature is defined as the ratio of the
	value of the 'device-width' media feature to the value of the
	'device-height media feature.

	<div class="example">
		For example, if a screen device with square pixels has 1280 horizontal
		pixels and 720 vertical pixels (commonly referred to as "16:9"), the
		following Media Queries will all match the device:

		<pre>
		@media screen and (device-aspect-ratio: 16/9) { … }
		@media screen and (device-aspect-ratio: 32/18) { … }
		@media screen and (device-aspect-ratio: 1280/720) { … }
		@media screen and (device-aspect-ratio: 2560/1440) { … }
		</pre>
	</div>


<h3 id="color">
color</h3>

	<pre class='descdef mq'>
	Name: color
	Value: <<integer>>
	For: @media
	Type: range
	</pre>

	The 'color' media feature describes the number of bits per color
	component of the output device. If the device is not a color device,
	the value is zero.

	A specified <<integer>> cannot be negative.

	<div class="example">
		For example, these two media queries express that a style sheet
		applies to all color devices:

		<pre>
		@media all and (color) { … }
		@media all and (min-color: 1) { … }
		</pre>
	</div>

	<div class="example">
		This media query expresses that a style sheet applies to color
		devices with 2 or more bits per color component:

		<pre>@media all and (min-color: 2) { … }</pre>
	</div>

	If different color components are represented by
	different number of bits, the smallest number is used.

	<div class="example">
		For instance, if an 8-bit color system represents the red
		component with 3 bits, the green component with 3 bits and the blue
		component with 2 bits, the ''color'' media feature will have a value
		of 2.
	</div>

	In a device with indexed colors, the minimum number of bits per
	color component in the lookup table is used.

	Note: The described functionality is only able to describe color
	capabilities at a superficial level. If further functionality is
	required, RFC2531 [[RFC2531]] provides more specific media features
	which may be supported at a later stage.


<h3 id="color-index">
color-index</h3>

	<pre class='descdef mq'>
	Name: color-index
	Value: <<integer>>
	For: @media
	Type: range
	</pre>

	The 'color-index' media feature describes the number of entries
	in the color lookup table of the output device. If the device does not
	use a color lookup table, the value is zero.

	A specified <<integer>> cannot be negative.

	<div class="example">
		For example, here are two ways to express that a style sheet
		applies to all color index devices:

		<pre>
		@media all and (color-index) { … }
		@media all and (min-color-index: 1) { … }
		</pre>
	</div>


	<div class="example">
		This media query expresses that a style sheet applies to a color
		index device with 256 or more entries:

		<pre>
		&lt;?xml-stylesheet media="all and (min-color-index: 256)"
			href="http://www.example.com/…" ?&gt;
		</pre>
	</div>

<h3 id="monochrome">
monochrome</h3>

	<pre class='descdef mq'>
	Name: monochrome
	Value: <<integer>>
	For: @media
	Type: range
	</pre>

	The 'monochrome' media feature describes the number of bits per
	pixel in a monochrome frame buffer. If the device is not a
	monochrome device, the output device value will be 0.

	A specified <<integer>> cannot be negative.

	<div class="example">
		For example, here are two ways to express that a style sheet
		applies to all monochrome devices:

		<pre>
		@media all and (monochrome) { … }
		@media all and (min-monochrome: 1) { … }
		</pre>
	</div>

	<div class="example">
		Express that a style sheet applies to monochrome
		devices with more than 2 bits per pixels:

		<pre>@media all and (min-monochrome: 2) { … }</pre>
	</div>


	<div class="example">
		Express that there is one style sheet for color pages and another for monochrome:

		<pre>
		&lt;link rel="stylesheet" media="print and (color)" href="http://…" /&gt;
		&lt;link rel="stylesheet" media="print and (monochrome)" href="http://…" /&gt;
		</pre>
	</div>

<h3 id="resolution">
resolution</h3>

	<pre class='descdef mq'>
	Name: resolution
	Value: <<resolution>>
	For: @media
	Type: range
	</pre>

	The 'resolution' media feature describes the resolution of the output device, i.e. the density of the pixels.
	When querying devices with non-square pixels,
	in 'min-resolution' queries the least-dense dimension must be compared to the specified value
	and in 'max-resolution' queries the most-dense dimensions must be compared instead.
	A 'resolution' (without a "min-" or "max-" prefix) query never matches a device with non-square pixels.

	For printers, this corresponds to the screening resolution
	(the resolution for printing dots of arbitrary color).
	Printers might have a different resolution for grayscale printing.

	<p class="issue">
		Another media feature should probably be added to deal with the type of resolution authors want to know to deal with monochrome printing.

	<div class="example">
		For example, this media query expresses that a style sheet is usable on devices with resolution greater than 300 dots per CSS ''in'':

		<pre>@media print and (min-resolution: 300dpi) { … }</pre>
	</div>


	<div class="example">
		This media query expresses that a style sheet is usable on devices with resolution greater than 118 dots per CSS ''cm'':

		<pre>@media print and (min-resolution: 118dpcm) { … }</pre>
	</div>



<h3 id="scan">
scan</h3>

	<pre class='descdef mq'>
	Name: scan
	Value: progressive | interlace
	For: @media
	Type: discrete
	</pre>

	The 'scan media feature describes the scanning process of "tv"
	output devices.

	<div class="example">
		For example, this media query expresses that a style sheet is
		usable on tv devices with progressive scanning:

		<pre>@media tv and (scan: progressive) { … }</pre>
	</div>

<h3 id="grid">
grid</h3>

	<pre class='descdef mq'>
	Name: grid
	Value: <<mq-boolean>>
	For: @media
	Type: discrete
	</pre>

	The 'grid' media feature is used to query whether the output device
	is grid or bitmap. If the output device is grid-based (e.g., a "tty"
	terminal, or a phone display with only one fixed font), the value will
	be 1. Otherwise, the value will be 0.

	<div class="example">
		Here is an example:

		<pre>
		@media handheld and (grid) and (max-width: 15em) { … }
		</pre>
	</div>


<h3 id="script">
script</h3>

	<pre class='descdef mq'>
	Name: script
	Value: none | enabled
	For: @media
	Type: discrete
	</pre>

	The 'script' media feature is used to query whether ECMAscript is supported
	on the current document.

	<dl dfn-type=value dfn-for="@media/script">
		<dt><dfn>enabled</dfn>
		<dd>
			Indicates that the user agent supports ECMAscript
			and that support is active for the current document.

		<dt><dfn>none</dfn>
		<dd>
			Indicates that the user agent will not run scripts for this document;
			either it doesn't support ECMAScript,
			or the support isn't active for the current document.
	</dl>

	Some user agents have the ability to turn off ECMAscript support on a per script basis or per domain basis,
	allowing some, but not all, scripts to run in a particular document.
	The 'script' media feature does not allow fine grained detection of which script is allowed to run.
	In this scenario, the value of the 'script' media feature should be ''script/enabled''
	if scripts originating on the same domain as the document are allowed to run,
	and ''script/none'' otherwise.

	Note: A future level of CSS may extend this media feature to allow fine-grained detection of which script is allowed to run.

<h3 id="pointer">
pointer</h3>

	<pre class='descdef mq'>
	Name: pointer
	Value: none | coarse | fine
	For: @media
	Type: discrete
	</pre>

	The 'pointer' media feature is used to query about the presence and
	accuracy of a pointing device such as a mouse. If a device has multiple input
	mechanisms, it is recommended that the UA reports the characteristics of the
	least capable pointing device of the primary input mechanisms. This
	media query takes the following values:

	<dl dfn-type=value dfn-for="@media/pointer">
		<dt><dfn>none</dfn>
		<dd>The input mechanism of the device does not include a pointing device.

		<dt><dfn>coarse</dfn>
		<dd>The input mechanism of the device includes a pointing device of limited accuracy.

		<dt><dfn>fine</dfn>
		<dd>The input mechanism of the device includes an accurate pointing device.
	</dl>

	Both ''coarse'' and ''fine'' indicate the presence of a pointing device, but
	differ in accuracy. A pointing device with which it would be difficult or
	impossible to reliably pick one of several small adjacent targets at a zoom
	factor of 1 would qualify as ''coarse''. Changing the zoom level does not
	affect the value of this media feature.

	Note: As the UA may provide the user with the ability to zoom, or as
	secondary pointing devices may have a different accuracy, the user may be able
	to perform accurate clicks even if the value of this media feature is
	''coarse''. This media feature does not indicate that the user will never be
	able to click accurately, only that it is inconvenient for them to do so.
	Authors are expected to react to a value of ''coarse'' by designing pages that
	do not rely on accurate clicking to be operated.

	<div class='note'>
		Typical examples of devices matching combinations of 'pointer' and 'hover':

		<table id='pointer-hover-table'>
			<thead>
				<tr>
					<td><td><th colspan=2>pointer
				<tr>
					<td>
					<td>
					<th>coarse
					<th>fine
			<tbody>
				<tr>
					<th rowspan=2>hover
					<th>none
					<td>smartphones, touch screens
					<td>stylus-based screens (Cintiq, Wacom, etc)
				<tr>
					<th>over
					<td>Nintendo Wii controller, Kinect
					<td>mouse, touch pad
		</table>
		<style>
			#pointer-hover-table { margin: 1em auto; text-align: center; border-collapse: collapse; max-width: 40em; }
			#pointer-hover-table td, #pointer-hover-table th { padding: .5em; }
			#pointer-hover-table thead tr+tr th { border-bottom: 1px solid silver; }
			#pointer-hover-table tbody td:first-of-type { border-left: 1px solid silver; }
		</style>
	</div>

	For accessibility reasons, even on devices whose pointing device can be
	described as ''fine'', the UA may give a value of ''coarse'' or ''pointer/none'' to
	this media query, to indicate that the user has difficulties
	manipulating the input device accurately or at all.

	<div class="example">
		<pre>
		/* Make radio buttons and check boxes larger if we have an inaccurate pointing device */
		@media (pointer:coarse) {
			input[type="checkbox"], input[type="radio"] {
				min-width:30px;
				min-height:40px;
				background:transparent;
			}
		}
		</pre>
	</div>

<h3 id="hover">
hover</h3>

	<pre class='descdef mq'>
	Name: hover
	Value: none | on-demand | over
	For: @media
	Type: discrete
	</pre>

	The 'hover' media feature is used to query whether primary pointing system
	used on the output device can hover or not.

	<dl dfn-type=value dfn-for="@media/hover">
		<dt><dfn>none</dfn>
		<dd>
			Indicates that the primary pointing system can't hover,
			or there is no pointing system.

		<dt><dfn>on-demand</dfn>
		<dd>
			Indicates that the primary pointing system can hover,
			but it requires a significant action on the user's part.
			For example, some devices can't normally hover,
			but will activate hover on a “long press”.

		<dt><dfn>over</dfn>
		<dd>
			Indicates that the primary pointing system can easily hover over parts of the page.
	</dl>

	If a device has multiple pointing devices, some of which support hovering
	and some of which not, it is  recommended that the UA reports the hovering
	ability of the least capable of the primary pointing devices.

	<div class='example'>
		For example, on a touch screen device that can also be controlled by an optional mouse,
		the 'hover' <a>media feature</a> should match ''hover/none'',
		as the primary interaction mode (touching the screen) can't hover.

		Authors should therefore be careful not to assume that the ':hover' pseudo class
		will never match on device where 'hover:none' is true,
		but they should design layouts that do not depend on hovering to be fully usable.
	</div>

	<p class='issue'>
		Rob Coulburn points out that Mac devices turn off scrollbars when you plug in a mouse,
		which means that it *does* react to changing input devices.
		But is this just because it considers a plugged-in mouse to be "primary"?

	For accessibility reasons, even on devices that do support hovering,
	the UA may give a value of ''hover: none'' to this media query,
	to opt into layouts that work well without hovering.

	<div class="example">
		<pre>
		/* Only use a hover-activated drop down menu on devices that can hover. */
		@media (hover) {
			.menu > li        {display:inline-block;}
			.menu ul          {display:none; position:absolute;}
			.menu li:hover ul {display:block; list-style:none; padding:0;}
			/* ... */
		}
		</pre>
	</div>


<h3 id="luminosity">
luminosity</h3>

	<pre class='descdef mq'>
	Name: luminosity
	Value: dim | normal | washed
	For: @media
	Type: discrete
	</pre>

	The 'luminosity' media feature is used to query about the ambient luminosity in
	which the device is used, to allow the author to adjust style of the document
	in response. The following values are valid:

	<dl dfn-type=value dfn-for="@media/luminosity">
		<dt><dfn>dim</dfn>
		<dd>The device is used in a dim environment, where excessive contrast
		and brightness would be distracting or uncomfortable to the reader. For
		example: night time, or a dimly illuminated indoor environment.

		<dt><dfn>normal</dfn>
		<dd>The device is used in a environment with a level of luminosity in
		the ideal range for the screen, and which does not necessitate any
		particular adjustment.

		<dt><dfn>washed</dfn>
		<dd>The device is used in an exceptionally bright environment, causing the screen to be washed out and difficult to read. For example: bright daylight.
	</dl>

	User agents should set the thresholds between the 3 levels in a way that
	takes into account the characteristics of the device.

	<div class="note">
		Even though it is expected that User Agents will adjust the
		value of this media feature based on ambient light sensors, this
		specification intentionally refrains from defining the 3 levels in
		terms of a measurement in lux, for several reasons:

		<ul>
			<li>Devices equipped with a light sensor usually adjust the
			brightness of the screen automatically. Depending on the level
			of adjustment, the thresholds for needing a low contrast or
			hight contrast content may vary.
			<li>Different screen technologies wash out at very different
			levels of ambient luminosity; e-ink displays remain readable in
			bright daylight, while liquid crystal displays do not.
			<li>Many embedded light sensors are inaccurately calibrated,
			making it difficult to establish useful thresholds valid across
			devices.
		</ul>
	</div>

	For accessibility purposes, user agents may offer manual controls allowing
	the user to switch between the 3 levels of independently of the environment
	luminosity, as high contrast or low contrast styles may be more suitable for
	users with visual disabilities.

	<p class="issue">
		Using this media feature for accessibility purposes overlaps
		a lot with the high-contrast media feature proposed by Microsoft:
		<a href="http://msdn.microsoft.com/en-us/library/windows/apps/hh465764.aspx">http://msdn.microsoft.com/en-us/library/windows/apps/hh465764.aspx</a>.
		Can we adjust this so that it covers all use cases for both, or somehow
		modify them to work in an orthogonal, rather than overlapping,
		fashion?

	<div class="example">
		<pre>
		@media (luminosity: normal) {
			p { background: url("texture.jpg"); color: #333 }
		}
		@media (luminosity: dim) {
			p { background: #222; color: #ccc }
		}
		@media (luminosity: washed) {
			p { background: white; color: black; font-size: 2em; }
		}
		</pre>
	</div>

	<div class='issue'>
		We need a media feature (or set of media features) to detect the type of keyboard available.
		It should be able to distinguish between full computer keyboards, phone dial pads, tv remotes, or virtual keyboards.
		As an attempt at an exhaustive list is likely to fail,
		finding atomic features to decompose these into would be preferable,
		but these remain to be identified.

		<ul>
			<li>always vs in text forms only
			<li>just numbers vs free alphanumeric input vs full ime support
			<li>work properly vs horrible lag like on a tv remove
		</ul>

		How much is actually useful for styling?
	</div>

	<div class='issue'>
		RESPONSIBLE DEVICE DISCRIMINATION WITH MEDIA QUERIES

		<ul>
			<li>printer: updates:none, scroll:none, pointer:none, hover:none, pagination:pages
			<li>eink with stylus: printer: updates:slow, scroll:none, pointer:fine, hover:none, pagination:pages
			<li>tv updates: fast, scroll: none pointer coarse or none, hover: none: pagination:none
			<li>tablet: updates: fast, scroll: both, pointer coarse, hover none, pagination: none
			<li>wii: updates fast, scroll: both, pointer: coarse, hover: yes, pagination: none
			<li>Chromebook pixel: updates: fast, scroll: both, pointer: coarse *and* fine, hover: over, pagination: none
			<li>Glass: updates: fast, scroll: none?, pointer: coarse? or none?, hover: none, pagination: none
			<li>XTERM: updates: fast: scroll: vertical: pointer:none hover:none, pagination:roll, grid:1
		</ul>
	</div>

	<div class='issue'>
		Feature for update speed:

		<pre>updates: none | slow | fast</pre>

		Except with a better name.

		Discriminates between static printing,
		e-ink and similar that can handle updates but not animations,
		and normal screens.
	</div>

	<div class='issue'>
		Pagination control:

		<pre>pagination: none | roll | pages</pre>

		"none" is normal screens - infinite in both dimensions.
		"roll" is things that are infinite in one dimension - terminals, roll printers, etc.
		"pages" is things that are paged.

		Any need to discriminate between things that just throw away paged overflow not in the paging dimension,
		and things that put it on the next page?
	</div>

<h2 id="changes">
Changes</h2>
<h3 id="changes-2012">
Changes Since the Media Queries Level 3</h3>

The following changes were made to this specification since the
<a href="http://www.w3.org/TR/2012/PR-css3-mediaqueries-20120426/">26 April 2012
Proposed Recomendation of Media Queries Level 3</a>:

<ul>
	<li>
		For a media feature <var>feature</var>,
		<code>(<var>feature</var>)</code> will evaluate to true if
		<code>(<var>feature</var>:<var>x</var>)</code> will evaluate to true
		for a value <var>x</var> other than zero or zero followed by a unit
		identifier (i.e., other than <code>0</code>, <code>0px</code>,
		<code>0em</code>, etc.)<ins> or the keyword ''none''</ins>.
	<li>The 'script' media feature was added.
	<li>The 'pointer' media feature was added.
	<li>The 'hover' media feature was added.
	<li>The 'luminosity' media feature was added.
	<li>''or'', ''and'', ''only'' and ''not'' are invalid media types.
	<li>White space is required around the keyword “and” as well as after “not” and “only”.
</ul>


<h2 class="no-num" id="acknowledgments">
Acknowledgments</h2>

This specification is the product of the W3C Working Group on
Cascading Style Sheets.

Comments from
 Arve Bersvendsen,
 Björn Höhrmann,
 Chris Lilley,
 Christoph Päper,
 L. David Baron,
 François Remy,
 Melinda Grant,
 Nicholas C. Zakas
 Philipp Hoschka,
 Rick Byers,
 Rijk van Geijtenbeek,
 Roger Gimson,
 Sigurd Lerstad,
 Simon Kissane,
 Simon Pieters,
 Steven Pemberton,
 and Susan Lesch
improved this specification.
