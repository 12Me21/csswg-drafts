<pre class='metadata'>
Title: CSSOM View Module
ED: http://dev.w3.org/csswg/cssom-view/
TR: http://www.w3.org/TR/cssom-view/
Previous Version: http://www.w3.org/TR/2009/WD-cssom-view-20090804/
Previous Version: http://www.w3.org/TR/2008/WD-cssom-view-20080222/
Previous Version: http://www.w3.org/TR/2000/REC-DOM-Level-2-Style-20001113/
Group: CSSWG
Status: WD
Shortname: cssom-view
Level: 1
Editor: Simon Pieters, Opera Software ASA http://www.opera.com, simonp@opera.com
Editor: Glenn Adams, Cox Communications&#44; Inc. http://www.cox.com, glenn.adams@cos.com, http://www.w3.org/wiki/User:Gadams
Former Editor: Anne van Kesteren, Opera Software ASA http://www.opera.com, annevk@annevk.nl, https://annevankesteren.nl/
Abstract: The APIs introduced by this specification provide authors with a way to inspect and manipulate the visual view of a document. This includes getting the position of element layout boxes, obtaining the width of the viewport through script, and also scrolling an element.
</pre>

Background {#background}
========================

Many of the features defined in this specification have been supported
by browsers for a long period of time. The goal of this specification is
to define these features in such a way that they can be implemented by all
browsers in an interoperable manner. The specification also defines a
couple of new features that will hopefully be useful to authors. (If they
are not you can bug us!)



Terminology {#terminology}
==========================

Terminology used in this specification is from
DOM,
CSSOM and
HTML.
[[!DOM]]
[[!CSSOM]]
[[!HTML]]

Issue: <dfn>MouseEvent</dfn> and <dfn>MouseEventInit</dfn> are defined in &hellip;

Issue: FIXME: All of these definitions should be removed, or put in a &lt;pre class='anchors'> block if necessary.

<dfn>DOMPoint</dfn>,
<dfn>DOMPointReadOnly</dfn>,
<dfn>DOMPointInit</dfn>,
<dfn>DOMRect</dfn>,
<dfn>DOMRectReadOnly</dfn>,
<dfn>DOMRectList</dfn> and
<dfn>DOMQuad</dfn> are defined in Geometry Interfaces Module. [[!GEOMETRY]]

<dfn>The HTML <code>body</code> element</dfn> is the first
<code>body</code>
<span data-anolis-spec=html title="HTML elements">HTML element</span> child of the root
<span data-anolis-spec=html title="HTML elements">HTML element</span> <code>html</code>.

<dfn>Content edge</dfn>,
<dfn>padding edge</dfn>,
<dfn>border edge</dfn>,
<dfn>margin edge</dfn> and
<dfn>canvas</dfn> are defined by CSS.
<!--[[!CSS]]-->

<dfn>Viewport</dfn> and <dfn>initial containing block</dfn> are defined by CSS 2.1. <!--[[!CSS]]-->

<dfn>Block flow direction</dfn> and <dfn>inline base direction</dfn> are defined in CSS Writing Modes Module. [[!CSSWRITINGMODES]]

<dfn>Converted to an IDL value</dfn> is defined in Web IDL. [[!WEBIDL]]

Elements and <a>viewports</a> have an associated <dfn>scrolling box</dfn> if has a scrolling mechanism<!--XXX xref--> or it overflows
its content area<!--XXX xref--> and the used value of the 'overflow-x' or 'overflow-y' property is ''overflow/hidden''. [[!CSSBOX]]

A <a>scrolling box</a> of a <a>viewport</a> or element has two <dfn>overflow directions</dfn>, depending on the <a>viewport’s</a> or
element's <a>block flow direction</a> and <a>inline base direction</a>, as follows:

<dl class=switch>
	<dt>If the <a>block flow direction</a> is top-to-bottom and the <a>inline base direction</a> is left-to-right
	<dt>If the <a>block flow direction</a> is left-to-right and the <a>inline base direction</a> is left-to-right
	<dd>Rightward and downward.

	<dt>If the <a>block flow direction</a> is top-to-bottom and the <a>inline base direction</a> is right-to-left
	<dt>If the <a>block flow direction</a> is right-to-left and the <a>inline base direction</a> is left-to-right
	<dd>Leftward and downward.

	<dt>If the <a>block flow direction</a> is right-to-left and the <a>inline base direction</a> is right-to-left
	<dd>Leftward and upward.

	<dt>If the <a>block flow direction</a> is left-to-right and the <a>inline base direction</a> is right-to-left
	<dd>Righward and upward.
</dl>

The term <dfn>scrolling area</dfn> refers to a box of a <a>viewport</a> or an element that has the following edges, depending on the
<a>viewport’s</a> or element's <a>scrolling box’s</a> <a>overflow directions</a>.

<table class="complex data">
 <thead>
  <tr>
   <th>If the <a>overflow directions</a> are&hellip;
   <th>For a <a>viewport</a>
   <th>For an element
 <tbody>
  <tr>
   <td>rightward and downward
   <td class=long>
    <dl>
     <dt>top edge
     <dd>The top edge of the <a>initial containing block</a>.
     <dt>right edge
     <dd>The right-most edge of the right edge of the <a>initial containing block</a> and the right <a>margin edge</a> of the
     <a>viewport’s</a> all descendant boxes.
     <dt>bottom edge
     <dd>The bottom-most edge of the bottom edge of the <a>initial containing block</a> and the bottom <a>margin edge</a> of the
     <a>viewport’s</a> all descendant boxes.
     <dt>left edge
     <dd>The left edge of the <a>initial containing block</a>.
    </dl>
   <td class=long>
    <dl>
     <dt>top edge
     <dd>The element's top <a>padding edge</a>.
     <dt>right edge
     <dd>The right-most edge of the element's right <a>padding edge</a> and the right <a>margin edge</a> of the element's all descendant boxes,
     excluding boxes that have an ancestor of the element as their containing block.
     <dt>bottom edge
     <dd>The bottom-most edge of the element's bottom <a>padding edge</a> and the bottom <a>margin edge</a> of the element's all descendant
     boxes, excluding boxes that have an ancestor of the element as their containing block.
     <dt>left edge
     <dd>The element's left <a>padding edge</a>.
    </dl>
  <tr>
   <td>leftward and downward
   <td class=long>
    <dl>
     <dt>top edge
     <dd>The top edge of the <a>initial containing block</a>.
     <dt>right edge
     <dd>The right edge of the <a>initial containing block</a>.
     <dt>bottom edge
     <dd>The bottom-most edge of the bottom edge of the <a>initial containing block</a> and the bottom <a>margin edge</a> of the
     <a>viewport’s</a> all descendant boxes.
     <dt>left edge
     <dd>The left-most edge of the left edge of the <a>initial containing block</a> and the left <a>margin edge</a> of the
     <a>viewport’s</a> all descendant boxes.
    </dl>
   <td class=long>
    <dl>
     <dt>top edge
     <dd>The element's top <a>padding edge</a>.
     <dt>right edge
     <dd>The element's right <a>padding edge</a>.
     <dt>bottom edge
     <dd>The bottom-most edge of the element's bottom <a>padding edge</a> and the bottom <a>margin edge</a> of the element's all descendant
     boxes, excluding boxes that have an ancestor of the element as their containing block.
     <dt>left edge
     <dd>The left-most edge of the element's left <a>padding edge</a> and the left <a>margin edge</a> of the element's all descendant boxes,
     excluding boxes that have an ancestor of the element as their containing block.
    </dl>
  <tr>
   <td>leftward and upward
   <td class=long>
    <dl>
     <dt>top edge
     <dd>The top-most edge of the top edge of the <a>initial containing block</a> and the top <a>margin edge</a> of the
     <a>viewport’s</a> all descendant boxes.
     <dt>right edge
     <dd>The right edge of the <a>initial containing block</a>.
     <dt>bottom edge
     <dd>The bottom edge of the <a>initial containing block</a>.
     <dt>left edge
     <dd>The left-most edge of the left edge of the <a>initial containing block</a> and the left <a>margin edge</a> of the
     <a>viewport’s</a> all descendant boxes.
    </dl>
   <td class=long>
    <dl>
     <dt>top edge
     <dd>The top-most edge of the element's top <a>padding edge</a> and the top <a>margin edge</a> of the element's all descendant boxes,
     excluding boxes that have an ancestor of the element as their containing block.
     <dt>right edge
     <dd>The element's right <a>padding edge</a>.
     <dt>bottom edge
     <dd>The element's bottom <a>padding edge</a>.
     <dt>left edge
     <dd>The left-most edge of the element's left <a>padding edge</a> and the left <a>margin edge</a> of the element's all descendant boxes,
     excluding boxes that have an ancestor of the element as their containing block.
    </dl>
  <tr>
   <td>rightward and upward
   <td class=long>
    <dl>
     <dt>top edge
     <dd>The top-most edge of the top edge of the <a>initial containing block</a> and the top <a>margin edge</a> of the
     <a>viewport’s</a> all descendant boxes.
     <dt>right edge
     <dd>The right-most edge of the right edge of the <a>initial containing block</a> and the right <a>margin edge</a> of the
     <a>viewport’s</a> all descendant boxes.
     <dt>bottom edge
     <dd>The bottom edge of the <a>initial containing block</a>.
     <dt>left edge
     <dd>The left edge of the <a>initial containing block</a>.
    </dl>
   <td class=long>
    <dl>
     <dt>top edge
     <dd>The top-most edge of the element's top <a>padding edge</a> and the top <a>margin edge</a> of the element's all descendant boxes,
     excluding boxes that have an ancestor of the element as their containing block.
     <dt>right edge
     <dd>The right-most edge of the element's right <a>padding edge</a> and the right <a>margin edge</a> of the element's all descendant boxes,
     excluding boxes that have an ancestor of the element as their containing block.
     <dt>bottom edge
     <dd>The element's bottom <a>padding edge</a>.
     <dt>left edge
     <dd>The element's left <a>padding edge</a>.
    </dl>
</table>

The <dfn title="scrolling area origin">origin</dfn> of a <a>scrolling area</a> is
the origin of the <a>initial containing block</a> if the <a>scrolling area</a> is a <a>viewport</a>,
and otherwise the top left padding edge of the element when the element has its default scroll position.
The x-coordinate increases rightwards, and the y-coordinate increases downwards.

The <dfn>beginning edges</dfn> of a particular set of edges of a box or element are the following edges:

<dl class=switch>
 <dt>If the <a>overflow directions</a> are rightward and downward
 <dd>The top and left edges.
 <dt>If the <a>overflow directions</a> are leftward and downward
 <dd>The top and right edges.
 <dt>If the <a>overflow directions</a> are leftward and upward
 <dd>The bottom and right edges.
 <dt>If the <a>overflow directions</a> are rightward and upward
 <dd>The bottom and left edges.
</dl>

The <dfn>ending edges</dfn> of a particular set of edges of a box or element are the following edges:

<dl class=switch>
 <dt>If the <a>overflow directions</a> are rightward and downward
 <dd>The bottom and right edges.
 <dt>If the <a>overflow directions</a> are leftward and downward
 <dd>The bottom and left edges.
 <dt>If the <a>overflow directions</a> are leftward and upward
 <dd>The top and left edges.
 <dt>If the <a>overflow directions</a> are rightward and upward
 <dd>The top and right edges.
</dl>

The term <dfn>CSS layout box</dfn> refers to the same term in CSS. For the purpose
of the requirements in this specification, elements that have a computed value of the
'display' property that is ''table-column'' or
''table-column-group'' must be considered to have an associated <a>CSS layout box</a> (the column or column group, respectively).

The term <dfn>SVG layout box</dfn> refers to the same term in SVG.

<p class=issue>The terms <a>CSS layout box</a> and <a>SVG layout box</a> are not currently defined by CSS or SVG.

The term <dfn>layout box</dfn> refers to either a <a>CSS layout box</a> or an <a>SVG layout box</a>.

The term <dfn>transforms</dfn> refers to SVG transforms and CSS transforms. [[!SVG]] [[!CSSTRANSFORMS]]


<h3>CSS pixels</h3>

All coordinates and dimensions for the APIs defined in this
specification are in CSS pixels, unless otherwise specified. <!--[[!CSS]]-->

Note: This does not apply to e.g. {{matchMedia()}} as the units are explicitly given there.


<h3>Zooming</h3>

There are two kinds of zoom, <dfn>page zoom</dfn> which affects the size of the initial viewport<!-- XXX ref -->, and <dfn>pinch zoom</dfn> which acts like
a magnifying glass and does not affect the initial viewport<!-- XXX ref --> or actual viewport<!-- XXX ref -->. [[!CSSDEVICEADAPT]]


<h2>Common Infrastructure</h2>

<h3>Scrolling</h3>

When a user agent is to <dfn>perform a scroll</dfn> of a <a>scrolling box</a> <var>box</var>,
to a given position <var>position</var>,
an associated element <var>element</var> and optionally a scroll behavior <var>behavior</var>
(which is <code>auto</code> if omitted),
the following steps must be run:

<ol>
 <li><a title="smooth scroll aborted">Abort</a> any ongoing <a>smooth scroll</a> for <var>box</var>.
 <li>If the user agent honors the 'scroll-behavior' property and one of the following are true:
  <ul>
   <li><var>behavior</var> is <code>auto</code> and <var>element</var> is not null and its computed value of the
   'scroll-behavior' property is ''smooth''
   <li><var>behavior</var> is <code>smooth</code>
  </ul>
  ...then perform a <a>smooth scroll</a> of <var>box</var> to <var>position</var>.
  Otherwise, perform an <a>instant scroll</a> of <var>box</var> to <var>position</var>.
</ol>

When a user agent is to perform a <dfn id=concept-smooth-scroll>smooth scroll</dfn> of a <a>scrolling box</a> <var>box</var> to <var>position</var>,
it must update the scroll position of <var>box</var> in a user-agent-defined fashion over a user-agent-defined amount of time. When the scroll is
<dfn title="smooth scroll completed">completed</dfn>, the scroll position of <var>box</var> must be <var>position</var>. The scroll can also
be <dfn title="smooth scroll aborted">aborted</dfn>, either by an algorithm or by the user. <!--fingerprint-->

When a user agent is to perform an <dfn id=concept-instant-scroll>instant scroll</dfn> of a <a>scrolling box</a> <var>box</var> to
<var>position</var>, it must update the scroll position of <var>box</var> to <var>position</var>.

To <dfn>scroll to the beginning of the document</dfn> for a document <var>document</var>, follow these steps:

<ol>
 <li>Let <var>viewport</var> be the <a>viewport</a> that is associated with <var>document</var>. <!-- This assumes that there is a viewport, since
 it is only invoked when navigating -->
 <li>Let <var>position</var> be the the scroll position <var>viewport</var> would have by aligning the <span>beginning edges</span> of the
 <a>scrolling area</a> with the <span>beginning edges</span> of <var>viewport</var>.
 <li>If <var>position</var> is the same as <var>viewport</var>'s current scroll position, and <var>viewport</var> does not have an ongoing
 <a>smooth scroll</a>, abort these steps.
 <li><a>Perform a scroll</a> of <var>viewport</var> to <var>position</var>,
 and <var>document</var>'s root element as the associated element, if there is one, or null otherwise.
</ol>

Note: This algorithm is used when navigating to the <code>#top</code> fragment identifier, as defined in HTML. [[!HTML]]


<h3>WebIDL values</h3>

When asked to <dfn>normalize non-finite values</dfn> for a value <var>x</var>,
if <var>x</var> is one of the three special floating point literal values
(<code>Infinity</code>, <code>-Infinity</code> or <code>NaN</code>),
then <var>x</var> must be changed to the value <code>0</code>. [[!WEBIDL]]


<h2>Extensions to the <code>Window</code> Interface</h2>

<pre class=idl>
enum ScrollBehavior { "auto", "instant", "smooth" };

dictionary ScrollOptions {
	ScrollBehavior behavior = "auto";
};
dictionary ScrollToOptions : ScrollOptions {
	double left;
	double top;
};

partial interface Window {
	[NewObject] MediaQueryList matchMedia(DOMString query);
	[SameObject] readonly attribute Screen screen;

	// browsing context
	void moveTo(unrestricted double x, unrestricted double y);
	void moveBy(unrestricted double x, unrestricted double y);
	void resizeTo(unrestricted double x, unrestricted double y);
	void resizeBy(unrestricted double x, unrestricted double y);

	// viewport
	readonly attribute double innerWidth;
	readonly attribute double innerHeight;

	// viewport scrolling
	readonly attribute double scrollX;
	readonly attribute double pageXOffset;
	readonly attribute double scrollY;
	readonly attribute double pageYOffset;
	void scroll(optional ScrollToOptions options);
	void scroll(unrestricted double x, unrestricted double y);
	void scrollTo(optional ScrollToOptions options);
	void scrollTo(unrestricted double x, unrestricted double y);
	void scrollBy(optional ScrollToOptions options);
	void scrollBy(unrestricted double x, unrestricted double y);

	// client
	readonly attribute double screenX;
	readonly attribute double screenY;
	readonly attribute double outerWidth;
	readonly attribute double outerHeight;
	readonly attribute double devicePixelRatio;
};
</pre>

When the <dfn method for=Window>matchMedia(<var>query</var>)</dfn> method is invoked these steps must be run:
<ol>
 <li>Let <var>parsed media query list</var> be the result of
 <a title='parse a media query list'>parsing</a>
 <var>query</var>.
 <li>Return a new {{MediaQueryList}} object,
 with the <a>context object’s</a>
 <a>associated <code>Document</code></a>
 as the <a title="MediaQueryList document">document</a>,
 with <var>parsed media query list</var> as its associated <a>media query list</a>.
</ol>

The <dfn title=dom-Window-screen><code>screen</dfn> attribute must return the <code>Screen</code> object
associated with the <code data-anolis-spec=html>Window</code> object.
<p class='note'>Accessing <code title=dom-Window-screen>screen</code> through a <code data-anolis-spec=html>WindowProxy</code> object might yield different
results when the {{Document}} is navigated.

The <dfn title=dom-Window-moveTo>moveTo(<var>x</var>, <var>y</var>)</dfn> method must follow these steps:

<ol>
 <li>Optionally, terminate these steps.
 <li><span>Normalize non-finite values</span> for <var>x</var> and <var>y</var>.
 <li>Let <var>target</var> be the <span data-anolis-spec=html>browsing context</span> of the <span data-anolis-spec=dom>context
 object</span>.
 <li>Let <var>source</var> be the <span data-anolis-spec=html>responsible browsing context</span> of the <span data-anolis-spec=html>incumbent settings
 object</span>.
 <li>If <var>source</var> is not <span>allowed to resize and move</span> <var>target</var>, terminate these steps.
 <li>Optionally, clamp <var>x</var> and <var>y</var> in a user-agent-defined manner so that the window does not move outside the available space.
 <li>Move <var>target</var>'s window such that the window's top left corner is at coordinates (<var>x</var>, <var>y</var>) relative to the top left corner of
 the output device, measured in CSS pixels of <var>target</var>. The positive axes are rightward and downward.
</ol>

The <dfn title=dom-Window-moveBy>moveBy(<var>x</var>, <var>y</var>)</dfn> method must follow these steps:

<ol>
 <li>Optionally, terminate these steps.
 <li><span>Normalize non-finite values</span> for <var>x</var> and <var>y</var>.
 <li>Let <var>target</var> be the <span data-anolis-spec=html>browsing context</span> of the <span data-anolis-spec=dom>context
 object</span>.
 <li>Let <var>source</var> be the <span data-anolis-spec=html>responsible browsing context</span> of the <span data-anolis-spec=html>incumbent settings
 object</span>.
 <li>If <var>source</var> is not <span>allowed to resize and move</span> <var>target</var>, terminate these steps.
 <li>Optionally, clamp <var>x</var> and <var>y</var> in a user-agent-defined manner so that the window does not move outside the available space.
 <li>Move <var>target</var>'s window <var>x</var> CSS pixels of <var>target</var> righward and <var>y</var> CSS pixels of <var>target</var> downward.
</ol>


The <dfn title=dom-Window-resizeTo>resizeTo(<var>x</var>, <var>y</var>)</dfn> method must follow these steps:

<ol>
 <li>Optionally, terminate these steps.
 <li><span>Normalize non-finite values</span> for <var>x</var> and <var>y</var>.
 <li>Let <var>target</var> be the <span data-anolis-spec=html>browsing context</span> of the <span data-anolis-spec=dom>context
 object</span>.
 <li>Let <var>source</var> be the <span data-anolis-spec=html>responsible browsing context</span> of the <span data-anolis-spec=html>incumbent settings
 object</span>.
 <li>If <var>source</var> is not <span>allowed to resize and move</span> <var>target</var>, terminate these steps.
 <li>Optionally, clamp <var>x</var> and <var>y</var> in a user-agent-defined manner so that the window does not get too small or bigger than the available
 space.
 <li>Resize <var>target</var>'s window by moving its right and bottom edges such that the distance between the left and right edges of the viewport are
 <var>x</var> CSS pixels of <var>target</var> and the distance between the top and bottom edges of the viewport are <var>y</var> CSS pixels of
 <var>target</var>.
 <li>Optionally, move <var>target</var>'s window in a user-agent-defined manner so that it does not grow outside the available space.
</ol>

The <dfn title=dom-Window-resizeBy>resizeBy(<var>x</var>, <var>y</var>)</dfn> method must follow these steps:

<ol>
 <li>Optionally, terminate these steps.
 <li>Let <var>target</var> be the <span data-anolis-spec=html>browsing context</span> of the <span data-anolis-spec=dom>context
 object</span>.
 <li>Let <var>source</var> be the <span data-anolis-spec=html>responsible browsing context</span> of the <span data-anolis-spec=html>incumbent settings
 object</span>.
 <li>If <var>source</var> is not <span>allowed to resize and move</span> <var>target</var>, terminate these steps.
 <li>Optionally, clamp <var>x</var> and <var>y</var> in a user-agent-defined manner so that the window does not get too small or bigger than the available
 space.
 <li>Resize <var>target</var>'s window by moving its right edge <var>x</var> CSS pixels of <var>target</var> righward and its bottom edge <var>y</var> CSS
 pixels of <var>target</var> downward.
 <li>Optionally, move <var>target</var>'s window in a user-agent-defined manner so that it does not grow outside the available space.
</ol>

A <span data-anolis-spec=html>browsing context</span> <var>A</var> is <dfn>allowed to resize and move</dfn> a <span data-anolis-spec=html>browsing
context</span> <var>B</var> if all the following conditions are met:

<ul>
 <li><var>B</var> is an <span data-anolis-spec=html>auxiliary browsing context</span> that was created by a script (as opposed to by an action of the user).
 <li><var>A</var> is <span data-anolis-spec=html>familiar with</span> <var>B</var>.
</ul>

The <dfn title=dom-Window-innerWidth><code>innerWidth</dfn> attribute must return the <a>viewport</a> width including the size of a rendered
scroll bar (if any), or zero if there is no <a>viewport</a>. <!--fingerprint-->
<div class='example'>
 The following snippet shows how to obtain the width of the viewport:
 <pre>var viewportWidth = innerWidth</pre>
</div>


The  <dfn title=dom-Window-innerHeight><code>innerHeight</dfn> attribute must return the <a>viewport</a> height including the size of a rendered
scroll bar (if any), or zero if there is no <a>viewport</a>. <!--fingerprint-->


The <dfn title=dom-Window-scrollX><code>scrollX</dfn> attribute attribute must return the x-coordinate, relative to the <span>initial containing
block</span> origin, of the left of the <a>viewport</a>, or zero if there is no <a>viewport</a>. <!--fingerprint-->

The <dfn title=dom-Window-pageXOffset><code>pageXOffset</dfn> attribute must return the value returned by the
<code title=dom-Window-scrollX>scrollX</code> attribute.

The <dfn title=dom-Window-scrollY><code>scrollY</dfn> attribute attribute must return the y-coordinate, relative to the <span>initial containing
block</span> origin, of the top of the <a>viewport</a>, or zero if there is no <a>viewport</a>. <!--fingerprint-->

The <dfn title=dom-Window-pageYOffset><code>pageYOffset</dfn> attribute must return the value returned by the
<code title=dom-Window-scrollY>scrollY</code> attribute.

When the <dfn title=dom-Window-scroll><code>scroll()</dfn> method is invoked these
steps must be run:
<ol>
 <li>If invoked with one argument, follow these substeps:
  <ol>
   <li>Let <var>options</var> be the argument.
   <li>Let <var>x</var> be the value of the <code>left</code> dictionary member of <var>options</var>, if present, or the <a>viewport’s</a> current scroll position on the x axis otherwise.
   <li>Let <var>y</var> be the value of the <code>top</code> dictionary member of <var>options</var>, if present, or the <a>viewport’s</a> current scroll position on the y axis otherwise.
  </ol>
 <li>If invoked with two arguments, follow these substeps:
  <ol>
   <li>Let <var>options</var> be null <span title="converted to an IDL value">converted</span> to a <code>ScrollToOptions</code> dictionary. [[!WEBIDL]]
   <li>Let <var>x</var> and <var>y</var> be the arguments, respectively.
   <li><span>Normalize non-finite values</span> for <var>x</var> and <var>y</var>.
  </ol>
 <li>If there is no <a>viewport</a>, abort these steps.
 <li>Let <var>viewport width</var> be the width of the <a>viewport</a> excluding the width of the scroll bar, if any.
 <li>Let <var>viewport height</var> be the height of the <a>viewport</a> excluding the height of the scroll bar, if any.
 <li>
  <dl class=switch>
   <dt>If the <a>viewport</a> has rightward <span title="overflow directions">overflow direction</span>
   <dd>Let <var>x</var> be max(0, min(<var>x</var>,
   <a>viewport</a> <a>scrolling area</a> width - <var>viewport width</var>)).
   <dt>If the <a>viewport</a> has leftward <span title="overflow directions">overflow direction</span>
   <dd>Let <var>x</var> be min(0, max(<var>x</var>,
   <var>viewport width</var> - <a>viewport</a> <a>scrolling area</a>
   width)).
  </dl>
 <li>
  <dl class=switch>
   <dt>If the <a>viewport</a> has downward <span title="overflow directions">overflow direction</span>
   <dd>Let <var>y</var> be max(0, min(<var>y</var>,
   <a>viewport</a> <a>scrolling area</a> height - <var>viewport height</var>)).
   <dt>If the <a>viewport</a> has upward <span title="overflow directions">overflow direction</span>
   <dd>Let <var>y</var> be min(0, max(<var>y</var>,
   <var>viewport height</var> - <a>viewport</a> <a>scrolling area</a>
   height)).
  </dl>
 <li>Let <var>position</var> be the scroll position the <a>viewport</a> would have by aligning the x-coordinate <var>x</var> of the
 <a>viewport</a> <a>scrolling area</a> with the left of the <a>viewport</a> and aligning the y-coordinate <var>y</var> of the
 <a>viewport</a> <a>scrolling area</a> with the top of the <a>viewport</a>.
 <li>If <var>position</var> is the same as the <a>viewport’s</a> current scroll position, and the <a>viewport</a> does not have an ongoing
 <a>smooth scroll</a>, abort these steps.
 <li>Let <var>document</var> be the <a>viewport’s</a> associated {{Document}}.
 <li><a>Perform a scroll</a> of the <a>viewport</a> to <var>position</var>,
 <var>document</var>'s root element as the associated element, if there is one, or null otherwise,
 and the scroll behavior being the value of the <code>behavior</code> dictionary member of <var>options</var>.
</ol>

When the <dfn title=dom-Window-scrollTo><code>scrollTo()</dfn> method is invoked, the
user agent must act as if the <code title=dom-Window-scroll>scroll()</code> method was invoked with the same arguments.

When the <dfn title=dom-Window-scrollBy><code>scrollBy()</dfn> method is invoked, the
user agent must run these steps:
<ol>
 <li>If invoked with two arguments, follow these substeps:
  <ol>
   <li>Let <var>options</var> be null <span title="converted to an IDL value">converted</span> to a <code>ScrollToOptions</code> dictionary. [[!WEBIDL]]
   <li>Let <var>x</var> and <var>y</var> be the arguments, respectively.
   <li><span>Normalize non-finite values</span> for <var>x</var> and <var>y</var>.
   <li>Let the <code>left</code> dictionary member of <var>options</var> have the value <var>x</var>.
   <li>Let the <code>top</code> dictionary member of <var>options</var> have the value <var>y</var>.
  </ol>
 <li>Add the value of <code title="dom-Window-scrollX">scrollX</code> to the <code>left</code> dictionary member.
 <li>Add the value of <code title="dom-Window-scrollY">scrollY</code> to the <code>top</code> dictionary member.
 <li>Act as if the <code title=dom-Window-scroll>scroll()</code> method was invoked with
 <var>options</var> as the only argument.
</ol>

The <dfn title=dom-Window-screenX><code>screenX</dfn> attribute must return the x-coordinate,
relative to the origin of the screen of the output device, of the left of
the client window as number of pixels, or zero if there is no such
thing. <!--fingerprint-->

The <dfn title=dom-Window-screenY><code>screenY</dfn> attribute must return the y-coordinate,
relative to the origin of the screen of the output device, of the top of
the client window as number of pixels, or zero if there is no such
thing. <!--fingerprint-->

The <dfn title=dom-Window-outerWidth><code>outerWidth</dfn> attribute must return the width of the
client window. If there is no client window this
attribute must return zero. <!--fingerprint-->

The <dfn title=dom-Window-outerHeight><code>outerHeight</dfn> attribute must return the height of the
client window. If there is no client window this
attribute must return zero. <!--fingerprint-->

The <dfn title=dom-Window-devicePixelRatio><code>devicePixelRatio</dfn> attribute must return the result of the following algorithm:

<ol>
 <li>If there is no output device, return 1 and abort these steps.
 <li>Let <var>CSS pixel size</var> be the size of a CSS pixel at the current <span>page zoom</span> scale factor and at a <span>pinch zoom</span> scale
 factor of 1.0.
 <li>Let <var>device pixel size</var> be the vertical size of a device pixel of the output device.
 <li>Return the result of dividing <var>CSS pixel size</var> by <var>device pixel size</var>.
</ol>


<h4>The <var>features</var> argument to the <code>open()</code> method</h4>

HTML defines the <code data-anolis-spec=html title=dom-open>open()</code> method but has no defined effect for the third argument, <var>features</var>.
[[!HTML]]

This specification defines the effect of the <var>features</var> argument for user agents that do not opt to ignore it, as follows:

<ol>
 <li>If the method does not result in a new <span data-anolis-spec=html>auxiliary browsing context</span> being created, terminate these steps.
 <li>Let <var>target</var> be the new <span data-anolis-spec=html>auxiliary browsing context</span>.
 <li>Let <var>tokens</var> be the result of <span data-anolis-spec=html title="split a string on commas">splitting <var>features</var> on commas</span>.
 <li>Let <var>parsed features</var> be a new empty dictionary.
 <li><i>Token loop</i>: For each token <var>token</var> in <var>tokens</var>, follow these substeps:
  <ol>
   <li>Let <var>input</var> be <var>token</var>.
   <li>Let <var>position</var> point at the first character of <var>input</var>.
   <li><span data-anolis-spec=html>Skip whitespace</span>.
   <li><span data-anolis-spec=html>Collect a sequence of characters</span> that are not <span data-anolis-spec=html title="space character">space
   characters</span> nor "<code>=</code>" (U+003D). Let <var>name</var> be the collected characters, <span data-anolis-spec=dom>converted to ASCII
   lowercase</span>.
   <li>If <var>name</var> is in <var>parsed features</var> or if <var>name</var> is not a <span>supported <code>open()</code> feature name</span>,
   continue <i>token loop</i>.
   <li><span data-anolis-spec=html>Skip whitespace</span>.
   <li>If the character at <var>position</var> is not "<code>=</code>" (U+003D), continue <i>token loop</i>.
   <li>Advance <var>position</var> by one.
   <li>If <var>position</var> is past the end of <var>input</var>, continue <i>token loop</i>.
   <li><span data-anolis-spec=html>Collect a sequence of characters</span> that are any characters. Let <var>raw value</var> be the collected characters.
   <li>Let <var>value</var> be the result of invoking the <span data-anolis-spec=html>rules for parsing integers</span> on <var>raw value</var>.
   <li>If <var>value</var> is an error, continue <i>token loop</i>.
   <li>Set <var>name</var> in <var>parsed features</var> to <var>value</var>.
  </ol>
 <li>If <code title=dom-open-features-left>left</code> is present in <var>parsed features</var>, follow these substeps:
  <ol>
   <li>Let <var>x</var> be the value of <code title=dom-open-features-left>left</code>.
   <li>Optionally, clamp <var>x</var> in a user-agent-defined manner so that the window does not move outside the available space.
   <li>Optionally, move <var>target</var>'s window such that the window's left edge is at the horizontal coordinate <var>x</var> relative to the left edge of
   the output device, measured in CSS pixels of <var>target</var>. The positive axis is rightward.
  </ol>
 <li>If <code title=dom-open-features-top>top</code> is present in <var>parsed features</var>, follow these substeps:
  <ol>
   <li>Let <var>y</var> be the value of <code title=dom-open-features-top>top</code>.
   <li>Optionally, clamp <var>y</var> in a user-agent-defined manner so that the window does not move outside the available space.
   <li>Optionally, move <var>target</var>'s window such that the window's top edge is at the vertical coordinate <var>y</var> relative to the top edge of
   the output device, measured in CSS pixels of <var>target</var>. The positive axis is downward.
  </ol>
 <li>If <code title=dom-open-features-width>width</code> is present in <var>parsed features</var>, follow these substeps:
  <ol>
   <li>Let <var>x</var> be the value of <code title=dom-open-features-width>width</code>.
   <li>Optionally, clamp <var>x</var> in a user-agent-defined manner so that the window does not get too small or bigger than the available space.
   <li>Optionally, size <var>target</var>'s window by moving its right edge such that the distance between the left and right edges of the viewport are
   <var>x</var> CSS pixels of <var>target</var>.
   <li>Optionally, move <var>target</var>'s window in a user-agent-defined manner so that it does not grow outside the available space.
  </ol>
 <li>If <code title=dom-open-features-height>height</code> is present in <var>parsed features</var>, follow these substeps:
  <ol>
   <li>Let <var>y</var> be the value of <code title=dom-open-features-height>height</code>.
   <li>Optionally, clamp <var>y</var> in a user-agent-defined manner so that the window does not get too small or bigger than the available space.
   <li>Optionally, size <var>target</var>'s window by moving its bottom edge such that the distance between the top and bottom edges of the viewport are
   <var>y</var> CSS pixels of <var>target</var>.
   <li>Optionally, move <var>target</var>'s window in a user-agent-defined manner so that it does not grow outside the available space.
  </ol>
</ol>

A <dfn>supported <code>open()</code> feature name</dfn> is one of the following:

<dl>
 <dt><dfn title=dom-open-features-width>width</dfn>
 <dd>The width of the viewport.
 <dt><dfn title=dom-open-features-height>height</dfn>
 <dd>The height of the viewport.
 <dt><dfn title=dom-open-features-left>left</dfn>
 <dd>The left position of the window.
 <dt><dfn title=dom-open-features-top>top</dfn>
 <dd>The top position of the window.
</dl>


<h3>The {{MediaQueryList}} Interface</h3>

A {{MediaQueryList}} object has an associated <dfn>media query list</dfn>
and an associated <dfn concept for=MediaQueryList>document</dfn> set on creation.

A {{MediaQueryList}} object has an associated <dfn concept for=MediaQueryList>media</dfn> which is the
<a title='serialize a media query list'>serialized</a> form of the associated <a>media query list</a>.

A {{MediaQueryList}} object has an associated <dfn concept for=MediaQueryList>matches state</dfn> which is
true if the associated <a>media query list</a> matches the state of the <a concept>document</a>, and false otherwise.

<!--XXX update the matches state when flushing layout (offsetWidth et al), without firing a change event. -->

When asked to <dfn>evaluate media queries and report changes</dfn> for a {{Document}} <var>doc</var>, run these steps:

<ol>

 <li>

  For each {{MediaQueryList}} object <var>target</var> that has <var>doc</var> as its <a concept>document</a>,
  in the order they were created, oldest first, run these substeps:

  <ol>

   <li>If <var>target</var>'s <a concept>matches state</a> has changed since the last time these steps were run,
   <a>dispatch</a> a new <a>event</a> to <var>target</var>
   using the {{MediaQueryList}} interface,
   with its {{Event/type}} attribute initialized to <code>change</code>,
   its {{Event/isTrusted}} attribute initialized to true,
   its {{MediaQueryList/media}} attribute initialized to <var>target</var>'s <a concept>media</a>,
   and its {{MediaQueryListEvent/matches}} attribute initialized to <var>target</var>'s <a concept>matches state</a>. <!--fingerprint-->

  </ol>

</ol>

<div class='example'>
	A simple piece of code that detects changes in the orientation of the viewport can be written as follows:

	<pre>
	function handleOrientationChange(event) {
		if(event.matches) // landscape
			&hellip;
		else
			&hellip;
	}
	var mql = matchMedia("(orientation:landscape)");
	mql.onchange = handleOrientationChange;</pre>
</div>

<pre class=idl>
interface MediaQueryList : EventTarget {
  readonly attribute DOMString media;
  readonly attribute boolean matches;
  void addListener(EventListener? listener);
  void removeListener(EventListener? listener);
           attribute EventHandler onchange;
};
</pre>

The <dfn attribute for=MediaQueryList>media</dfn> attribute must return
the associated <span title=concept-MediaQueryList-media>media</span>.

The <dfn attribute for=MediaQueryList>matches</dfn> attribute must return
the associated <a concept>matches state</a>. <!--fingerprint-->

The <dfn method for=MediaQueryList>addListener(<var>listener</var>)</dfn> method must run these steps:

1. If <var>listener</var> is null, terminate these steps.
2. Append an <a>event listener</a> to the associated list of <a>event listeners</a>
	with <b>type</b> set to <code>change</code>,
	<b>callback</b> set to <var>listener</var>,
	and <b>capture</b> set to false,
	unless there already is an <a>event listener</a> in that list
	with the same <b>type</b>, <b>callback</b>, and <b>capture</b>.

The <dfn method for=MediaQueryList>removeListener(<var>listener</var>)</dfn> method must run these steps:

1. Remove an <a>event listener</a> from the associated list of <a>event listeners</a>,
	whose <b>type</b> is <code>change</code>,
	<b>callback</b> is <var>listener</var>,
	and <b>capture</b> is false.

Note: This specification initially had a custom callback mechanism with {{addListener()}} and
{{removeListener()}}, and the callback was invoked with the associated media query list as argument.
Now the normal event mechanism is used instead.
For backwards compatibility, the {{addListener()}} and {{removeListener()}} methods
are basically aliases for {{addEventListener()}} and {{removeEventListener()}}, respectively,
and the <code>change</code> event masquerades as a {{MediaQueryList}}.

The following are the <a>event handlers</a>
(and their corresponding <a>event handler event types</a>) that must be supported,
as <a>event handler IDL attributes</a>, by all objects implementing the {{MediaQueryList}} interface:

<table class="complex data">
 <thead>
  <tr>
   <th><a>Event handler</a>
   <th><a>Event handler event type</a>


 <tbody>
  <tr>
   <td><dfn title=handler-MediaQueryList-onchange>onchange</dfn>
   <td><code>change</code>


</table>

<pre class=idl>
[Constructor(DOMString type, optional MediaQueryListEventInit eventInitDict)]
interface MediaQueryListEvent : Event {
  readonly attribute DOMString media;
  readonly attribute boolean matches;
};

dictionary MediaQueryListEventInit : EventInit {
  DOMString media = "";
  boolean matches = false;
};
</pre>

The <dfn attribute for=MediaQueryListEvent>media</dfn> attribute must return the value it was initialized to.

The <dfn attribute for=MediaQueryListEvent>matches</dfn> attribute must return the value it was initialized to.

<h3>The <code>Screen</code> Interface</h3>

As its name suggests, the <code>Screen</code> interface represents information about the screen of the output device.

<pre class=idl>
interface Screen {
  readonly attribute double availWidth;
  readonly attribute double availHeight;
  readonly attribute double width;
  readonly attribute double height;
  readonly attribute unsigned long colorDepth;
  readonly attribute unsigned long pixelDepth;
};
</pre>

The <dfn title=dom-Screen-availWidth><code>availWidth</dfn> attribute must return the available width of the rendering surface of the output device,
in CSS pixels. <!--fingerprint-->

The <dfn title=dom-Screen-availHeight><code>availHeight</dfn> attribute must return the available height of the rendering surface of the output
device, in CSS pixels. <!--fingerprint-->

The <dfn title=dom-Screen-width><code>width</dfn> attribute must return the width of the output device, in CSS pixels. <!--fingerprint-->

The <dfn title=dom-Screen-height><code>height</dfn> attribute must return the height of the output device, in CSS pixels. <!--fingerprint-->

The <dfn title=dom-Screen-colorDepth><code>colorDepth</dfn> attribute must return 24.

The <dfn title=dom-Screen-pixelDepth><code>pixelDepth</dfn> attribute must return 24.

<p class=note>The <code title=dom-Screen-colorDepth>colorDepth</code> and <code title=dom-Screen-pixelDepth>pixelDepth</code> attributes are useless but are
included for compatibility.


<h2>Extensions to the <code>Document</code> Interface</h2>

<pre class=idl>partial interface <span data-anolis-spec=dom>Document</span> {
  <span data-anolis-spec=dom>Element</span>? <span title=dom-Document-elementFromPoint>elementFromPoint</span>(double x, double y);
  sequence&lt;<span data-anolis-spec=dom>Element</span>> <span title=dom-Document-elementsFromPoint>elementsFromPoint</span>(double x, double y);
  <span>CaretPosition</span>? <span title=dom-Document-caretPositionFromPoint>caretPositionFromPoint</span>(double x, double y);
};</pre>

The <dfn title=dom-Document-elementFromPoint><code>elementFromPoint(<var>x</var>, <var>y</var>)</dfn> method must follow these steps:

<ol>
 <li>If either argument is negative, <var>x</var> is greater than the <a>viewport</a> width excluding the size of a rendered scroll bar (if any), or
 <var>y</var> is greater than the <a>viewport</a> height excluding the size of a rendered scroll bar (if any), or there is no <a>viewport</a>
 associated with the document, return null and terminate these steps.
 <li>If there is a <span>layout box</span> in the <a>viewport</a> that would be a target for hit testing at coordinates <var>x</var>,<var>y</var>,
 when applying the <span>transforms</span> that apply to the descendants of the <a>viewport</a>, return the associated element and terminate these steps.
 <li>If the document has a root element, return the root element and terminate these steps.
 <li>Return null.
</ol>

<p class=note>The <code title=dom-Document-elementFromPoint>elementFromPoint()</code> method does not necessarily return the top-most painted element. For
instance, an element can be excluded from being a target for hit testing by using the 'pointer-events' CSS property.

<p class=atrisk>The <dfn title=dom-Document-elementsFromPoint><code>elementsFromPoint(<var>x</var>, <var>y</var>)</dfn> method must follow these steps:

<ol>
 <li>Let <var>sequence</var> be a new empty sequence.
 <li>If either argument is negative, <var>x</var> is greater than the <a>viewport</a> width excluding the size of a rendered scroll bar (if any), or
 <var>y</var> is greater than the <a>viewport</a> height excluding the size of a rendered scroll bar (if any), or there is no <a>viewport</a>
 associated with the document, return <var>sequence</var> and terminate these steps.
 <li>For each <span>layout box</span> in the <a>viewport</a>, in paint order, starting with the topmost box, that would be a target for hit testing at
 coordinates <var>x</var>,<var>y</var> even if nothing would be overlapping it, when applying the <span>transforms</span> that apply to the descendants of the
 <a>viewport</a>, append the associated element to <var>sequence</var>.
 <li>If the document has a root element, and the last item in <var>sequence</var> is not the root element, append the root element to <var>sequence</var>.
 <li>Return <var>sequence</var>.
</ol>

The <dfn title=dom-Document-caretPositionFromPoint><code>caretPositionFromPoint(<var>x</var>, <var>y</var>)</dfn> method must return the
result of running these steps:
<ol>
 <li>If there is no <a>viewport</a> associated with the document, return null.
 <li>If either argument is negative, <var>x</var> is greater
 than the <a>viewport</a> width excluding the size of a rendered
 scroll bar (if any), <var>y</var> is greather than the
 <a>viewport</a> height excluding the size of a rendered scroll bar
 (if any) return null.
 <li>If at the coordinates <var>x</var>,<var>y</var>
 in the <a>viewport</a> no text insertion point indicator would have
 been inserted when applying the <span>transforms</span> that apply to the descendants of the <a>viewport</a>, return null.
 <li>
  If at the coordinates <var>x</var>,<var>y</var>
  in the <a>viewport</a> a text insertion point indicator would have
  been inserted in a text entry widget which is also a replaced element, when applying the <span>transforms</span> that apply to the descendants of the
  <a>viewport</a>, return a <span>caret position</span> with its properties set as follows:
  <dl>
   <dt><span>caret node</span>
   <dd>The node corresponding to the text entry widget.
   <dt><span>caret offset</span>
   <dd>The amount of 16-bit units to the left of where the
   text insertion point indicator would have inserted.
   <dt><span>caret range</span>
   <dd>null
  </dl>

 <li>
  Otherwise, return a <span>caret position</span> where the
  <span>caret range</span> is a collapsed
  <code data-anolis-spec=dom>Range</code> object for the position
  where the text insertion point indicator would have been inserted when applying the <span>transforms</span> that apply to the descendants of the
  <a>viewport</a>, and the other properties are set as follows:
  <dl>
   <dt><span>caret node</span>
   <dd>The <code data-anolis-spec=dom title=dom-Range-startContainer>startContainer</code>
   of the <span>caret range</span>.
   <dt><span>caret offset</span>
   <dd>The <code data-anolis-spec=dom title=dom-Range-startOffset>startOffset</code> of
   the <span>caret range</span>.
  </dl>

</ol>
<p class='note'>The specifics of hit testing are out of scope of this
specification and therefore the exact details of
<code title=dom-Document-elementFromPoint>elementFromPoint()</code> and
<code title=dom-Document-caretPositionFromPoint>caretPositionFromPoint()</code>
are therefore too. Hit testing will hopefully be defined in a future
revision of CSS or HTML.

<h3>The <code>CaretPosition</code> Interface</h3>

A <dfn>caret position</dfn> gives the position of a text insertion point indicator. It always has an associated
<dfn>caret node</dfn>, <dfn>caret offset</dfn>, and <dfn>caret range</dfn>. It is represented by a <code>CaretPosition</code> object.

<pre class=idl>interface <dfn>CaretPosition</dfn> {
  readonly attribute <span data-anolis-spec=dom>Node</span> <span title=dom-CaretPosition-offsetNode>offsetNode</span>;
  readonly attribute unsigned long <span title=dom-CaretPosition-offset>offset</span>;
  <span>DOMRect</span>? <span title=dom-CaretPosition-getClientRect>getClientRect</span>();
};</pre>

The <dfn title=dom-CaretPosition-offsetNode><code>offsetNode</dfn> attribute must return the <span>caret node</span>.

The <dfn title=dom-CaretPosition-offset><code>offset</dfn> attribute must return the <span>caret offset</span>.

The <dfn title=dom-CaretPosition-getClientRect><code>getClientRect()</dfn> method must follow these steps, aborting on the first step that
returns a value:
<ol>
 <li>
  If <span>caret range</span> is not null:
  <ol>
   <li>Let <var>list</var> be the result of invoking the
   <code title=dom-Range-getClientRects>getClientRects()</code> method on the
   range.
   <li>If <var>list</var> is empty, return null.
   <li>Return the <code>DOMRect</code> object in <var>list</var> at index 0.
  </ol>
 <li>If <span>caret node</span> is a text entry widget that is a replaced element,
 and that is in the document, return a <code>DOMRect</code> object for the caret
 in the widget as represented by the <span>caret offset</span> value. The <span>transforms</span> that apply to the element and its ancestors are
 applied.
 <li>Return null.
</ol>

<h2>Extensions to the <code>Element</code> Interface</h2>

<pre class=idl>enum <dfn>ScrollLogicalPosition</dfn> { "start", <!--"center", -->"end" };<!--
enum <dfn>ScrollVerticalPosition</dfn> { "top", "center", "bottom" };
enum <dfn>ScrollHorizontalPosition</dfn> { "left", "center", "right" };-->
dictionary <dfn>ScrollIntoViewOptions</dfn> : <span>ScrollOptions</span> {
  <span>ScrollLogicalPosition</span> block = "start";<!--
  <span>ScrollLogicalPosition</span> inline;
  <span>ScrollVerticalPosition</span> vertical;
  <span>ScrollHorizontalPosition</span> horizontal;-->
};

partial interface <span data-anolis-spec=dom>Element</span> {
  <span>DOMRectList</span> <span title=dom-Element-getClientRects>getClientRects</span>();
  <span>DOMRect</span> <span title=dom-Element-getBoundingClientRect>getBoundingClientRect</span>();
  void <span title=dom-Element-scrollIntoView>scrollIntoView</span>();
  void <span title=dom-Element-scrollIntoView>scrollIntoView</span>((boolean or object) arg);
  void <span title=dom-Element-scroll>scroll</span>(optional <span>ScrollToOptions</span> options);
  void <span title=dom-Element-scroll>scroll</span>(unrestricted double x, unrestricted double y);
  void <span title=dom-Element-scrollTo>scrollTo</span>(optional <span>ScrollToOptions</span> options);
  void <span title=dom-Element-scrollTo>scrollTo</span>(unrestricted double x, unrestricted double y);
  void <span title=dom-Element-scrollBy>scrollBy</span>(optional <span>ScrollToOptions</span> options);
  void <span title=dom-Element-scrollBy>scrollBy</span>(unrestricted double x, unrestricted double y);
  attribute unrestricted double <span title=dom-Element-scrollTop>scrollTop</span>;
  attribute unrestricted double <span title=dom-Element-scrollLeft>scrollLeft</span>;
  readonly attribute double <span title=dom-Element-scrollWidth>scrollWidth</span>;
  readonly attribute double <span title=dom-Element-scrollHeight>scrollHeight</span>;
  readonly attribute double <span title=dom-Element-clientTop>clientTop</span>;
  readonly attribute double <span title=dom-Element-clientLeft>clientLeft</span>;
  readonly attribute double <span title=dom-Element-clientWidth>clientWidth</span>;
  readonly attribute double <span title=dom-Element-clientHeight>clientHeight</span>;
};</pre>

The <dfn title=dom-Element-getClientRects><code>getClientRects()</dfn> method, when invoked, must return the result of the following algorithm:
<ol>
 <li>If the element on which it was invoked does not have an associated
 <span>layout box</span> return an empty <code>DOMRectList</code> object and stop
 this algorithm.
 <li>If the element has an associated <a>SVG layout box</a> return a
 <code>DOMRectList</code> object containing a single
 <code>DOMRect</code> object that describes the bounding box of the
 element as defined by the SVG specification, applying the <span>transforms</span> that apply to the element and its ancestors.
 <li>
  Return a <code>DOMRectList</code> object containing a list of
  <code>DOMRect</code> objects in content order describing the bounding border
  boxes (including those with a height or width of zero) with the
  following constraints:
  <ul>
   <li>Apply the <span>transforms</span> that apply to the element and its ancestors.
   <li>If the element on which the method was invoked has a computed
   value for the 'display' property of 'table' or
   'inline-table' include both the table box and the caption
   box, if any, but not the anonymous container box.
   <li>Replace each
   <a href='http://www.w3.org/TR/CSS21/visuren.html#anonymous-block-level'>anonymous
   block box</a> with its child box(es) and repeat this until no anonymous
   block boxes are left in the final list.
  </ul>

</ol>

The <dfn title=dom-Element-getBoundingClientRect><code>getBoundingClientRect()</dfn> method, when invoked, must return the result of the following
algorithm:
<ol>
 <li>Let <var>list</var> be the result of invoking
 <code title=dom-Element-getClientRects>getClientRects()</code> on the
 same element this method was invoked on.
 <li>If the <var>list</var> is empty return a <code>DOMRect</code>
 object whose <code>x</code>,
 <code>y</code>,
 <code>width</code> and
 <code>height</code> members are zero.
 <li>Otherwise, return a <code>DOMRect</code> object describing the
 smallest rectangle that includes the first rectangle in <var>list</var>
 and all of the remaining rectangles of which the height or width is not
 zero.
</ol>
<div class='example'>
 The following snippet gets the dimensions of the first
 <code>div</code> element in a document:
 <pre>var example = document.getElementsByTagName("div")[0].getBoundingClientRect();
var exampleWidth = example.width;
var exampleHeight = example.height;</pre>
</div>

The <dfn title=dom-Element-scrollIntoView><code>scrollIntoView(<var>arg</var>)</dfn> method must run these steps:
<ol>
 <!-- scrollIntoView() means top=true but scrollIntoView(undefined) means top=false, to align with impls. -->
 <li>Let <var>options</var> be null.
 <li>If <var>arg</var> is an object, let <var>options</var> be <var>arg</var>.
 <li><span title="converted to an IDL value">Convert</span> <var>options</var> to a <code>ScrollIntoViewOptions</code> dictionary. [[!WEBIDL]]
 <li>If <var>arg</var> is false, let the <code>block</code> dictionary member of <var>options</var> have the value "<code>end</code>".
 <li>If the element does not have any associated <span>layout box</span> terminate these steps.
 <li><span title='scroll an element into view'>Scroll the element into view</span>
 with the <i>align to top</i> flag set if <var>options</var> <code>block</code> dictionary member has the value "<code>start</code>",
 and the scroll behavior being the value of the <code>behavior</code> dictionary member of <var>options</var>.
 <li>Optionally perform some other action that brings the element to the user's attention.
</ol>

The <dfn title=dom-Element-scroll><code>scroll()</dfn> method must run these steps:
<ol>
 <li>If invoked with one argument, follow these substeps:
  <ol>
   <li>Let <var>options</var> be the argument.
   <li>Let <var>x</var> be the value of the <code>left</code> dictionary member of <var>options</var>, if present, or the element's current scroll position on the x axis otherwise.
   <li>Let <var>y</var> be the value of the <code>top</code> dictionary member of <var>options</var>, if present, or the element's current scroll position on the y axis otherwise.
  </ol>
 <li>If invoked with two arguments, follow these substeps:
  <ol>
   <li>Let <var>options</var> be null <span title="converted to an IDL value">converted</span> to a <code>ScrollToOptions</code> dictionary. [[!WEBIDL]]
   <li>Let <var>x</var> and <var>y</var> be the arguments, respectively.
   <li><span>Normalize non-finite values</span> for <var>x</var> and <var>y</var>.
   <li>Let the <code>left</code> dictionary member of <var>options</var> have the value <var>x</var>.
   <li>Let the <code>top</code> dictionary member of <var>options</var> have the value <var>y</var>.
  </ol>
 <li>If the element is the root element and the {{Document}} is in
 <span data-anolis-spec=dom title=concept-document-quirks>quirks mode</span>, terminate these steps.
 <li>If the element is the root element invoke
 <code title=dom-Window-scroll>scroll()</code> with <code title=dom-Window-scrollX>scrollX</code> as first
 argument and <var>y</var> as second argument, and terminate these steps.
 <li>If the element is <span>the HTML <code>body</code> element</span>,
 the {{Document}} is in <span data-anolis-spec=dom title=concept-document-quirks>quirks mode</span>, and the element
 does not have an associated <a>scrolling box</a>, invoke
 <code title=dom-Window-scroll>scroll()</code> with
 <var>options</var> as the only argument, and
 terminate these steps.
 <li>If the element does not have any associated <a>CSS layout box</a>, the element has no associated <a>scrolling box</a>, or the element has no
 overflow, terminate these steps.
 <li><span title='scroll an element'>Scroll the element</span> to
 <var>x</var>,<var>y</var>, with the scroll behavior being the value of the <code>behavior</code> dictionary member of <var>options</var>.
</ol>

When the <dfn title=dom-Element-scrollTo><code>scrollTo()</dfn> method is invoked, the
user agent must act as if the <code title=dom-Element-scroll>scroll()</code> method was invoked with the same arguments.

When the <dfn title=dom-Element-scrollBy><code>scrollBy()</dfn> method is invoked, the
user agent must run these steps:
<ol>
 <li>If invoked with two arguments, follow these substeps:
  <ol>
   <li>Let <var>options</var> be null <span title="converted to an IDL value">converted</span> to a <code>ScrollToOptions</code> dictionary. [[!WEBIDL]]
   <li>Let <var>x</var> and <var>y</var> be the arguments, respectively.
   <li><span>Normalize non-finite values</span> for <var>x</var> and <var>y</var>.
   <li>Let the <code>left</code> dictionary member of <var>options</var> have the value <var>x</var>.
   <li>Let the <code>top</code> dictionary member of <var>options</var> have the value <var>y</var>.
  </ol>
 <li>Add the value of <code title="dom-Element-scrollLeft">scrollLeft</code> to the <code>left</code> dictionary member.
 <li>Add the value of <code title="dom-Element-scrollTop">scrollTop</code> to the <code>top</code> dictionary member.
 <li>Act as if the <code title=dom-Element-scroll>scroll()</code> method was invoked with
 <var>options</var> as the only argument.
</ol>

The <dfn title=dom-Element-scrollTop><code>scrollTop</dfn> attribute, on getting, must return the result of running these steps:
<ol>
 <li>If the element is the root element and the {{Document}} is in
 <span data-anolis-spec=dom title=concept-document-quirks>quirks mode</span>, return zero and terminate these steps.
 <li>If the element is the root element return the value of
 <code title='dom-Window-scrollY'>scrollY</code>.
 <li>If the element is <span>the HTML <code>body</code> element</span>,
 the {{Document}} is in <span data-anolis-spec=dom title=concept-document-quirks>quirks mode</span>, and the element does not have
 an associated <a>scrolling box</a>, return the value of
 <code title=dom-Window-scrollY>scrollY</code>.
 <li>If the element does not have any associated <a>CSS layout box</a>, return zero and terminate these steps.
 <li>Return the y-coordinate of the <a>scrolling area</a> at the
 alignment point with the top of the <a>padding edge</a> of the
 element.
</ol>
When setting the <code title=dom-Element-scrollTop>scrollTop</code> attribute these steps must be run:
<ol>
 <li>Let <var>y</var> be the given value.
 <li><span>Normalize non-finite values</span> for <var>y</var>.
 <li>If the element is the root element and the {{Document}} is in
 <span data-anolis-spec=dom title=concept-document-quirks>quirks mode</span>, terminate these steps.
 <li>If the element is the root element invoke
 <code title=dom-Window-scroll>scroll()</code> with <code title=dom-Window-scrollX>scrollX</code> as first
 argument and <var>y</var> as second argument, and terminate these steps.
 <li>If the element is <span>the HTML <code>body</code> element</span>,
 the {{Document}} is in <span data-anolis-spec=dom title=concept-document-quirks>quirks mode</span>, and the element
 does not have an associated <a>scrolling box</a>, invoke
 <code title=dom-Window-scroll>scroll()</code> with
 <code title=dom-Window-scrollX>scrollX</code> as first
 argument and <var>y</var> as second argument, and
 terminate these steps.
 <li>If the element does not have any associated <a>CSS layout box</a>, the element has no associated <a>scrolling box</a>, or the element has no
 overflow, terminate these steps.
 <li><span title='scroll an element'>Scroll the element</span> to
 <code title=dom-Element-scrollLeft>scrollLeft</code>,<var>y</var>, with the scroll behavior being <code>auto</code>.
</ol>

The <dfn title=dom-Element-scrollLeft><code>scrollLeft</dfn> attribute, on getting, must return the result of running these steps:
<ol>
 <li>If the element is the root element and the {{Document}} is in
 <span data-anolis-spec=dom title=concept-document-quirks>quirks mode</span>, return zero and terminate these steps.
 <li>If the element is the root element return the value of
 <code title=dom-Window-scrollX>scrollX</code>.
 <li>If the element is <span>the HTML <code>body</code> element</span>,
 the {{Document}} is in <span data-anolis-spec=dom title=concept-document-quirks>quirks mode</span>, and the element does not have
 an associated <a>scrolling box</a>, return the value of
 <code title=dom-Window-scrollX>scrollX</code>.
 <li>If the element does not have any associated <a>CSS layout box</a>, return zero and terminate these steps.
 <li>Return the x-coordinate of the <a>scrolling area</a> at the
 alignment point with the left of the <a>padding edge</a> of the
 element.
</ol>
When setting the <code title=dom-Element-scrollLeft>scrollLeft</code> attribute these steps must be run:
<ol>
 <li>Let <var>x</var> be the given value.
 <li><span>Normalize non-finite values</span> for <var>x</var>.
 <li>If the element is the root element and the {{Document}} is in
 <span data-anolis-spec=dom title=concept-document-quirks>quirks mode</span>, terminate these steps.
 <li>If the element is the root element invoke
 <code title=dom-Window-scroll>scroll()</code> with
 <var>x</var> as first argument and <code title=dom-Window-scrollY>scrollY</code> as second argument, and terminate these steps.
 <li>If the element is <span>the HTML <code>body</code> element</span>,
 the {{Document}} is in <span data-anolis-spec=dom title=concept-document-quirks>quirks mode</span>, and the element
 does not have an associated <a>scrolling box</a>, invoke
 <code title='dom-Window-scroll'>scroll()</code> with
 <var>x</var> as first argument and
 <code title=dom-Window-scrollY>scrollY</code> as second
 argument, and terminate these steps.
 <li>If the element does not have any associated <a>CSS layout box</a>, the element has no associated <a>scrolling box</a>, or the element has no
 overflow, terminate these steps.
 <li><span title='Scroll an element'>Scroll the element</span> to
 <var>x</var>,<code title=dom-Element-scrollTop>scrollTop</code>, with the scroll behavior being <code>auto</code>.
</ol>

The <dfn title=dom-Element-scrollWidth><code>scrollWidth</dfn> attribute must return the result of running these steps:
<ol>
 <li>Let <var>viewport width</var> be the width of the <a>viewport</a> excluding the width of the scroll bar, if any, or zero if there is no
 <a>viewport</a>.
 <li>If the element is the root element and the
 {{Document}} is not in
 <span data-anolis-spec=dom title=concept-document-quirks>quirks mode</span>
 return max(<a>viewport</a> <a>scrolling area</a> width, <var>viewport width</var>).
 <li>If the element is <span>the HTML <code>body</code> element</span>, the {{Document}} is in
 <span data-anolis-spec=dom title=concept-document-quirks>quirks mode</span> and the element has no associated <a>scrolling box</a>,
 return max(<a>viewport</a> <a>scrolling area</a> width, <var>viewport width</var>).
 <li>If the element does not have any associated <a>CSS layout box</a> return
 zero and terminate these steps.
 <li>Return the width of the element's <a>scrolling area</a>.
</ol>

The <dfn title=dom-Element-scrollHeight><code>scrollHeight</dfn> attribute must return the result of running these steps:
<ol>
 <li>Let <var>viewport height</var> be the height of the <a>viewport</a> excluding the height of the scroll bar, if any, or zero if there is no
 <a>viewport</a>.
 <li>If the element is the root element and the
 {{Document}} is not in
 <span data-anolis-spec=dom title=concept-document-quirks>quirks mode</span>
 return max(<a>viewport</a> <a>scrolling area</a> height, <var>viewport height</var>).
 <li>If the element is <span>the HTML <code>body</code> element</span>, the {{Document}} is in
 <span data-anolis-spec=dom title=concept-document-quirks>quirks mode</span> and the element has no associated <a>scrolling box</a>,
 return max(<a>viewport</a> <a>scrolling area</a> height, <var>viewport height</var>).
 <li>If the element does not have any associated <a>CSS layout box</a> return
 zero and terminate these steps.
 <li>Return the height of the element's <a>scrolling area</a>.
</ol>

The <dfn title=dom-Element-clientTop><code>clientTop</dfn> attribute must run these steps:
<ol>
 <li>If the element has no associated <a>CSS layout box</a> or if the <a>CSS layout box</a> is inline, return zero.
 <li>Return the computed value of the 'border-top-width' property plus the height of any scrollbar rendered between the top <span>padding
 edge</span> and the top <span>border edge</span>, ignoring any <span>transforms</span> that apply to the element and its ancestors.
</ol>

The <dfn title=dom-Element-clientLeft><code>clientLeft</dfn> attribute must run these steps:
<ol>
 <li>If the element has no associated <a>CSS layout box</a> or if the <a>CSS layout box</a> is inline, return zero.
 <li>Return the computed value of the 'border-left-width' property plus the width of any scrollbar rendered between the left <span>padding
 edge</span> and the left <span>border edge</span>, ignoring any <span>transforms</span> that apply to the element and its ancestors.
</ol>

The <dfn title=dom-Element-clientWidth><code>clientWidth</dfn> attribute must run these steps:
<ol>
 <li>If the element has no associated <a>CSS layout box</a> or if the <a>CSS layout box</a> is inline, return zero.
 <li>If the element is the root element and the element's document is not in <span data-anolis-spec=dom title=concept-document-quirks>quirks mode</span>, or
 if the element is <span>the HTML <code>body</code> element</span> and the element's document <em>is</em> in
 <span data-anolis-spec=dom title=concept-document-quirks>quirks mode</span>, return the <a>viewport</a> width excluding the size of a rendered scroll bar
 (if any).
 <li>Return the width of the <a>padding edge</a> excluding the width of any rendered scrollbar between the <a>padding edge</a> and the
 <span>border edge</span>, ignoring any <span>transforms</span> that apply to the element and its ancestors.
</ol>

The <dfn title=dom-Element-clientHeight><code>clientHeight</dfn> attribute must run these steps:
<ol>
 <li>If the element has no associated <a>CSS layout box</a> or if the <a>CSS layout box</a> is inline, return zero.
 <li>If the element is the root element and the element's document is not in <span data-anolis-spec=dom title=concept-document-quirks>quirks mode</span>, or
 if the element is <span>the HTML <code>body</code> element</span> and the element's document <em>is</em> in
 <span data-anolis-spec=dom title=concept-document-quirks>quirks mode</span>, return the <a>viewport</a> height excluding the size of a rendered scroll
 bar (if any).
 <li>Return the height of the <a>padding edge</a> excluding the height of any rendered scrollbar between the <a>padding edge</a> and the
 <span>border edge</span>, ignoring any <span>transforms</span> that apply to the element and its ancestors.
</ol>

<h3>The <code>getClientRects()</code> and
<code>getBoundingClientRect()</code> methods</h3>

The <code title=dom-Element-getClientRects>getClientRects()</code> and <code title=dom-Element-getBoundingClientRect>getBoundingClientRect()</code>
methods provide information about the position of the border box edges of
an element relative to the viewport. The objects these methods return
must be static. That is, changes to the underlying
document are not reflected in the objects.

<h3><code>Element</code> Scrolling Members</h3>

To <dfn>scroll an element into view</dfn> <var>element</var>, optionally with an <i>align to top flag</i> set, and optionally with a scroll behavior
<var>behavior</var> (which is <code>auto</code> if omitted), means to run these steps for each ancestor element or <a>viewport</a> that establishes
a <a>scrolling box</a> <var>scrolling box</var>, in order of innermost to outermost <a>scrolling box</a>:

<ol>
 <li>If the {{Document}} associated
 with <var>element</var> is not <span data-anolis-spec=html>same origin</span> with the
 {{Document}} associated with the element or
 <a>viewport</a> associated with <var>box</var>, terminate these
 steps.

 <li>Let <var>element bounding border box</var> be the box that the return value of invoking
 <code title=dom-Element-getBoundingClientRect>getBoundingClientRect()</code> on <var>element</var> represents.

 <li>Let <var>scrolling box edge A</var> be the <span title="beginning edges">beginning edge</span> in the <span>block flow direction</span> of
 <var>scrolling box</var>, and let <var>element edge A</var> be <var>element bounding border box</var>'s edge on the same physical side as that of
 <var>scrolling box edge A</var>.

 <li>Let <var>scrolling box edge B</var> be the <span title="ending edges">ending edge</span> in the <span>block flow direction</span> of <var>scrolling
 box</var>, and let <var>element edge B</var> be <var>element bounding border box</var>'s edge on the same physical side as that of <var>scrolling box edge
 B</var>.

 <li>Let <var>scrolling box edge C</var> be the <span title="beginning edges">beginning edge</span> in the <span>inline base direction</span> of
 <var>scrolling box</var>, and let <var>element edge C</var> be <var>element bounding border box</var>'s edge on the same physical side as that of
 <var>scrolling box edge C</var>.

 <li>Let <var>scrolling box edge D</var> be the <span title="ending edges">ending edge</span> in the <span>inline base direction</span> of <var>scrolling
 box</var>, and let <var>element edge D</var> be <var>element bounding border box</var>'s edge on the same physical side as that of <var>box edge D</var>.

 <li>Let <var>element width</var> be the distance between <var>element edge C</var> and <var>element edge D</var>.

 <li>Let <var>scrolling box width</var> be the distance between <var>scrolling box edge C</var> and <var>scrolling box edge D</var>.

 <li>Let <var>position</var> be the scroll position <var>scrolling box</var> would have by following these steps:

  <ol>
   <li>If the <i>align to top flag</i> is set align <var>element edge A</var> with <var>scrolling box edge A</var>.

   <li>Otherwise, the <i>align to top flag</i> is not set; align <var>element edge B</var> with <var>scrolling box edge B</var>.

   <li>
    <dl class=switch>
     <dt>If <var>element edge C</var> and <var>element edge D</var> are both outside <var>scrolling box edge C</var> and <var>scrolling box edge D</var>
     <dd>Do nothing.

     <dt>If <var>element edge C</var> is outside <var>scrolling box edge C</var> and <var>element width</var> is less than <var>scrolling box width</var>
     <dt>If <var>element edge D</var> is outside <var>scrolling box edge D</var> and <var>element width</var> is greater than <var>scrolling box width</var>
     <dd>Align <var>element edge C</var> with <var>scrolling box edge C</var>.

     <dt>If <var>element edge C</var> is outside <var>scrolling box edge C</var> and <var>element width</var> is greater than <var>scrolling box width</var>
     <dt>If <var>element edge D</var> is outside <var>scrolling box edge D</var> and <var>element width</var> is less than <var>scrolling box width</var>
     <dd>Align <var>element edge D</var> with <var>scrolling box edge D</var>.
    </dl>
  </ol>

 <li>If <var>position</var> is the same as <var>scrolling box</var>'s current scroll position, and <var>scrolling box</var> does not have an ongoing
 <a>smooth scroll</a>, abort these steps.

 <li>
  <dl class=switch>
   <dt>If <var>scrolling box</var> is associated with an element
   <dd>
    Let <var>associated element</var> be the element.


   <dt>If <var>scrolling box</var> is associated with a <a>viewport</a>
   <dd>
    Let <var>document</var> be the <a>viewport’s</a> associated {{Document}}.
    Let <var>associated element</var> be <var>document</var>'s root element, if there is one, or null otherwise.

  </dl>

 <li><a>Perform a scroll</a> of <var>scrolling box</var> to <var>position</var>,
 <var>associated element</var> as the associated element and <var>behavior</var> as the scroll behavior.

</ol>

To <dfn>scroll an element</dfn> <var>element</var> to <var>x</var>,<var>y</var> optionally with a scroll behavior <var>behavior</var> (which is
<code>auto</code> if omitted) means to:

<ol>
 <li>Let <var>box</var> be <var>element</var>'s associated <a>scrolling box</a>.
 <li>
  <dl class=switch>
   <dt>If <var>box</var> has rightward <span title="overflow directions">overflow direction</span>

   <dd>Let <var>x</var> be max(0, min(<var>x</var>,
   <var>element</var> <a>scrolling area</a> width -
   <var>element</var> <a>padding edge</a> width)).

   <dt>If <var>box</var> has leftward <span title="overflow directions">overflow direction</span>

   <dd>Let <var>x</var> be min(0, max(<var>x</var>,
   <var>element</var> <a>padding edge</a> width -
   <var>element</var> <a>scrolling area</a> width)).
  </dl>

 <li>
  <dl class=switch>
   <dt>If <var>box</var> has downward <span title="overflow directions">overflow direction</span>

   <dd>Let <var>y</var> be max(0, min(<var>y</var>,
   <var>element</var> <a>scrolling area</a> height -
   <var>element</var> <a>padding edge</a> height)).

   <dt>If <var>box</var> has upward <span title="overflow directions">overflow direction</span>

   <dd>Let <var>y</var> be min(0, max(<var>y</var>,
   <var>element</var> <a>padding edge</a> height -
   <var>element</var> <a>scrolling area</a> height)).
  </dl>

 <li>Let <var>position</var> be the scroll position <var>box</var> would have by aligning <a>scrolling area</a> x-coordinate
 <var>x</var> with the left of <var>box</var> and aligning <a>scrolling area</a> y-coordinate <var>y</var> with
 the top of <var>box</var>.

 <li>If <var>position</var> is the same as <var>box</var>'s current scroll position, and <var>box</var> does not have an ongoing
 <a>smooth scroll</a>, abort these steps.

 <li><a>Perform a scroll</a> of <var>box</var> to <var>position</var>,
 <var>element</var> as the associated element and <var>behavior</var> as the scroll behavior.

</ol>


<h2>Extensions to the <code>HTMLElement</code> Interface</h2>

<pre class=idl>partial interface <span data-anolis-spec=html>HTMLElement</span> {
  readonly attribute <span data-anolis-spec=dom>Element</span>? <span title=dom-HTMLElement-offsetParent>offsetParent</span>;
  readonly attribute double <span title=dom-HTMLElement-offsetTop>offsetTop</span>;
  readonly attribute double <span title=dom-HTMLElement-offsetLeft>offsetLeft</span>;
  readonly attribute double <span title=dom-HTMLElement-offsetWidth>offsetWidth</span>;
  readonly attribute double <span title=dom-HTMLElement-offsetHeight>offsetHeight</span>;
};</pre>

The <dfn title=dom-HTMLElement-offsetParent><code>offsetParent</dfn> attribute must return the result of running these steps:
<ol>
 <li>
  If any of the following holds true return null and terminate this
  algorithm:
  <ul>
   <li>The element does not have an associated <a>CSS layout box</a>.
   <li>The element is the root element.
   <li>The element is <span>the HTML <code>body</code> element</span>.
   <li>The element's computed value of the 'position' property is 'fixed'.
  </ul>

 <li>
  Return the nearest ancestor element of the element for which at least
  one of the following is true and terminate this algorithm if such an
  ancestor is found:
  <ul>
   <li>The computed value of the 'position' property is not 'static'.
   <li>It is <span>the HTML <code>body</code> element</span>.
   <li>The computed value of the 'position' property of
   the element is 'static' and the ancestor is one of the
   following <span data-anolis-spec=html title='HTML elements'>HTML elements</span>:
   <code>td</code>, <code>th</code>, or <code>table</code>.
  </ul>

 <li>Return null.
</ol>

The <dfn title=dom-HTMLElement-offsetTop><code>offsetTop</dfn> attribute must return the result of running these steps:
<ol>
 <li>If the element is <span>the HTML <code>body</code> element</span>
 or does not have any associated <a>CSS layout box</a> return zero and terminate
 this algorithm.
 <li>If the <code title=dom-HTMLElement-offsetParent>offsetParent</code> of the element is null return the
 y-coordinate of the top <span>border edge</span> of the first
 <a>CSS layout box</a> associated with the element, relative to the
 <a>initial containing block</a> origin, ignoring any <span>transforms</span> that apply to the element and its ancestors, and terminate this
 algorithm.
 <li>
  Return the result of subtracting the y-coordinate of the top
  <a>padding edge</a> of the first <a>CSS layout box</a> associated with
  the <code title=dom-HTMLElement-offsetParent>offsetParent</code> of the element from the y-coordinate of
  the top <span>border edge</span> of the first <a>CSS layout box</a> associated
  with the element, relative to the <a>initial containing block</a>
  origin, ignoring any <span>transforms</span> that apply to the element and its ancestors.
  <p class='note'>An inline element that consists of multiple line boxes
  will only have its first <a>CSS layout box</a> considered.

</ol>

The <dfn title=dom-HTMLElement-offsetLeft><code>offsetLeft</dfn> attribute must return the result of running these steps:
<ol>
 <li>If the element is <span>the HTML <code>body</code>
 element</span> or does not have any associated <a>CSS layout box</a> return zero
 and terminate this algorithm.
 <li>If the <code title=dom-HTMLElement-offsetParent>offsetParent</code> of the element is null return the
 x-coordinate of the left <span>border edge</span> of the first
 <a>CSS layout box</a> associated with the element, relative to the
 <a>initial containing block</a> origin, , ignoring any <span>transforms</span> that apply to the element and its ancestors, and terminate this
 algorithm.
 <li>
  Return the result of subtracting the x-coordinate of the left
  <a>padding edge</a> of the first <a>CSS layout box</a> associated with
  the <code title=dom-HTMLElement-offsetParent>offsetParent</code> of the element from the x-coordinate of
  the left <span>border edge</span> of the first <a>CSS layout box</a> associated
  with the element, relative to the <a>initial containing block</a>
  origin, ignoring any <span>transforms</span> that apply to the element and its ancestors.

</ol>

The <dfn title=dom-HTMLElement-offsetWidth><code>offsetWidth</dfn> attribute must return the result of running these steps:
<ol>
 <li>If the element does not have any associated <a>CSS layout box</a> return zero and terminate this algorithm.
 <li>Return the <span>border edge</span> width of the first <a>CSS layout box</a> associated with the element, ignoring any <span>transforms</span>
 that apply to the element and its ancestors.
</ol>

The <dfn title=dom-HTMLElement-offsetHeight><code>offsetHeight</dfn> attribute must return the result of running these steps:
<ol>
 <li>If the element does not have any associated <a>CSS layout box</a> return zero and terminate this algorithm.
 <li>Return the <span>border edge</span> height of the first <a>CSS layout box</a> associated with the element, ignoring any <span>transforms</span>
 that apply to the element and its ancestors.
</ol>


<h2>Excensions to the <code>HTMLImageElement</code> Interface</h2>

<pre class=idl>partial interface <span data-anolis-spec=html>HTMLImageElement</span> {
  readonly attribute double <span title=dom-HTMLImageElement-x>x</span>;
  readonly attribute double <span title=dom-HTMLImageElement-y>y</span>;
};</pre>

The <dfn title=dom-HTMLImageElement-x><code>x</dfn> attribute, on getting, must return the x-coordinate of the left <span>border edge</span> of the
first <a>CSS layout box</a> associated with the element, relative to the <a>initial containing block</a> origin, ignoring any
<span>transforms</span> that apply to the element and its ancestors, or zero if there is no <a>CSS layout box</a>.

The <dfn title=dom-HTMLImageElement-y><code>y</dfn> attribute, on getting, must return the y-coordinate of the top <span>border edge</span> of the
first <a>CSS layout box</a> associated with the element, relative to the <a>initial containing block</a> origin, ignoring any
<span>transforms</span> that apply to the element and its ancestors, or zero if there is no <a>CSS layout box</a>.


<h2>Extensions to the <code>Range</code> Interface</h2>

The objects the methods described below return must
be static.

<pre class=idl>partial interface <span data-anolis-spec=dom>Range</span> {
  <span>DOMRectList</span> <span title=dom-Range-getClientRects>getClientRects</span>();
  <span>DOMRect</span> <span title=dom-Range-getBoundingClientRect>getBoundingClientRect</span>();
};</pre>

The <dfn title=dom-Range-getClientRects><code>getClientRects()</dfn> method, when invoked, must return an empty
<code>DOMRectList</code> object if the range is not in the document and
otherwise a <code>DOMRectList</code> object containing a list of
<code>DOMRect</code> objects in content order that matches the
following constraints:
<ul>
 <li>For each element selected by the range, whose parent is not selected
 by the range, include the border boxes returned by invoking
 <code title=dom-Element-getClientRects>getClientRects()</code> on the
 element.
 <li>For each <code data-anolis-spec=dom>Text</code> node selected or partially selected by the
 range (including when the boundary-points are identical), include a
 <code>DOMRect</code> object (for the part that is selected, not the
 whole line box). The bounds of these <code>DOMRect</code> objects are
 computed using font metrics; thus, for horizontal writing, the vertical
 dimension of each box is determined by the font ascent and descent, and
 the horizontal dimension by the text advance width. The <span>transforms</span> that apply to the ancestors are applied.
</ul>

The <dfn title=dom-Range-getBoundingClientRect><code>getBoundingClientRect()</dfn> method, when invoked, must return the result of the following
algorithm:
<ol>
 <li>Let <var>list</var> be the result of invoking
 <code title=dom-Range-getClientRects>getClientRects()</code> on the
 same range this method was invoked on.
 <li>If <var>list</var> is empty return a
 <code>DOMRect</code> object whose
 <code>x</code>,
 <code>y</code>,
 <code>width</code> and
 <code>height</code> members are zero.
 <li>Otherwise, return a <code>DOMRect</code> object describing the
 smallest rectangle that includes the first rectangle in <var>list</var>
 and all of the remaining rectangles of which the height or width is not
 zero.
</ol>

<h2>Extensions to the <code>MouseEvent</code> Interface</h2>

<p class="issue">The object IDL fragment redefines some members. Can we
resolve this somehow?

<!-- x/y do not match IE in the position:relative case but do match other
browsers -->

<pre class=idl>partial interface <span>MouseEvent</span> {
  readonly attribute double <span title=dom-MouseEvent-screenX>screenX</span>;
  readonly attribute double <span title=dom-MouseEvent-screenY>screenY</span>;
  readonly attribute double <span title=dom-MouseEvent-pageX>pageX</span>;
  readonly attribute double <span title=dom-MouseEvent-pageY>pageY</span>;
  readonly attribute double <span title=dom-MouseEvent-clientX>clientX</span>;
  readonly attribute double <span title=dom-MouseEvent-clientY>clientY</span>;
  readonly attribute double <span title=dom-MouseEvent-x>x</span>;
  readonly attribute double <span title=dom-MouseEvent-y>y</span>;
  readonly attribute double <span title=dom-MouseEvent-offsetX>offsetX</span>;
  readonly attribute double <span title=dom-MouseEvent-offsetY>offsetY</span>;
};

partial dictionary <span>MouseEventInit</span> {
  double screenX = 0.0;
  double screenY = 0.0;
  double clientX = 0.0;
  double clientY = 0.0;
};</pre>

The <dfn title=dom-MouseEvent-screenX><code>screenX</dfn> attribute must return the x-coordinate of
the position where the event occurred relative to the origin of the
screen.

The <dfn title=dom-MouseEvent-screenY><code>screenY</dfn> attribute must return the y-coordinate of
the position where the event occurred relative to the origin of the
screen.

The <dfn title=dom-MouseEvent-pageX><code>pageX</dfn> attribute must follow these steps:

<ol>
 <li>If the event's <span data-anolis-spec=dom>dispatch flag</span> is set, return the horizontal coordinate of the position where the event occurred
 relative to the origin of the <a>initial containing block</a> and terminate these steps.
 <li>Let <var>offset</var> be the value of the <code title=dom-Window-scrollX>scrollX</code> attribute of the event's associated
 <code data-anolis-spec=html>Window</code> object, if there is one, or zero otherwise.
 <li>Return the sum of <var>offset</var> and the value of the event's <code title=dom-MouseEvent-clientX>clientX</code> attribute.
</ol>

The <dfn title=dom-MouseEvent-pageY><code>pageY</dfn> attribute must follow these steps:

<ol>
 <li>If the event's <span data-anolis-spec=dom>dispatch flag</span> is set, return the vertical coordinate of the position where the event occurred
 relative to the origin of the <a>initial containing block</a> and terminate these steps.
 <li>Let <var>offset</var> be the value of the <code title=dom-Window-scrollX>scrollX</code> attribute of the event's associated
 <code data-anolis-spec=html>Window</code> object, if there is one, or zero otherwise.
 <li>Return the sum of <var>offset</var> and the value of the event's <code title=dom-MouseEvent-clientY>clientY</code> attribute.
</ol>

The <dfn title=dom-MouseEvent-clientX><code>clientX</dfn> attribute must return the x-coordinate of
the position where the event occurred relative to the origin of the
<a>viewport</a>.

The <dfn title=dom-MouseEvent-clientY><code>clientY</dfn> attribute must return the y-coordinate of
the position where the event occurred relative to the origin of the
<a>viewport</a>.

The <dfn title=dom-MouseEvent-x><code>x</dfn> attribute must return the value of <code title=dom-MouseEvent-clientX>clientX</code>.

The <dfn title=dom-MouseEvent-y><code>y</dfn> attribute must return the value of <code title=dom-MouseEvent-clientY>clientY</code>.

The <dfn title=dom-MouseEvent-offsetX><code>offsetX</dfn> attribute must follow these steps:

<ol>
 <li>If the event's <span data-anolis-spec=dom>dispatch flag</span> is set, return the x-coordinate of the position where the event occurred relative to the
 origin of the <a>padding edge</a> of the target node, ignoring the <span>transforms</span> that apply to the element and its ancestors, and terminate
 these steps.
 <li>Return the value of the event's <code title=dom-MouseEvent-pageX>pageX</code> attribute.
</ol>

The <dfn title=dom-MouseEvent-offsetY><code>offsetY</dfn> attribute must follow these steps:

<ol>
 <li>If the event's <span data-anolis-spec=dom>dispatch flag</span> is set, return the y-coordinate of the position where the event occurred relative to the
 origin of the <a>padding edge</a> of the target node, ignoring the <span>transforms</span> that apply to the element and its ancestors, and terminate
 these steps.
 <li>Return the value of the event's <code title=dom-MouseEvent-pageY>pageY</code> attribute.
</ol>


<h2>Geometry</h2>

<h3 class=atrisk>The <code>GeometryUtils</code> Interface</h3>

<pre class=idl>enum <dfn>CSSBoxType</dfn> { "margin", "border", "padding", "content" };
dictionary <dfn>BoxQuadOptions</dfn> {
  <span>CSSBoxType</span> box = "border";
  <span>GeometryNode</span> relativeTo;
};

dictionary <dfn>ConvertCoordinateOptions</dfn> {
  <span>CSSBoxType</span> fromBox = "border";
  <span>CSSBoxType</span> toBox = "border";
};

[NoInterfaceObject]
interface <dfn>GeometryUtils</dfn> {
  sequence&lt;<span>DOMQuad</span>> <span title=dom-GeometryUtils-getBoxQuads>getBoxQuads</span>(optional <span>BoxQuadOptions</span> options);
  <span>DOMQuad</span> <span title=dom-GeometryUtils-convertQuadFromNode>convertQuadFromNode</span>(<span>DOMQuad</span> quad, <!--
  --><span>GeometryNode</span> from, optional <span>ConvertCoordinateOptions</span> options);
  <span>DOMQuad</span> <span title=dom-GeometryUtils-convertRectFromNode>convertRectFromNode</span>(<span>DOMRectReadOnly</span> rect, <!--
  --><span>GeometryNode</span> from, optional <span>ConvertCoordinateOptions</span> options);
  <span>DOMPoint</span> <span title=dom-GeometryUtils-convertPointFromNode>convertPointFromNode</span>(<span>DOMPointInit</span> point, <!--
  --><span>GeometryNode</span> from, optional <span>ConvertCoordinateOptions</span> options);
};

<span data-anolis-spec=dom>Text</span> implements <span>GeometryUtils</span>;
<span data-anolis-spec=dom>Element</span> implements <span>GeometryUtils</span>;
<span data-anolis-spec=cssom>PseudoElement</span> implements <span>GeometryUtils</span>;
<span data-anolis-spec=dom>Document</span> implements <span>GeometryUtils</span>;

typedef (<span data-anolis-spec=dom>Text</span> or <span data-anolis-spec=dom>Element</span> or <span data-anolis-spec=cssom>PseudoElement</span> or <!--
--><span data-anolis-spec=dom>Document</span>) <dfn>GeometryNode</dfn>;</pre>

The <dfn title=dom-GeometryUtils-getBoxQuads><code>getBoxQuads(<var>options</var>)</dfn> method must run the following steps:

<ol>
 <li><p class=issue>...
</ol>

The <dfn title=dom-GeometryUtils-convertQuadFromNode><code>convertQuadFromNode(<var>quad</var>, <var>from</var>, <var>options</var>)</dfn> method
must run the following steps:

<ol>
 <li><p class=issue>...
</ol>

The <dfn title=dom-GeometryUtils-convertRectFromNode><code>convertRectFromNode(<var>rect</var>, <var>from</var>, <var>options</var>)</dfn> method
must run the following steps:

<ol>
 <li><p class=issue>...
</ol>

The <dfn title=dom-GeometryUtils-convertPointFromNode><code>convertPointFromNode(<var>point</var>, <var>from</var>, <var>options</var>)</dfn>
method must run the following steps:

<ol>
 <li><p class=issue>...
</ol>


<h2>Events</h2>

<h3>Resizing viewports</h3>

When asked to <dfn>run the resize steps</dfn> for a {{Document}} <var>doc</var>, run these steps:

<ol>

 <li>If <var>doc</var>'s <a>viewport</a> has had its width or height changed
 (e.g. as a result of the user resizing the browser window,
 or changing the <span>page zoom</span> scale factor,
 or an <code>iframe</code> element's dimensions are changed)
 since the last time these steps were run,
 <span data-anolis-spec=dom title=concept-event-fire>fire an event</span> named <code>resize</code>
 at the <code data-anolis-spec=html>Window</code> object associated with <var>doc</var>.

</ol>


<h3>Scrolling</h3>

Each {{Document}} has an associated list of <dfn>pending scroll event targets</dfn>, initially empty.

Whenever a <a>viewport</a> gets scrolled (whether in response to user interaction or by an API), the user agent must run these steps:

<ol>

 <li>Let <var>doc</var> be the <a>viewport’s</a> associated {{Document}}.

 <li>If <var>doc</var> is already in <var>doc</var>'s <span>pending scroll event targets</span>, abort these steps.

 <li>Append <var>doc</var> to <var>doc</var>'s <span>pending scroll event targets</span>.

</ol>

Whenever an element gets scrolled (whether in response to user interaction or by an API), the user agent must run these steps:

<ol>

 <li>Let <var>doc</var> be the element's <span data-anolis-spec=dom title="concept-node-document">node document</span>.

 <li>If the element is already in <var>doc</var>'s <span>pending scroll event targets</span>, abort these steps.

 <li>Append the element to <var>doc</var>'s <span>pending scroll event targets</span>.

</ol>

When asked to <dfn>run the scroll steps</dfn> for a {{Document}} <var>doc</var>, run these steps:

<ol>

 <li>

  For each item <var>target</var> in <var>doc</var>'s <span>pending scroll event targets</span>,
  in the order they were added to the list, run these substeps:

  <ol>

   <li>If <var>target</var> is a {{Document}},
   <span data-anolis-spec=html title=concept-event-fire>fire an event</span> named <code>scroll</code> that bubbles at <var>target</var>.

   <li>Otherwise, <span data-anolis-spec=dom title=concept-event-fire>fire an event</span> named <code>scroll</code> at <var>target</var>.

  </ol>

 <li>Empty <var>doc</var>'s <span>pending scroll event targets</span>.

</ol>


<h2>CSS properties</h2>

<p class="issue">The features in this section should be moved to some other specification.

<h3>Smooth Scrolling: The 'scroll-behavior' Property</h3>

<pre class=propdef>
Name: <dfn>scroll-behavior</dfn>
Value: auto | smooth
Initial: auto
Applies to: <span title="scrolling box">scrolling boxes</span>
Inherited: no
Computed value:	specified value
Media: visual
Animatable: no
Canonical Order: per grammar
</pre>

The '<span>scroll-behavior</span>' property specifies the scrolling behavior for a <a>scrolling box</a>,
when scrolling happens due to navigation or CSSOM scrolling APIs.
Any other scrolls, e.g. those that are performed by the user, are not affected by this property.
When this property is specified on the root element, it applies to the <a>viewport</a> instead.

<p class=note>The '<span>scroll-behavior</span>' property of the HTML <code>body</code> element is <em>not</em> propagated to the viewport.

<dl>
 <dt>'<dfn title=scroll-behavior-auto>auto</dfn>'
 <dd>The <a>scrolling box</a> is scrolled in an instant fashion.

 <dt>'<dfn title=scroll-behavior-smooth>smooth</dfn>'
 <dd>The <a>scrolling box</a> is scrolled in a smooth fashion using a user-agent-defined timing function over a user-agent-defined period of time. User
 agents should follow platform convensions, if any. <!--fingerprint-->
</dl>

User agents may ignore this property. <!--fingerprint-->

<h2 class=no-num>References</h2>
<div id=anolis-references></div>

<h2 class="no-num">Change History</h2>

This section documents some of the changes between publications of this specification. This section is not exhaustive. Bug fixes and editorial changes are
generally not listed.

<h3 class=no-num>Changes From 4 August 2011 To 17 December 2013</h3>

<ul>
 <li>The specification now handles right-to-left and vertical writing modes.

 <li>The specification is now aware of <span>page zoom</span> and <span>pinch zoom</span>.

 <li>The '<span>scroll-behavior</span>' CSS property is introduced and scrolling APIs are extended with a mechanism to control smooth scrolling.

 <li>The <code title=dom-Window-moveTo>moveTo()</code>, <code title=dom-Window-moveBy>moveBy()</code>, <code title=dom-Window-resizeTo>resizeTo()</code> and
 <code title=dom-Window-resizeBy>resizeBy()</code> methods are now defined.

 <li><code title=dom-Window-innerWidth>innerWidth</code> et al now use the WebIDL type <code>double</code> instead of <code>long</code>.

 <li><code title=dom-Window-devicePixelRatio>devicePixelRatio</code> is now defined.

 <li>The <code>features</code> argument to <code data-anolis-spec=html title=dom-open>window.open()</code> is now defined.

 <li>The <code title=dom-Screen-colorDepth>colorDepth</code> and <code title=dom-Screen-pixelDepth>pixelDepth</code> attributes of <code>Screen</code> now
 always return 24.

 <li>The <code title=dom-Document-elementsFromPoint>elementsFromPoint()</code> method of <code data-anolis-spec=dom>Element</code> is introduced.

 <li>The specification is now aware of <span>transforms</span>.

 <li>Some geometry utility APIs are introduced but are not yet specified.

 <li><code>ClientRect</code> has been renamed to <code>DOMRect</code> and has moved to the Geometry specification.
 <span data-anolis-ref class=informative>GEOMETRY</span>

 <li>The specification now defines when the <code>resize</code> and <code>scroll</code> events fire.
</ul>

<h2 class="no-num">Acknowledgments</h2>

The editors would like to thank

Alan Stearns,
Alexey Feldgendler,
Antonio Gomes,
Bj&ouml;rn H&ouml;hrmann,
Dan Bates,
David Vest,
Elliott Sprehn,
Garrett Smith,
Henrik Andersson,
Hallvord R. M. Steen,
Kang-Hao Lu,
Leif Arne Storset,
Luiz Agostini,
Maciej Stachowiak,
Michael Dyck,
Mike Wilson,
Morten Stenshorne,
Olli Pettay,
Pavel Curtis,
Peter-Paul Koch,
Rachel Kmetz,
Robert O'Callahan,
Sam Weinig,
Scott Johnson,
Sebastian Zartner,
Stewart Brodie,
Sylvain Galineau,
Tab Atkins,
Tarquin Wilton-Jones,
Thomas Moore, and
Xiaomei Ji

for their contributions to this document.

Special thanks to the Microsoft employees who first implemented many of
the features specified in this draft, which were first widely deployed by
the Windows Internet Explorer browser.
 </body>
</html>
