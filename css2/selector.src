<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html lang="en">
<!-- $Id: selector.src,v 1.28 1997-10-30 18:57:10 bbos Exp $ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Selectors</title>
<link rel="next" href="cascade.html">
<link rel="previous" href="syndata.html">
<link href="style/default.css" rel="STYLESHEET" type="text/css">
</head>
<body>
<h1 align="center">Selectors</h1>

<p>In CSS, pattern matching rules determine which style rules apply to
elements in a document. These patterns, called <span class="index-def"
title="selectors"><em>selectors,</em></span> may range from simple
element names to rich contextual patterns.</p>

<h2><a name="type-selectors">Type selectors</a></h2>

<p>The simplest selector is the name of an element from the document
language, called a <span class="index-def" title="type
selector"><em>type selector.</em></span> Type selectors match all
instances of the element in the document. Element names are
case-insensitive if the document is in HTML, and case-sensitive if it
is in XML.</P>

<!-- [Keep this in sync with XML spec. BB]-->

<div class="example">
For example, the following rule matches all H1 elements in a document:

<pre>
  H1 { font-family: Helvetica }
</pre>
</div>

<h2><a name="grouping">Grouping</a></h2>

<p>When element selectors share the same declarations, they may be
grouped into comma-separated lists.</p>

<div class="example">
In this example, we condense three rules with identical declarations
into one. Thus,

<pre>
  H1 { font-family: Helvetica }
  H2 { font-family: Helvetica }
  H3 { font-family: Helvetica }
</pre>

<p>is equivalent to:</p>

<pre>
  H1, H2, H3 { font-family: Helvetica }
</pre>
</div>

<p> Furthermore, multiple declarations for the same selector may be
organized into semi-colon separated groups.</p>

<div class="example"><p>
Thus, the following rules:</p>  
<pre>
  H1 { font-weight: bold }
  H1 { font-size: 12pt }
  H1 { line-height: 14pt }
  H1 { font-family: Helvetica }
  H1 { font-variant: normal }
  H1 { font-style: normal }
</pre>

<p>are equivalent to:</p>

<pre>
  H1 { 
    font-weight: bold; 
    font-size: 12pt;
    line-height: 14pt; 
    font-family: Helvetica; 
    font-variant: normal;
    font-style: normal;
  }
</pre>
</div>

<p>In addition, some properties are <span class="index-def"
title="shorthand"><em>shorthand</em></span> rules that allow authors
to specify the values of several properties with a single property.
For instance, the <span class="propinst-font">'font'</span> property
is a shorthand property for setting <span
class="propinst-font-style">'font-style'</span>, <span
class="propinst-font-variant">'font-variant'</span>, <span
class="propinst-font-weight">'font-weight'</span>, <span
class="propinst-font-size">'font-size'</span>, <span
class="propinst-line-height">'line-height'</span>, and <span
class="propinst-font-family">'font-family'</span> all at once.</p>

<div class="example"><p>
The multiple style rules of the previous example:</p>

<pre>
  H1 { 
    font-weight: bold; 
    font-size: 12pt;
    line-height: 14pt; 
    font-family: Helvetica; 
    font-variant: normal;
    font-style: normal;
  }
</pre>

<p>may be rewritten with a single shorthand property:</p>

<pre>
  H1 { font: bold 12pt/14pt Helvetica }
</pre>

<p>Note that since <span
class="propinst-font-variant">'font-variant'</span> and <span
class="propinst-font-style">'font-style'</span> take their default
values of 'normal' in this example, these values have been omitted
from the shorthand form.</p>
</div>

<h2><a name="attribute-selectors">Attribute selectors</a></h2>

<p>CSS2 allows authors to specify rules that match according to
attributes defined in the document language. A rule may match based on
the simple presence of the attribute, or on one or more values for the
attribute.</P>

<h3>Matching attributes, single values, and multiple values</h3>

<p>An attribute selector can select on the simple presence or absence
of an attribute, on the attribute and its value, or on the attribute
and one word in its value. The syntax is <code>[att]</code>,
<code>[att=val]</code>, and <code>[att~=val]</code> respectively.</p>

<div class="example"><p>
For example, the following rule matches all H1 elements that
specify the "href" attribute, whatever its value:</p>

<pre>
   H1[href] { color: blue; }
</pre>
</div>

<div class="example"><p>
In the following example, the rule matches all SPAN elements whose
"class" attribute has the value "example":</p>

<pre>
   SPAN[class=example] { color: blue; }
</pre>
</div>

<p>The case-sensitivity of attribute values depends on the document
language. For example, in HTML, attribute values are case-insensitive,
but in XML they are case-sensitive.

<p>Attribute values must be quoted or escaped if they are not 
<a href="syndata.html#identifier">identifiers.</a>

<p>Document languages may allow multi-valued attributes, typically
space-separated lists such as the following:</p>

<pre class="example">
&lt;SPAN class="fish fresh-water edible"&gt;perch&lt;/SPAN&gt;
</pre>

<p>To accommodate value lists such as this, CSS2 defines the following
two types of equality:</p>

<dl>
<dt><strong>The "=" sign</strong></dt>
<dd>
<p>For the rule to apply, the value following "=" must match the
whole attribute value.</p>
</dd>

<dt><strong>The "~=" sign</strong></dt>
<dd>
<p>For the rule to apply, the string following "~=" must match at
least one member of the space-separated list of attribute values.
With the "~=" operator, attribute values cannot contain spaces.</p>

</dl>

<div class="example"><p>
The following rules illustrate the differences between "=" and "~=":</p>
<pre>
   A[rel~="copyright"] {...} /* matches, e.g., &lt;A rel="copyright copyleft ..." */
   td[colspan="2"] {...}   /* matches only &lt;TD colspan="2"&gt; ... */
</pre>
</div>

<div class="example"><P>
The following rule hides all elements
for which the value of the "lang" attribute
is "fr" (i.e., the language is French).

<PRE>
[LANG=fr] { display : none }
</PRE>
</div>

<h3>The class attribute in HTML</h3> 

<p>Although authors may refer to any attributes with the generic
syntax "[attribute=value]", CSS2 defines a special syntax for two 
<a href="./refs.html#ref-HTML40" rel="biblioentry">[HTML40]</a>
attributes: "class" and "id".</p>

<p>The HTML "class" attribute allows authors to group elements
together and specify style information for the entire group. The CSS2
shortcut syntax for "class" is a "." followed by the
class value, with no intervening white space.</p>

<div class="example"><p>
For example, we can assign style information to all elements with
<samp>class="pastoral"</samp>:</p>

<pre>
  .pastoral { color: green }  /* all elements with class=pastoral */
</pre>

<p>or just to H1 elements with <samp>class="pastoral"</samp>:</p>

<pre>
  H1.pastoral { color: green }  /* H1 elements with class=pastoral */
</pre>

<p>Given these rules, the first H1 instance below would not have green
text, while the second would:</p>

<pre>
  &lt;H1&gt;Not green&lt;/H1&gt;
  &lt;H1 class="pastoral"&gt;Very green&lt;/H1&gt;
</pre>

<p>Note that "H1.pastoral" is equivalent to "H1[class=pastoral]".</p>
</div>

<!--<p>The normal inheritance rules apply to classed elements; they
inherit values from their parent in the document structure.</p>-->

<p>To match a subset of "class" values, each value must be preceded
by a ".", in any order.</P>

<div class="example"><P>
For example, the following rule matches any P element whose "class" attribute
has been assigned a list of space-separated values that includes "pastoral"
and "marine":</p>

<pre> 
   P.pastoral.marine { color: green }
</pre>

<p>This rule matches when <samp>class="pastoral blue aqua
marine"</samp> but does not match for <samp>class="pastoral
blue"</samp>.</p>

<p>Similarly, the following aural style sheet rules allow a script
to be read aloud in different voices for each role:</p>

<pre>
   P.role.romeo  { voice-family: romeo, male }
   P.role.juliet { voice-family: juliet, female }
</pre>
</div>

<div class="note"><p>
<em><strong>Note.</strong>
CSS gives so much power to the "class" attribute, that in many cases
it doesn't matter what HTML element the class is set on -- you
can make any element emulate almost any other. Relying on this power
is not recommended, since it removes the level of structure that has a
universal meaning (HTML elements).  A structure based on "class" is only
useful within a restricted domain, where the meaning of a class has
been mutually agreed upon.
</em></p>
</div>

<h3>The class attribute in other document languages: @class</h3> 

<p>CSS2 allows authors to use the class selector syntax (a "."
followed by a class value) for languages other than HTML. For
other languages, however, authors must specify which attribute will be
acting as the "class" attribute.  This is done with the <span
class="index-def" title="@class">@class</span> rule, which has the
form "@class &lt;attribute-name&gt;;".</p>

<div class="example"><p>
For instance, to specify that the "type" attribute of XML has the role
of assigning class information, authors should include the following
declaration in their style sheets:</p>

<pre>
   @class type;
</pre>

<p>Then, a rule for XML such as:</p>

<pre>
   PARA.romeo { ... }
</pre>

<p>would be equivalent to:</p>

<pre>
   PARA[type~=romeo] { ... }
</pre>
</div>

<p>@class declarations must obey the following rules:</p>

<ul>
<li>
<p>An @class declaration must appear before the first selector in the
current style resource.</p>
</li>
<li>
<p>If it occurs more than once, only the last instance applies.</p>
</li>
<li>
<p>If it occurs, it only applies to the current style resource and not to any
imported style sheets.</p>
</li>
</ul>

<p>A style resource is either

<ol>
<li>a style sheet corresponding to a URL (excluding
any style sheets imported recursively),
<li>or, if the style sheet is embedded in HTML, it is the whole HTML
file.
</ol> 

<h3>The id attribute</h3>

<p>The "id" attribute allows authors to assign a unique name to an
element. CSS2 allows authors to specify style rules that apply to a
single instance of an element, based on its "id" value.</p>

<p>To match an element with a given "id" value, the selector must contain
"#" followed by the "id" value.</p>

<div class="example"><p> 
In the following example, the style rule
contains no selector information and therefore matches any element
that has <samp>id="z98y"</samp>. The rule will thus match for the P element:</p>

<pre>
  &lt;HEAD&gt;
  &lt;STYLE&gt;
  #z98y { letter-spacing: 0.3em }
  &lt;/STYLE&gt;
  &lt;/HEAD&gt;
  &lt;BODY&gt;
  &lt;P id=z98y&gt;Wide text&lt;/P&gt;
  &lt;/BODY&gt;
</pre>

<p>In the next example, however, the style rule will only match an H1
element that has <samp>id="z98y"</samp>. The rule will not match 
the P element in this example:</p>

<pre>
  &lt;HEAD&gt;
  &lt;STYLE&gt;
  H1#z98y { letter-spacing: 0.5em }
  &lt;/STYLE&gt;
  &lt;/HEAD&gt;
  &lt;BODY&gt;
  &lt;P id=z98y&gt;Wide text&lt;/P&gt;
  &lt;/BODY&gt;
</pre>
</div>

<div class="note"><p>
<em><strong>Note.</strong>
While style sheets have been designed to augment document
structure, this feature will allow authors to create documents that
may render well, but don't take advantage of the structural
elements of HTML. This use of style sheets is discouraged.
</em></p>
</div>

<p>Note that in HTML 4.0, the ID attribute is called "ID", but in XML
documents it may be called something else. The name of the ID
attribute is immaterial for CSS. Also note that, even in HTML, the
selector <samp>#p123</samp> is <em>not</em> equivalent to
<samp>[ID=p123]</samp>, since the former has a higher <a
href="cascade">specificity</a>.

<!-- Should this be "latter has a higher specificity?" -IJ -->
<!-- no, it's correct as is - BB -->

<h2><a name="contextual-selectors">Contextual selectors</a></h2>

<p>At times, authors may want selectors to match elements that appear
in a certain context, such as "only those EM elements that are 
contained by an H1 element".  In these cases, <span class="index-def"
title="contextual selectors"><em>contextual selectors</em></span> add
specificity. Context is defined as an ancestor/descendent relationship
between elements in the document tree. Sibling relationships (one
element after another) are discussed in the section on <a
href="#sequential-selectors">sequential selectors</a>.</p>

<p>A contextual selector matches when an element is an arbitrary
descendent of some ancestor element (i.e., it may be any generation
below the ancestor element). A contextual selector is made up of two or
more selectors separated by white
space.

<div class="example"><p>
For example, consider the following rules:</p>

<pre>
  H1 { color: red }
  EM { color: red }
</pre>

<p>Although the intention of these rules is to add emphasis to text by
changing its color, the effect will be lost in a case such as:</p>

<pre>
&lt;H1&gt;This headline is &lt;EM&gt;very&lt;/EM&gt; important&lt;/H1&gt;
</pre>

<p>We address this case by adding a contextual rule to the previous
two that sets the text color to blue whenever an EM occurs anywhere
within an H1:</p>

<pre>
  H1 { color: red }
  EM { color: red }
  H1 EM { color: blue }
</pre>

<p>The third rule will also match the following fragment:</p>

<pre>
  &lt;H1&gt;This 
     &lt;SPAN class="myclass"&gt;headline is &lt;EM&gt;very&lt;/EM&gt;
     important&lt;/SPAN&gt;&lt;/H1&gt;
</pre>
</div>

<P>A contextual selector may also contain <a
href="#attribute-selectors">attribute selectors</a>.

<div class="example"><p>
For example, the following matches any element with an "href" attribute
inside a P with class "myclass" inside any DIV. Note that the space
after "myclass" is essential: without it the selector would match a P
with both a class and an "href":

<pre>
DIV P.myclass [href]
</pre>
</div>

<p>Contextual
selectors may be grouped according to the <a href="grouping">rules for
grouping</a> listed above.</p>

<h2><a name="parent-child-selectors">Parent-child selectors</a></h2>

<p>A <span class="index-def" title="parent-child selector">
<em>parent-child selector</em></span> matches when an element is the
direct descendent of some parent element. A parent-child selector is
made up of two or more selectors
separated by a tilde (~). 

<div class="example"><p>
The following rule sets the style of a P in a BODY, but not a P inside
something else:</p>

<pre>
  BODY ~ P { line-height: 1.3 }
</pre>

</div>

<p>A parent-child selector may also contain <a
href="#attribute-selectors">attribute selectors</a>. Parent-child
selectors may be grouped according to the <a href="grouping">rules for
grouping</a> listed above.</p>

<p>Contextual selectors and parent-child selectors can be combined.
For instance, <code>DIV OL~LI P</code> groups as follows (DIV (OL ~
(LI P))), i.e., it matches a P that is a descendant of an LI, that is
in turn a child of an OL, which is a descendant of a DIV.

<h2><a name="sequential-selectors">Sequential selectors</a></h2>

<p>Often, special formatting rules apply when two types of elements
appear next to each other in a document. For example, when block-level
elements are laid out, the vertical space between them collapses. In
this case, the special formatting is handled by the rules for <a
href="./flowobj2.html#collapsing-margins">collapsing margins</a>, but
in other cases of sequential selectors, authors may want to specify
their own special formatting rules.</p>

<p>Sequential selectors have the following syntax: a forward slash
("/") precedes the first selector and immediately
the second selector. The sequential selector matches if the element
matched by the first selector <!--immediately--> precedes the element matched
by the second selector, and both have the same parent.</p>

<p>If, in addition, there is a tilde (~) between the selectors, then
the sequential selector matches if the element matched by the first
selector <em>immediately</em> precedes the element matched by the
second selector, i.e., without any intervening elements.

<div class="example"><p>
Thus, the following rule states that when a P element immediately follows a MATH
element, it should not be indented:</p>

<pre>
  /MATH ~ P/ { text-indent: 0 } 
</pre>

<p>The next example brings an H2 that follows an H1 closer to it:</p>

<pre>
  /H1~H2/ { margin-top: -5mm }   
</pre>
</div>

<p>Sequential selectors may be used along with other types of
selectors.

<div class="example"><p>
Thus, for example, the following rule is similar to the one in the
previous example, except that the special formatting only occurs when
H1 has <samp>class="opener"</samp> (see the section on <a
href="#attribute-selectors">attribute selectors</a>):</p>

<pre>
  /H1.opener ~ H2/ { margin-top: -5mm }   
</pre>
</div>

<p>Sequential selectors can also be used to match the first child of
some element. In this case the first selector is omitted, and the
first slash is doubled, e.g., <samp>//P/</samp>.

<p>Some descriptions of SGML and XML refer to text data as a "PCDATA
element" or a "character-data pseudo-element". For CSS, text is never
counted as an element. E.g., the EM in <samp>&lt;P>abc
&lt;EM>def&lt;/EM></samp> is the first child of the P.

<div class="example">
<p>The following rule sets the font weight to "bold" for any EM
element that is the descendent of a paragraph that is the
<em>first</em> child in some element. Note that in this rule, the
sequential selector "//P/" is the parent of "EM":</p>

<pre>
  //P/ EM { font-weight : bold }
</pre>

<p>Similarly, the following rule suppresses indentation for the first
paragraph (P) of a DIV:</p>

<pre>
  DIV ~ //P/ { text-indent: 0 }
</pre>

<P>This example would match the P inside the DIV of the
following fragment:</p>

<pre>
  &lt;P&gt; The last P before the note.
  &lt;DIV class="note"&gt;
  &lt;P&gt; The first P inside the note.
  &lt;/DIV&gt;
</pre>

<p>but would <em>not</em> match the second P in the following
fragment:</p>

<pre>
  &lt;P&gt; The last P before the note.
  &lt;DIV class="note"&gt;
  &lt;H2&gt;Note&lt;/H2&gt;
  &lt;P&gt; The first P inside the note.
  &lt;/DIV&gt;
</pre>
</div>

<p>[Do we need the functionality of <samp>/H1 P/</samp>, or only that
of <samp>/H1~P/</samp> and <samp>//P/</samp>? Also, should
<samp>/P//</samp> and <samp>//P//</samp> be added?]

<p>Sequential selectors can be combined with other kinds of selectors:
type selectors and attribute selectors can occur inside the slashes,
and sequential selectors themselves can be part of contextual or
parent-child selectors.

<h2><a name="pseudo-elements">Pseudo-elements</a> and <a
name="pseudo-classes">pseudo-classes</a></h2>

<p>In CSS2, style is normally attached to an element based on its
position in the <a href="process.html#doctree">document tree</a>. This
simple model is sufficient for many cases, but some common publishing
scenarios (such as changing the font size of the first letter of a
paragraph) may be independent of the document tree. For instance, in
<a href="./refs.html#ref-HTML40" rel="biblioentry">[HTML40]</a>, no
element refers to the first line of a paragraph, and therefore no
simple CSS selector may refer to it.</p>

<p>CSS introduces the concepts of <span class="index-def"
title="pseudo-elements"><em>pseudo-elements</em></span> and <span
class="index-def"
title="pseudo-classes"><em>pseudo-classes</em></span> to extend the
addressing model and permit formatting based on information that lies
outside the document tree. </p>

<ul>
<li>Pseudo-elements refer to sub-parts of an
element's content (e.g., the first letter or first line of a
paragraph, etc.).
<li>Pseudo-classes refer to elements that are grouped
dynamically (e.g., all links that have been visited, all left-hand
pages, etc.) 
</ul>

<P>Pseudo-classes are allowed anywhere in selectors while
pseudo-elements may only appear as the last segment of a selector.
</p>

<p>Although pseudo-elements and pseudo-classes do not exist in the
document tree, their behavior is defined as if they did. Each
pseudo-element and pseudo-class may be modeled by a <span
class="index-def" title="fictional tag sequence"><em>fictional tag
sequence,</em></span> a fragment of document source that includes
imaginary elements from the document language.</p>

<p>Pseudo-elements and pseudo-class names are case-insensitive.</p>

<div class="note"><p>
<em><strong>Note.</strong>
In CSS2, only one pseudo-element can be specified per
selector. This may change in future versions of CSS.
</em></p>
</div>

<!--
<P> Some common typographical effects are associated not with
structural elements but rather with typographical items as rendered. 
In CSS2, two such typographical items can be addressed
through <span class="index-inst"
title="pseudo-elements">pseudo-elements</span>: the first line of an
element, and the first letter.
-->

<p>Conforming UAs may ignore all rules with :first-line or
:first-letter in the selector, or, alternatively, may only support a
subset of the properties on these pseudo-elements. See the section on
<a href="convent.html#conformance">conformance</a> for further
information.</p>

<h3>The <span class="index-def" title="pseudo-elements,
:first-line|:first-line">:first-line</span> pseudo-element</h3>

<p>The :first-line pseudo-element is used to apply special styles to
the first formatted line. For instance:</p>

<pre class="example">
  P:first-line { font-style: small-caps }
</pre>

<p>The above rule means "change the font style of the first line of
every paragraph to small-caps". However, the selector "P:first-line"
does not match any real HTML element. It does match a pseudo-element
that conforming user agents will insert at the beginning of every
paragraph.</p>

<p>Note that the length of the first line depends on a number of
factors, including the width of the page, the font size, etc. Suppose
for this example that the paragraph is broken into the lines indicated
in the example. Thus, an ordinary HTML paragraph such as:</p>

<pre>
  &lt;P&gt;This is a somewhat long HTML paragraph that will
  be broken into several lines. The first line will be
  identified by a fictional tag sequence. The other lines will 
  be treated as ordinary lines in the paragraph.&lt;/P&gt;
</pre>

<p>will be "rewritten" by user agents to include the fictional tag
sequence for :first-line.</p> 

<pre>
  &lt;P&gt;
  &lt;P:first-line&gt;This is a somewhat long HTML paragraph that will&lt;/P:first-line&gt;
  be broken into several lines. The first line will be
  identified by a fictional tag sequence. The other lines will 
  be treated as ordinary lines in the paragraph.&lt;/P&gt;
</pre>

<p>If a pseudo-element breaks up a real element, the necessary extra
tags must be regenerated in the fictional tag sequence. Thus, if we
mark up the previous paragraph with a SPAN element:</p>

<pre>
  &lt;P&gt;&lt;SPAN class="test"&gt;This is a somewhat long HTML paragraph that will
  be broken into several lines.&lt;/SPAN&gt; The first line will be
  identified by a fictional tag sequence. The other lines will 
  be treated as ordinary lines in the paragraph.&lt;/P&gt;
</pre>

<p>The user agent must generate the appropriate start and end tags for
SPAN when inserting the fictional tag sequence for :first-line.</p>

<pre>
  &lt;P&gt;&lt;P:first-line&gt;&lt;SPAN class="test"&gt;This is a somewhat long HTML paragraph that will&lt;/SPAN&gt;&lt;/P:first-line&gt;
  &lt;SPAN&gt;be broken into several lines.&lt;/SPAN&gt; The first line will be
  identified by a fictional tag sequence. The other lines will 
  be treated as ordinary lines in the paragraph.&lt;/P&gt;
</pre>

<p> The <span class="index-inst" title="pseudo-elements,
:first-line">:first-line</span> pseudo-element can only be attached to
a block-level element.</p>

<p>The :first-line pseudo-element is similar to an inline element, but
with certain restrictions. Only the following properties apply to a
:first-line element: <a href="fonts.html#font-properties">font
properties</a>, <a href="colors.html#color-properties">color
properties</a>, <a href="colors.html#background-properties">background
properties</a>, <span
class="propinst-word-spacing">'word-spacing'</span>, <span
class="propinst-letter-spacing">'letter-spacing'</span>, <span
class="propinst-text-decoration">'text-decoration'</span>, <span
class="propinst-vertical-align">'vertical-align'</span>, <span
class="propinst-text-transform">'text-transform'</span>, <span
class="propinst-line-height">'line-height'</span>, and <span
class="propinst-clear">'clear'</span>,</p>

<h3>The <span class="index-def" title="pseudo-elements,
:first-letter|:first-letter">:first-letter</span> pseudo-element</h3>

<p>[Define better alignment of drop caps?  BB]</p>

<p>The :first-letter pseudo-element may be used for <span
class="index-inst" title="initial caps">"initial caps"</span> and
<span class="index-inst" title="drop caps">"drop caps"</span>, which
are common typographical effects. It is similar to an inline element
if its <span class="propinst-float">'float'</span> property is 'none',
otherwise it is similar to a floating element.</p>

<p>These are the properties that apply to :first-letter
pseudo-elements: <a href="fonts.html#font-properties">font
properties</a>, <a href="colors.html#color-properties">color
properties</a>, <a href="colors.html#background-properties">background
properties</a>, <span
class="propinst-text-decoration">'text-decoration'</span>, <span
class="propinst-vertical-align">'vertical-align'</span> (only if
'float' is 'none'), <span
class="propinst-text-transform">'text-transform'</span>, <span
class="propinst-line-height">'line-height'</span>, <a
href="box.html#margin-properties">margin properties</a>, <a
href="box.html#padding-properties">padding properties</a>, <a
href="box.html#border-properties">border properties</a>, <span
class="propinst-float">'float'</span>, and <span
class="propinst-clear">'clear'</span>.</p>

<div class="example"><p></p>
<p>The following CSS2 will make a dropcap initial letter span two lines:</p>

<pre>
&lt;HTML&gt;
 &lt;HEAD&gt;
  &lt;TITLE&gt;Title&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
   P              { font-size: 12pt; line-height: 12pt }
   P:first-letter { font-size: 200%; font-style: italic; font-weight: bold; float: left }
   SPAN           { text-transform: uppercase }
  &lt;/STYLE&gt;
 &lt;/HEAD&gt;
 &lt;BODY&gt;
  &lt;P&gt;&lt;SPAN&gt;The first&lt;/SPAN&gt; few words of an article in The Economist.&lt;/P&gt;
 &lt;/BODY&gt;
&lt;/HTML&gt;
</pre>

<p>This example might be formatted as follows:</p>

<img src="./images/first-letter.gif" alt="Image illustrating the combined effect of the :first-letter and :first-line pseudo-elements">

<p>The <span class="index-inst" title="fictional tag
sequence">fictional tag sequence</span> is:</p>

<pre>
  &lt;P&gt;
  &lt;SPAN&gt;
  &lt;P:first-letter&gt;
  T
  &lt;/P:first-letter&gt;he first
  &lt;/SPAN&gt; 
  few words of an article in the Economist.
  &lt;/P&gt;
</pre>

<p>Note that the :first-letter pseudo-element tags abut the content
(i.e., the initial character), while the :first-line pseudo-element
start tag is inserted right after the start tag of the element to
which it is attached.</p>
</div>

<p>The UA defines what characters are inside the :first-letter
element. Quotes that precede the first letter should be included, as
in:</p>

<img src="./images/first-letter2.gif" alt="Quotes that precede the
first letter should be included.">

<p> When the paragraph starts with other punctuation (e.g.,
parenthesis and ellipsis points) or other characters that are normally
not considered letters (e.g., digits and mathematical symbols),
:first-letter pseudo-elements are usually ignored.</p>

<p>The :first-letter pseudo-element can only be attached to a
block-level element.</p>

<div class="note"><p>
<em><strong>Note.</strong>
Some languages may have specific rules about how to treat certain
letter combinations. In Dutch, for example, if the letter combination
"ij" appears at the beginning of a word, they should both be
considered within the :first-letter pseudo-element.
</em></p>
</div>

<h3>Overlapping pseudo-elements</h3>

<p>Several pseudo-element rules may have an impact on the same
content.</p>

<div class="example"><p>
In the following example, the first letter of each P element will be
green with a font size of 24pt. The rest of the first formatted line
will be blue while the rest of the paragraph will be red.</p>

<pre>
  P { color: red; font-size: 12pt }
  P:first-letter { color: green; font-size: 200% }
  P:first-line { color: blue }

  &lt;P&gt;Some text that ends up on two lines&lt;/P&gt;
</pre>

<p>Assuming that a line break will occur before the word "ends", the
<span class="index-inst" title="fictional tag sequence">fictional tag
sequence</span> for this fragment is:</p>

<pre>
  &lt;P&gt;
  &lt;P:first-line&gt;
  &lt;P:first-letter&gt; 
  S 
  &lt;/P:first-letter&gt;ome text that 
  &lt;/P:first-line&gt; 
  ends up on two lines 
  &lt;/P&gt;
</pre>

<p>Note that the :first-letter element is inside the :first-line
element.  Properties set on :first-line will be inherited by
:first-letter, but are overridden if the same property is set on
:first-letter.</p>
</div>

<h3>Pseudo-elements with contextual selectors</h3>

<p>In a contextual selector, pseudo-elements are only allowed at the
end of the selector.</p>

<div class="example"><p>
The following example illustrates this with the
<span class="index-inst" title=":first-letter">:first-letter</span>
pseudo-element.</p>

<pre>
  BODY P:first-letter { color: purple }
</pre>
</div>

<p>Pseudo-classes may also be used in contextual selectors.</p> 

<div class="example"><p>
The following example sets the border color to blue of all images that
descend from A elements that have not yet been visited:</p>
<pre>
  A:link IMG { border: solid blue }
</pre>
</div>

<h3>Anchor pseudo-classes:
<span class="index-def" title="pseudo-classes, :link|:link">:link</span>, 
<span class="index-def" title="pseudo-classes, :hover|:hover">:hover</span>,
<span class="index-def" title="pseudo-classes, :active|:active">:active</span>,, and 
<span class="index-def" title="pseudo-classes,
:visited|:visited">:visited</span>
</h3>

<p>User agents commonly display unvisited links differently from
previously visited ones. CSS2 allows authors to specify the rendering
of a link in one of several states:

<ul>
<li> The :link pseudo-class applies for links that have
not yet been visited.
<li> The :hover pseudo-class applies when the user designates,
but does not activate, a link. User agents may require a minimal
time delay before considering that a user has designated a link.
<li> The :active pseudo-class applies while the link is being
activated by the user.
<li> The :visited pseudo-class applies once the link has been
visited by the user. <strong>Note.</strong>
After a certain amount of time, user agents may choose to 
return a visited link to the (unvisited) 'link' state.
</ul>

<P>The four states are mutually exclusive.

<pre>
  A:link { color: red }       /* unvisited links */
  A:hover { color: yellow }   /* user hovers     */
  A:active { color: lime }    /* active links    */
  A:visited { color: blue }   /* visited links   */
</pre>

<p>User agents are not required to reformat a currently displayed
document due to anchor pseudo-class transitions. For instance, a style
sheet may legally specify that the <span
class="propinst-font-size">'font-size'</span> of an :active link
should be larger that a :visited link, but the UA is not required to
dynamically reformat the document when the reader selects the
:visited link.</p>

<div class="example"><p>
In HTML, the following two CSS2 declarations are equivalent and
select the same elements:</p>

<pre>
  A:link { color: red }
  :link { color: red }
</pre>
</div>


<div class="example"><P> 
The following example illustrates how authors specify a "tooltip" (a
brief message that is rendered temporarily) that will only appear when
the user hovers over a specific link. A link to the table of contents
has a "normal" rendering (the content of the HTML anchor element A)
and a tooltip that is rendered when the user hovers over the
link. Visual user agents render a 30em-wide tooltip up and to the left of the
A element's content. Here is the source HTML:

<PRE>
&lt;A href="tableofcontents.html"&gt;
  &lt;SPAN class="relative-position"&gt;
     &lt;SPAN class="tooltip"&gt;
     Return to the table of contents.
     &lt;/SPAN&gt;
  &lt;/SPAN&gt;
  [Table of Contents]
&lt;/A&gt;
</PRE>

<P>Here is the style sheet:

<PRE>
SPAN.tooltip {
  display: none
}
SPAN.relative-position {
  position: relative
}
A:hover SPAN.tooltip {
  position: absolute;
  top: -20px; left: 20px;
  width: 30em
}
</PRE>
</div>

<h3>Pseudo-elements and pseudo-classes with attribute selectors</h3>

<p>Pseudo-classes can be combined with normal classes. In this case,
the class name must precede the pseudo-class name in the selector.</p>

<div class="example"><p>
If the following link:

<pre>
  &lt;A class="external" href="http://out.side/"&gt;external link&lt;/A&gt;
</pre>

<P>has been visited, this rule:

<pre>
  A.external:visited { color: blue }
</pre>

<P>will cause it to be blue.
</div>

<p>Pseudo-elements can also be combined with attribute selectors.

<div class="example"><P>
Thus, the following rule:

<pre>
  P.initial:first-letter { color: red }
</pre>

<P>would make the first letter of all P
elements with "class=initial" such as the following, the color red:</p>

<pre>
  &lt;P class="initial"&gt;First paragraph&lt;/A&gt;
</pre>
</div>

<p>Pseudo-elements must be specified at the end of the selector.</p>

<h3>Colliding attribute selectors and pseudo-classes</h3>

<p>CSS syntax allows the following rules to co-exist:</p>

<pre>
  A:link { color: red }      /* The :link pseudo-class */
  A.link { color: green }    /* In HTML, class=link */
  A#link { color: blue }     /* In HTML, id=link */
</pre>

<p>Since a link may have class="link", id="link", and belong to the
pseudo-class :link simultaneously (i.e., be unvisited), user agents
must resolve the colliding rules. User agents must do so according to
the <a href="./cascade.html#cascading-order">cascading order</a>
defined in the section on the cascade.</p>

</body>

</html>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-declaration:"~/SGML/html.decl"
sgml-default-doctype-name:"html"
sgml-minimize-attributes:t
sgml-nofill-elements:("pre" "style" "br")
sgml-live-element-indicator:t
End:
-->
