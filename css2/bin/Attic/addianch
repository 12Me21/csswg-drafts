#!/usr/local/bin/perl
# Add index anchors to source file _and_ generate index database
# Arnaud Le Hors - lehors@w3.org
# $Id: addianch,v 1.5 1997-08-01 17:03:03 ijacobs Exp $

if (($_ = $ARGV[0], /^-r/) && $ARGV[0]) {
    shift;
    $realpath = $ARGV[0];
    shift;
} else {
    $realpath = ();
}

$PROGNAME = substr($0, rindex($0, "/") + 1);

if ($#ARGV < 2) {
    print STDERR "Usage: $PROGNAME [ -r realpath ] src trgt indexdb\n";
    exit 1;
} else {
    $input = $ARGV[0];
    if ($realpath) {
	$file = $realpath;
    } else {
	$file = $input;
    }
    # change file extension
    $file =~ s/src$/html/;
    shift;
    $output = $ARGV[0];
    shift;
    $dbasef = $ARGV[0];
    shift;
}

# copy file in memory
sub readfile {
    $buf = "";
    if (!open(INPUT, $_[0])) {
	print STDERR "$PROGNAME Error: Cannot open file: $_[0]\n";
	exit 1;
    }
    while (<INPUT>) {
	$buf .= $_;
    }
    close(INPUT);
}

# store index and return an anchor.
# Since each index markup can define several 
# links to the same anchor, create a unique
# anchor the first time this function is
# called (per markup) and reuse it thereafter

sub storeindex {
    ($prefix, $index, $cmt, $anchor) = @_;
    if ($indexes{$index}) {
	if (!$anchor) {
	    $n = $#{$indexes{$index}} + 1;
	    $anchor = "$prefix-$index-$n";
	    # change possible spaces to underscores
	    $anchor =~ s/ /_/g;
	    # leave only alphanumeric characters 
	    $anchor =~ s/[^a-zA-Z0-9_-]//g;
	}
	push(@{$indexes{$index}}, "$file#$anchor|$cmt");
    } else {
	if (!$anchor) {
	    $anchor = "$prefix-$index";
	    # change possible spaces to underscores
	    $anchor =~ s/ /_/g;
	    # leave only alphanumeric characters 
	    $anchor =~ s/[^a-zA-Z0-9_-]//g;
	}
	@{$indexes{$index}} = ("$file#$anchor|$cmt");
    }

    return $anchor;
}

$wd = "[^ \t\n>]+";		# word
$qwd = "\"([^\"]*)\"";		# quoted word
$sep = "[ \t\n]+";		# word separator

sub addanchor {
    ($prefix, $st, $content, $et) = @_;

    # see if a title is specified
    $_ = $st;
    if (/${sep}title=(?:$qwd|($wd))/sgio) {
        $anchor = ();
        # only $1 or $2 will actually be non null
        foreach $idxentry (split(/[\n \t]*\|[\n \t]*/, "$1$2", 2)) {
	    ($index, $cmt) = split(/, */, "$idxentry", 2);
	    # New lines -> spaces in keys (title OR content)
	    # And compress extra space
	    $index =~ s/[\n \t]+/ /g;
	    $cmt =~ s/[\n \t]+/ /g;
	    #Remove initial white space
	    $index =~ s/^[\n \t]+//;
	    $cmt =~ s/^[\n \t]+//;
	    $anchor = storeindex($prefix, $index, $cmt, $anchor);
	}
    } else {
	$index = $content;
	$cmt = ();
	# New lines -> spaces in keys (title OR content)
	# And compress extra space
	$index =~ s/[\n \t]+/ /g;
	$cmt =~ s/[\n \t]+/ /g;
	#Remove initial white space
	$index =~ s/^[\n \t]+//;
	$cmt =~ s/^[\n \t]+//;
	$anchor = storeindex($prefix, $index, $cmt, ());
    }

    # HACK!!!
    # add a non breakable space in the anchor to workaround
    # broken browsers which don't support correctly empty anchors
    return "$st<a name=\"" . $anchor . "\">&nbsp;</a>$content$et";
# if the span tags are to be removed use the following two lines instead
#    return "<a name=\"" . $anchor . "\">&nbsp;</a>$content";
}

### main

# index patterns
$eindexp = "</span>";

readfile($input);
@indexes = ();
# add index anchors - definitions
$sindexp = "<span[ \t\n]+class=(?:index-def|\"index-def\").*?>";
$buf =~ s/($sindexp)(.*?)($eindexp)/addanchor("didx", $1, $2, $3)/sgieo;
# add index anchors - instances
$sindexp = "<span[ \t\n]+class=(?:index-inst|\"index-inst\").*?>";
$buf =~ s/($sindexp)(.*?)($eindexp)/addanchor("idx", $1, $2, $3)/sgieo;

# print out result
open(OUTPUT, "> $output");
print OUTPUT $buf;
close(OUTPUT);

# print out index database
# Don't separate fields with ";" because keys may contain markup
# With entities.

if (!open(DBASE, "> $dbasef")) {
    print STDERR "$PROGNAME Error: Cannot open dbfile: $dbasef\n";
} else {
    foreach $index (sort(keys %indexes)) {
	foreach $item (@{$indexes{$index}}) {
	    print DBASE "$index|$item\n";
	}
    }
    close(DBASE);
}
