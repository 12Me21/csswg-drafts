#!/usr/local/bin/perl
# Index maker:
#
# Build an index table of all the anchors that have a name of the form:
# "<prefix>-<name>". In addition when a database is given with the '-db' option,
# information related to elements searched by names is added to the table.
# Table headers can be specified through the '-th' option.
#
# Arnaud Le Hors - lehors@w3.org
# $Id: mkidx,v 1.12 1998-01-28 18:12:01 bbos Exp $

if (($_ = $ARGV[0], /^-r/) && $ARGV[0]) {
    shift;
    $realpath = $ARGV[0];
    shift;
} else {
    $realpath = ();
}

$PROGNAME = substr($0, rindex($0, "/") + 1);

if (!$ARGV[1]) {
    die "Usage: $PROGNAME indexfile idxdb1 idxdb2 ...\n";
}
$indexf = $ARGV[0];
shift;
if (!$realpath) {
    $realpath = $indexf;
}

# compute relative path from 1 to 2
sub rpath {
    @path1 = split("/", $_[0]);
    @path2 = split("/", $_[1]);

    pop(@path1);
    while ($path1[0] eq $path2[0]) {
        shift(@path1);
        shift(@path2);
    }

    $root = "";
    foreach $el (@path1) {
        $root .= "../";
    }
    $path = join("/", @path2);
    return "$root$path";
}

sub readdbfile {
    $dbasef = $_[0];
    if (!open(DBASE, $dbasef)) {
	print STDERR "$PROGNAME Error: Cannot open dbfile: $dbasef\n";
	return;
    }
    while (<DBASE>)  {
	chop;
	($index, $url, $cmt) = split(/\|/, $_, 3);
	# Remove entity markup first (e.g. $lt;)
	$index =~ s/^&[^;]+;//;
	# Sort on certain chars only.
	$index =~ s/^[^a-zA-Z0-9\@:]*//;
	# Case-insensitive
	$index = lc($index);
	# NB: must have a non-space characer
        # between index and cmt for proper sortin.
	$key = "$index     $cmt";
	if ($indexes{$key}) {
	    push(@{$indexes{$key}}, "$_");
	} else {
	    @{$indexes{$key}} = ("$_");
	}
    }
    close(DBASE);
}


### main
@indexes = ();
foreach $file (@ARGV) {
    readdbfile($file);
}

# print out index document
$buf = "";
@letters = ();
$curindex = ();
$curletter = ();
foreach $key (sort(keys %indexes)) {
    $lastcmt = ();
    $first = t;
    foreach $item (@{$indexes{$key}}) {
	$cmt = ();
	if ($first) {
	    $first = ();
	    $pre = "";
	} else {
	    $pre = ",\n";
	}
	($index, $url, $cmt) = split(/\|/, $item, 3);

	$rurl = rpath($realpath, $url);	# relative URL

	if ($curletter ne ($letter = lc(substr($key, 0, 1)))) {
	    if ($curletter) {
		$buf .= "</dl>\n";
	    }
	    $buf .= "\n<dl>";
	    $curletter = $letter;
	    $setanchor = t;
	    push(@letters, $letter);
	} else {
	    $setanchor = ();
	}
	if ($curindex ne $index) {
	    if ($setanchor) {
		$buf .= "\n  <dt><a name=\"$letter\">$index</a>";
	    } else {
		$buf .= "\n  <dt>$index";
	    }
	    $n = 1;
	    $curindex = $index;
	}
	if ($url =~ /\#didx-/i) {
	    $class="index-def";
	} else {
	    $class="index-inst";
	}
	if ($cmt ne "") {
	    # If there is an index subkey
	    if ($lastcmt ne $cmt) {
		# If the subkey is not the same
		# as the previous one, start
		# a new subkey list.
		$buf .= "\n    <dd>$cmt";
		$pre .= " <a href=\"$rurl\" class=\"$class\">";
		$content = "1";
		$post = "</a>";
		$n = 2;
		$lastcmt = $cmt;
	    } else {
		# Add number to current subkey list.
		$pre .= " <a href=\"$rurl\" class=\"$class\">";
		$content = $n;
		$post = "</a>";
		$n++;
	    }
	} else {
	    # Add number to current index line.
	    $pre .= " <a href=\"$rurl\" class=\"$class\">";
	    $content = $n;
	    $post = "</a>";
	    $n++;
	}
	if ($url =~ /\#didx-/) {
	    $content = "<em><strong>$content</strong></em>";
	}
	$buf .= "$pre$content$post";
    }
}
$buf .= "</dl>\n";

# Print out the full buffer
open(OUTPUT, "> $indexf");
print OUTPUT "<DIV class=\"noprint\"> ";
foreach $letter (@letters) {
    print OUTPUT " <a href=\"#$letter\">" . uc($letter) . "</a> ";
}
print OUTPUT "</DIV>";
print OUTPUT $buf;
close(OUTPUT);



