<!DOCTYPE html public '-//W3C//DTD HTML 4.01//EN' 'http://www.w3.org/TR/html4/strict.dtd'>
<html lang="en">
<head profile="http://www.w3.org/2006/03/hcard">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>CSS Transforms</title>
  <link rel="stylesheet" type="text/css" href="../default.css" />
  <link rel="stylesheet" type="text/css" href="http://www.w3.org/StyleSheets/TR/W3C-ED.css" />

  <style type="text/css">
      .term {
        font-style: italic;
      }
    
     .todo {
         font-weight: bold;
         border-left: 0.5em solid #f44;
         padding-left: 1em;
         margin-top: 0.5em;
         color: #a0a0a0;
     }

     .todo:before {
         content: "TO DO : ";
         color: #f44;
     }
  </style>

</head>
<body>
    <div id="div-head" class="head">
        <!--logo-->

        <h1>CSS Transforms</h1>

        <h2 class="no-num no-toc">[LONGSTATUS] [DATE]</h2>
        <dl>
          <dt>This version:
            <dd>
            <a href="[VERSION]">http://dev.w3.org/csswg/css3-transforms/</a>
            <!--http://www.w3.org/TR/[YEAR]/WD-[SHORTNAME]-[CDATE]-->
          <dt>Latest version:
            <dd><a
              href="http://www.w3.org/TR/css3-transforms">[LATEST]</a>
          <dt>Previous version:
            <dd>None
          <dt id="editors-list">Editors:
            <dd>Simon Fraser (<a href="http://www.apple.com/">Apple Inc</a>) &lt;simon.fraser &#64;apple.com&gt;
            <dd>Dean Jackson (<a href="http://www.apple.com/">Apple Inc</a>) &lt;dino &#64;apple.com&gt;
            <dd>David Hyatt (<a href="http://www.apple.com/">Apple Inc</a>) &lt;hyatt &#64;apple.com&gt;
            <dd>Chris Marrin (<a href="http://www.apple.com/">Apple Inc</a>) &lt;cmarrin &#64;apple.com&gt;
            <dd>Edward O'Connor (<a href="http://www.apple.com/">Apple Inc</a>) &lt;eoconnor &#64;apple.com&gt;
            <dd>Dirk Schulze (<a href="http://www.adobe.com/">Adobe Systems, Inc</a>) &lt;dschulze &#64;adobe.com&gt;
            <dd>Aryeh Gregor (<a href="http://www.mozilla.org/">Mozilla</a>) &lt;ayg &#64;aryeh.name&gt;

            <dt>Issues list:
              <dd><a href="https://www.w3.org/Bugs/Public/buglist.cgi?query_format=advanced&amp;product=CSS&amp;component=Transforms&amp;resolution=---&amp;cmdtype=doit">in Bugzilla</a>

            <dt>Test suite:
              <dd>none yet
          </dl>

        <!--copyright-->

        <hr title="Separator for header">
        </div>

        <h2 class="no-num no-toc" id="abstract">Abstract</h2>
        
        <p>CSS transforms allows elements styled with CSS to be transformed
          in two-dimensional or three-dimensional space. This specification is the convergence of the 
            <a href="http://www.w3.org/TR/css3-2d-transforms/">CSS 2D transforms</a>, 
          <a href="http://www.w3.org/TR/css3-3d-transforms/">CSS 3D transforms</a>
          and <a href="http://www.w3.org/TR/2009/WD-SVG-Transforms-20090320/">SVG transforms</a> 
          specifications.</p>

        <h2 class="no-num no-toc" id="status">Status of this document</h2>

        <p class="note">
          This specification merges the former CSS 2D Transforms and CSS 3D Transforms specifications and 
          will also merge CSS Transforms and SVG Transforms. The merge is in progress and the specification
          is not yet ready for review.
        </p>

        <!--status-->

        <p>
          The <a href="ChangeLog">list of changes made to this specification</a> is
          available.
        </p>

        <h2 class="no-num no-toc" id="contents">Table of contents</h2>
        <!--toc-->


        <h2>Introduction</h2>

          <p><em>This section is not normative.</em></p>
          <p>
            The CSS <a href="http://www.w3.org/TR/REC-CSS2/visuren.html">visual
            formatting model</a> describes a coordinate system within each
            element is positioned. Positions and sizes in this coordinate space can
            be thought of as being expressed in pixels, starting in the origin of point
            with positive values proceeding to the right and down.
          </p>
          <p>
            This coordinate space can be modified with the <code
            class="property">'transform'</code> property. Using transform, elements
            can be translated, rotated and scaled in two or three dimensional space.
          </p>
          <p>
            Additional properties make working with transforms easier, and allow the
            author to control how nested three-dimensional transforms interact.
          </p>
          <ul>
            <li>
              The <code class="property"> 'transform-origin'</code> property
              provides a convenient way to control the origin about which transforms on
              an element are applied.
            </li>
            <li>
              The <code class="property">'perspective'</code> property allows the author
              to make child elements with three-dimensional transforms appear as if they live in a common
              three-dimensional space.
              The <code class="property">'perspective-origin'</code> property provides control
              over the origin at which perspective is applied, effectively changing the location of
              the "vanishing point".
            </li>
            <li>
              The <code class="property">'transform-style'</code> property allows 3D-transformed
              elements and their 3D-transformed descendants to share a common three-dimensional
              space, allowing the construction of hierarchies of three-dimensional objects.
            </li>
            <li>
               The <code class="property">'backface-visibility'</code> property comes into play
               when an element is flipped around via three-dimensional transforms such that its
               reverse side is visible to the viewer. In some situations it is desirable to
               hide the element in this situation, which is possible using the value of 'hidden'
               for this property.
            </li>
          </ul>
          <p>
            Note that while some values of the <code class="property">'transform'</code> property
            allow an element to be transformed in a three-dimensional coordinate system, the elements
            themselves are not three-dimensional objects. Instead, they exist on a two-dimensional
            plane (a flat surface) and have no depth.
          </p>

          <div class="issue">
            There are two roles for transformations in layout: (1) transformations
            that adjust the position of the affected content without changing the
            normal layout of that content (much like relative positioning) and (2)
            transformation of the content prior to layout that affects the layout
            of that content. See <a
            href="http://lists.w3.org/Archives/Public/www-style/2007Oct/0209">http://lists.w3.org/Archives/Public/www-style/2007Oct/0209</a>
            for examples of both cases. The "transform" property (as defined in
            this document) is equally useful for both roles. This document is
            focused on satisfying the first role. There is, however, an
            architectural question that arises because there needs to be a way to
            distinguish which role an author of a stylesheet wants. The key
            question is which is the default behavior/role for the "transform"
            property and how is the other behavior/role indicated by a stylesheet
            author. If you have an opinion on this topic, please send feedback.
          </div>
          <div class="issue">
            What do fixed backgrounds do in transforms? They should probably ignore
            the transform completely, since - even transformed - the object should
            be acting as "porthole" through which the fixed background can be viewed
            in its original form.
          </div>
          
        <!-- ======================================================================================================= -->

        <h2 id="module-interactions">Module Interactions</h2>
          <p>Write me</p>

        <h2 id="css-values">CSS Values</h2>
          <p>Write me</p>


        <h2 id="definitions">Definitions</h2>
          <p> When used in this specification, terms have the meanings assigned in
            this section.
          </p>
          <dl>
            <dt id="TermBoundingBox"><dfn>bounding box</dfn></dt>
            <dd>
              <p>
                A bounding box is the object bounding box for all SVG elements without an associated CSS layout box and 
                the border box for all other elements.
              </p>
            </dd>

            <dt id="TermTransformableElement"><dfn>transformable element</dfn></dt>
            <dd>
              <p>
                A transformable element in the HTML namespace which is either a block-level or atomic inline-level
                element, or an element in the SVG namespace (see [[SVG11]]) which has the attributes 'transform',
                'patternTransform' or 'gradientTransform'.
              </p>
            </dd>

            <dt id="TermPerspectiveMatrix"><dfn>perpsective matrix</dfn></dt>
            <dd>
              <p>
                A matrix computed from the values of the <code class="property">perspective</code> and <code class="property">perspective-origin</code> properties as described <a href="#perspective-matrix-computation">below</a>.
              </p>
            </dd>

            <dt id="TermTransformationMatrix"><dfn>transformation matrix</dfn></dt>
            <dd>
              <p>
                A matrix computed from the values of the <code class="property">transform</code> and <code class="property">transform-origin</code> properties as described <a href="#transformation-matrix-computation">below</a>.
              </p>
            </dd>

            <dt id="Term3DRenderingContext"><dfn>3D rendering context</dfn></dt>
            <dd>
              <p>
                A containing block hierarchy of one or more levels, instantiated by elements with a computed value for
                the <code class="property">transform-style</code> property of <code class="css">preserve-3d</code>,
                whose elements share a common three-dimensional coordinate system.
              </p>
            </dd>
            <!-- Define "three-dimensional transform" ? -->
          </dl>

          <!-- ======================================================================================================= -->
              
          <h2 id="transform-rendering">The Transform Rendering Model</h2>
            <!-- This section is normative -->
              <p>
                Specifying a value other than 'none' for the <code class="property">'transform'</code>
                property establishes a new <em>local coordinate system</em> at the element that it is
                applied to. The mapping from where the element would have rendered into that local coordinate system
                is given by the element's <a href="#TermTransformationMatrix"><i>transformation matrix</i></a>.
                Transformations are cumulative. That is, elements establish their local
                coordinate system within the coordinate system of their parent. From the perspective of the
                user, an element effectively accumulates all the <code class="property">'transform'</code>
                properties of its ancestors as well as any local transform applied to it. The accumulation
                of these transforms defines a <em>current transformation matrix (CTM)</em> for the element.
              </p>
              <p>
                The coordinate space behaves as described in the <a
                href="http://www.w3.org/TR/SVG/coords.html#EstablishingANewUserSpace">coordinate
                system transformations</a> section of the SVG 1.1 specification. This is
                a coordinate system with two axes: the X axis increases horizontally to
                the right; the Y axis increases vertically downwards. Three-dimensional
                transform functions extent this coordinate space into three dimensions,
                adding a Z axis perpendicular to the plane of the screen, that increases towards the viewer.
              </p>
              <p id="transformation-matrix-computation">
                The <a href="#TermTransformationMatrix"><i>transformation matrix</i></a> is computed
                from the <code class="property">transform</code> and <code class="property">transform-origin</code> properties
                as follows:
                <ol>
                  <li>Start with the identity matrix.</li>
                  <li>Translate by the computed X, Y and Z values of <code class="property">transform-origin</code></li>
                  <li>Multiply by each of the transform functions in <code class="property">transform</code> property in turn</li>
                  <li>Translate by the negated computed X, Y and Z values of <code class="property">transform-origin</code></li>
                </ol>
              </p>
              <p>
                Transforms apply to <a href="#TermTransformableElement">transformable elements</a>.
              </p>

              <div class="example">
<pre>
div {
    transform: translate(100px, 100px);
}
</pre>
                <p>This transform moves the element by 100 pixels in both the X and Y directions.</p>
                <div class="figure">
                  <img src="transform1.png" alt="The 100px translation in X and Y">
                </div>
              </div>
                
              <div class="example">
<pre>
div {
    height: 100px; width: 100px;
    transform: translate(80px, 80px) scale(1.5, 1.5) rotate(45deg);
}
</pre>
                <p>This transform moves the element by 80 pixels in both the X and Y directions, then scales the element by 150%, then rotates it 45&deg; clockwise about the Z axis. Note that the scale and rotation operate about the center of the element, since the element has the default transform-origin of 50% 50%.</p>
              <div class="figure">
                <img src="compound_transform.png" alt="The transform specified above">
              </div>

              <p>Note that an identical rendering can be obtained by nesting elements with the equivalent transforms:
<pre>
&lt;div style="transform: translate(80px, 80px)"&gt;
  &lt;div style="transform: scale(1.5, 1.5)"&gt;
    &lt;div style="transform: rotate(45deg)"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
            </div>

              <!-- This "in the HTML namespace" is awkward. Is there a better way? -->
              <p>
                In the HTML namespace, the transform property does not affect the flow of the content
                surrounding the transformed element. However, the extent of the overflow
                area takes into account transformed elements. This behavior is similar
                to what happens when elements are offset via relative positioning.
                Therefore, if the value of the <code class="property">'overflow'</code>
                property is <code class="css">'scroll'</code> or <code class="css">'auto'</code>,
                scrollbars will appear as needed to see content that is transformed outside the visible area.
              </p>
              <p>
                In the HTML namespace, any value other than 'none' for the transform results in the creation of
                both a stacking context and a containing block. The object acts as a
                containing block for fixed positioned descendants.
              </p>
              <p class="issue">
                Is this affect on position:fixed necessary? If so, need to go into more detail here
                about why fixed positioned objects should do this, i.e., that it's much harder to implement otherwise.
              </p>
              
              <h3 id="transform-3d-rendering">3D Transform Rendering</h3>

              <!-- Maybe define "tranform container" in the definitions, and use it everywhere
              in place of "containing block"? I'm not sure if "containing block" is exactly right. -->
              <p>
                Normally, elements render as flat planes, and are rendered into the same plane
                as their containing block. Often this is the plane shared by the rest of the page.
                Two-dimensional transform functions can alter the appearance of an element, but
                that element is still rendered into the same plane as its containing block.
              </p>
              <p>
                Three-dimensional transforms can result in transformation matrices with a non-zero
                Z component<!-- clarify -->, potentially lifting them off the plane of their
                containing block. Because of this, elements with three-dimensional transformations
                could potentially render in an front-to-back order that different from the normal CSS rendering order,
                and intersect with each other. Whether they do so depends on whether the element is a member
                of a <span class="term">3D rendering context</span>, as described below.
              </p>
              <div class="issue">
                <p class="desc">This description does not exactly match what WebKit implements. Perhaps
                  it should be changed to match current implementations?</p>
              </div>

              <div class="example">
                <p>This example shows the effect of three-dimensional transform applied to an element.
                </p>
<pre>
&lt;style&gt;
div { height: 150px; width: 150px; }
.container { border: 1px solid black; }
.transformed { transform: rotateY(50deg); }
&lt;/style&gt;

&lt;div class="container"&gt;
    &lt;div class="transformed"&gt;&lt;/div&gt;
&lt;/div&gt;
</pre>  
              <div class="figure">
                <img src="examples/simple-3d-example.png" width="210" height="190" alt="Div with a rotateY transform.">
              </div>
                <p>The transform is a 50&deg; rotation about the vertical, Y axis. Note how this makes the blue box appear
                  narrower, but not three-dimensional.
                </p>
              </div>

              <p>
                The <code class="property">perspective</code> and <code class="property">perspective-origin</code>
                properties can be used to add a feeling of depth to a scene by making elements higher on the Z axis
                (closer to the viewer) appear larger, and those futher away to appear smaller.
              </p>
              <p id="perspective-matrix-computation">
                The <a href="#TermPerspectiveMatrix"><i>perspective matrix</i></a> is computed as follows:
                <!-- Make this more mathy, with matrices? -->
                <ol>
                  <li>Start with the identity matrix.</li>
                  <li>Translate by the computed X and Y values of <code class="property">perspective-origin</code></li>
                  <li>Multiply by the matrix that would be obtained from the <a href="#perspective-function"><code class="css">perspective(&lt;length&gt;)</code></a> transform function, where the length is provided by the value of the <code class="property">perspective</code> property</li>
                  <li>Translate by the negated computed X and Y values of <code class="property">perspective-origin</code></li>
                </ol>
              </p>
              
              <div class="example">
                <p>This example shows how perspective can be used to cause three-dimensional transforms to appear more realistic.
                </p>
<pre>
&lt;style&gt;
div { height: 150px; width: 150px; }
.container { perspective: 500px; border: 1px solid black; }
.transformed { transform: rotateY(50deg); }
&lt;/style&gt;

&lt;div class="container"&gt;
    &lt;div class="transformed"&gt;&lt;/div&gt;
&lt;/div&gt;
</pre>  
                <div class="figure">
                    <img src="examples/simple-perspective-example.png" width="210" height="190" alt="Div with a rotateY transform,
                    and perspective on its container">
                </div>
                <p>The inner element has the same transform as in the previous example, but its rendering is now influenced by the perspective
                  property on its parent element. Perspective causes vertices that have positive Z coordinates (closer to the viewer)
                  to be scaled up in X and Y, and those futher away (negative Z coordinates) to be scaled down, giving an appearance of depth.
                </p>
              </div>

              <p>
                An element with a three-dimensional transform that is not contained in a
                <span class="term">3D rendering context</span> renders with the appropriate
                transform applied, but does not intersect with any other elements. The three-dimensional
                transform in this case can be considered just as a painting effect, like two-dimensional
                transforms. Similarly, the transform does not affect painting order. For example, a transform with a 
                positive Z translation may make an element look larger, but does not cause that element
                to render in front of elements with no translation in Z.
              </p>
              <p>
                An element with a three-dimensional transform that is contained in a
                <span class="term">3D rendering context</span> can visibly interact with other elements
                in that same 3D rendering context; the set of elements participating in the same 
                <span class="term">3D rendering context</span> may obscure each other or intersect,
                based on their computed transforms. They are rendered as if they are all siblings,
                positioned in a common 3D coordinate space. The position of each element in that three-dimensional
                space is determined by accumulating the transformation matrices
                up from the element that establishes the <span class="term">3D rendering context</span>
                through each element that is a containing block for the given element, as described below.
                <!-- More detail required, probably with matrices -->
              </p>

              <div class="example">
<pre>
&lt;style&gt;
div { height: 150px; width: 150px; }
.container { perspective: 500px; border: 1px solid black; }
.transformed { transform: rotateY(50deg); background-color: blue; }
.child { transform-origin: top left; transform: rotateX(40deg); background-color: lime; }
&lt;/style&gt;

&lt;div class="container"&gt;
  &lt;div class="transformed"&gt;
    &lt;div class="child"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
                <p>This exmaple shows how nested 3D transforms are rendered in the absence of <code>transform-style: preserve-3d</code>. The blue div is transformed as in the previous example, with its rendering influenced by the perspective on its parent element. The lime element also has a 3D transform, which is a rotation about the X axis (anchored at the top, by virtue of the transform-origin). However, the lime element is being rendered into the plane of its parent because it is not a member of a 3D rendering context; the parent is "flattening".
                </p>
                <div class="figure">
                  <img src="examples/3d-rendering-context-flat.png" width="240" height="200" alt="Nested 3D transforms, with flattening">
                </div>
              </div>

              <p>Elements establish and participate in 3D rendering contexts as follows:</p>
              <ul>
                <li>
                  A <span class="term">3D rendering context</span> is established by a
                  a transformable element whose computed value for <code class="property">transform-style</code> is
                  <code class="css">'preserve-3d'</code>, and which itself is not part of a 3D rendering context.
                  Note that such an element is always a containing block. An element that establishes a 3D rendering context
                  also participates in that context.
                </li>
                <li>
                  An element whose computed value for <code class="property">transform-style</code> is
                  <class style="css">'preserve-3d'</code>, and which itself participates in a
                  <span class="term">3D rendering context</span>, extends that 3D rendering context rather than establishing
                  a new one.
                </li>
                <li>
                  An element participates in a <span class="term">3D rendering context</span> if its containing block
                  establishes or extends a <span class="term">3D rendering context</span>.
                </li>
              </ul>
              <p>
                The final value of the transform used to render an element in a <span class="term">3D rendering context</span>
                is computed by accumulating a matrix as follows:
              </p>
              <ol>
                <li>Start with the identity matrix</li>
                <li>For each containing block between the root of the <span class="term">3D rendering context</span> 
                  and the element in question:
                  <ol>
                    <li>multiply the accumulated matrix with the <a href="#TermPerspectiveMatrix"><i>perspective matrix</i></a>
                      on the element's containing block (if any). That contining block is not necessarily a member
                      of the 3D rendering context.</li>
                    <li>apply to the accumulated matrix a translation equivalent to the horizontal and vertical offset of the element relative to
                      its containing block as specified by the CSS visual formatting model. <!-- (tighten this!) --></li>
                    <li>multiply the accumulated matrix with the <a href="#TermTransformationMatrix"><i>transformation matrix</i></a>.</li>
                  </ol>
                </li>
              </ol>
              
              <div class="example">
<pre>
&lt;style&gt;
div { height: 150px; width: 150px; }
.container { perspective: 500px; border: 1px solid black; }
.transformed { <b>transform-style: preserve-3d</b>; transform: rotateY(50deg); background-color: blue; }
.child { transform-origin: top left; transform: rotateX(40deg); background-color: lime; }
&lt;/style&gt;
</pre>
                <p>This example is identical to the previous example, with the addition of <code>transform-style: preserve-3d</code> on the blue element. The blue element now establishes a 3D rendering context, of which the lime element is a member. Now both blue and lime elements share a common three-dimensional space, so the lime element renders as tilting out from its parent, influenced by the perspective on the container.
                </p>
                <div class="figure">
                  <img src="examples/3d-rendering-context-3d.png" width="240" height="200" alt="Nested 3D transforms, with preserve-3d.">
                </div>
              </div>

              <div class="issue">
                <p class="desc">Should intersection behavior be normative?</p>
              </div>
              <p>
                Elements in the same <span class="term">3D rendering context</span> may intersect with eachother. User agents should
                subdivide the planes of intersecting elements as described by
                <a href="http://en.wikipedia.org/wiki/Newell's_algorithm">Newell's algorithm</a> to render intersection.
              </p>
              <p>
                Untransformed elements in a <span class="term">3D rendering context</span> render on the Z=0 plane, yet may still
                intersect with transformed elements.
              </p>
              <p>
                Within a <span class="term">3D rendering context</span>, the rendering order of non-intersecting elements is
                based on their position on the Z axis after the application of the accumulated transform. Elements at the same
                Z position render in <a href="http://www.w3.org/TR/CSS2/zindex.html#painting-order">stacking context order</a>.
              </p>

              <div class="example">
<pre>
&lt;style&gt;
.container {
    background-color: rgba(0, 0, 0, 0.3);
    transform-style: preserve-3d;
    perspective: 500px;
}
.container > div {
    position: absolute;
    left: 0;
}
.container > :first-child {
    transform: rotateY(45deg);
    background-color: orange;
    top: 10px;
    height: 135px;
}
.container > :last-child {
    transform: translateZ(40px);
    background-color: rgba(0, 0, 255, 0.75);
    top: 50px;
    height: 100px;
}
&lt;/style&gt;

&lt;div class="container"&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;div&gt;&lt;/div&gt;
&lt;/div&gt;
</pre>
                <p>
                  This example shows show elements in a 3D rendering context can intersect. The container element establishes
                  a 3D rendering context for itself and its two children. The children intersect with eachother, and
                  the orange element also intersects with the container.
                </p>
                <div class="figure">
                  <img src="examples/3d-intersection.png" width="200" height="200" alt="Intersecting sibling elements.">
                </div>
              </div>
              
              <p>
                Using three-dimensional transforms, it's possible to transform an element such that its reverse side
                is towards the viewer. 3D-tranformed elements show the same content on both sides, so the reverse side
                looks like a mirror-image of the front side (as if the element were painted onto a sheet of glass).
                Normally, elements whose reverse side is towards the viewer remain visible. However, the
                <code class="property">'backface-visibility'</code> property allows the author to make an element invisible
                when its reverse side is towards the viewer. This behavior is "live"; if an element with
                <code class="css">backface-visibility: hidden</code> were animating,
                such that its front and reverse sides were alternately visible, then it would only be visible when the
                front side were towards the viewer.
              </p>

              <!-- ======================================================================================================= -->

              <h2 id="transform-property">
                The <code class="property">'transform'</code> Property
              </h2>
              <p>
                A transformation is applied to the coordinate system an element
                renders in through the <code class="property">'transform'</code> property. This property contains a
                list of <a href="#transform-functions">transform functions</a>. The
                final transformation value for a coordinate system is obtained by converting
                each function in the list to its corresponding matrix like defined in <a href="#mathematical-description">Mathematical
                Description of Transformation Functions</a>, then multiplying the matrices.
              </p>
              <table class="propdef">
                <tbody>
                  <tr>
                    <td>
                      <em>Name:</em>
                    </td>
                    <td>
                      <dfn id="effects">transform</dfn>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Value:</em>
                    </td>
                    <td>
                      none | &lt;transform-function&gt; [ &lt;transform-function&gt; ]*
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Initial:</em>
                    </td>
                    <td>
                      none
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Applies&nbsp;to:</em>
                    </td>
                    <td>
                      <a href="#TermTransformableElement">transformable elements</a>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Inherited:</em>
                    </td>
                    <td>
                      no
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Percentages:</em>
                    </td>
                    <td>
                      refer to the size of the element's bounding box
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Media:</em>
                    </td>
                    <td>
                      visual
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Computed value:</em>
                    </td>
                    <td>
                      See below.
                    </td>
                  </tr>
                </tbody>
              </table>
              
              <div class="issue">
                <p class="desc">We need to resolve whether the computed value is the same as the specified value, or matrix().</p>
              </div>
              <p>The computed value of the transform property is a matrix() or matrix3d() value that describes the matrix that results from concatenating the individual transform functions. If the resulting matrix can be represented as a two-dimensional matrix with no loss of information, then a matrix() value is returned, otherwise a matrix3d() value. For elements with no transform applied, the computed value is 'none'.</p>

              <p>Any value other than 'none' for the transform results in the creation of both a stacking context and a containing block. The object acts as a containing block for fixed positioned descendants.</p>

              <!-- ======================================================================================================= -->
              
              <h3 id="svg-transform">The SVG transform attribute</h3>
              
              <p>The <a href="http://www.w3.org/TR/2011/REC-SVG11-20110816/">SVG 1.1 specification</a> did not
                  specify the 'transform' attribute as a <a href="http://www.w3.org/TR/2011/REC-SVG11-20110816/styling.html#UsingPresentationAttributes">presentation attribute</a>. 
                  In order to improve the integration of
                  SVG and HTML, this specification makes the SVG 'transform' attribute a 
                  'presentation attribute' and makes the 'transform' property one that applies to SVG elements.</p>
                  
              <h4 id="transform-attribute-specificity">SVG transform attribute specificity</h4>
              
              <p>Since the SVG attribute becomes a presentation attribute, its participation to the CSS 
                  cascade is determined by the specificity of presentation attributes, as 
                  <a href="http://www.w3.org/TR/2011/REC-SVG11-20110816/styling.html#UsingPresentationAttributes">explained</a>
                  in the SVG specification.</p>
                  
              <h4 id="transform-attribute-dom">SVG transform attribute DOM</h4>
              
              <p>The SVG specification <a href="http://www.w3.org/TR/2011/REC-SVG11-20110816/coords.html#InterfaceSVGAnimatedTransformList">defines</a> a DOM interface to access the animated and base value of 
                  the SVG transform attribute. To ensure backwards compatibility, this API should still be
                  supported by user agents. The <code>baseVal</code> should be the value of the 'transform' attribute, 
                  as set on the element, and the <code>animVal</code> should be the property's computed value which account
                  for CSS animation, if any is underway.</p>
                  
              <div class="issue">
                  <ul>
                      <li>Should we also make gradientTransform and patternTransform presentation attributes? 
                          Proposal: they 
                          are the 'presentation attributes' for &lt;gradient&gt; and &gt;pattern&lt; respectively,
                          for the 'transform' property (i.e., there is no 'gradientTransform' property. Instead, the
                          'gradientTransform' is a presentation attribute that provides a value for the 
                          'transform' property that applies to the &lt;gradient&gt; element.)</li>
                      <li>Is this proposal working for SMIL animation of the transform property?</li>
                  </ul>
              </div>

              <!-- ======================================================================================================= -->

              <h2 id="transform-origin-property">
                The <code class="property">'transform-origin'</code> Property
              </h2>
              <table class="propdef">
                <tbody>
                  <tr>
                    <td>
                      <em>Name:</em>
                    </td>
                    <td>
                      <dfn id="transform-origin">transform-origin</dfn>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Value:</em>
                    </td>
                    <td>
            [ top | bottom ] |<br>
            [ &lt;percentage> | &lt;length&gt; | left | center | right ] [ &lt;percentage> | &lt;length&gt; | top | center | bottom ]? |<br>
            [ center | [ left | right ] [ &lt;percentage> | &lt;length&gt; ]? ] &amp;&amp; [ center | [ top | bottom ] [ &lt;percentage> | &lt;length&gt; ]? ]<br>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Initial:</em>
                    </td>
                    <td>
                      0 0 for SVG elements without associated CSS layout box, 50% 50% for all other elements
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Applies&nbsp;to:</em>
                    </td>
                    <td>
                      <a href="#TermTransformableElement">transformable elements</a>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Inherited:</em>
                    </td>
                    <td>
                      no
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Percentages:</em>
                    </td>
                    <td>
                      refer to the size of the element's bounding box
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Media:</em>
                    </td>
                    <td>
                      visual
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Computed value:</em>
                    </td>
                    <td>
                      For &lt;length&gt; the absolute value, otherwise a percentage
                    </td>
                  </tr>
                </tbody>
              </table>

              <p>
                The values of the <code class="property">'transform'</code> and 
                <code class="property">'transform-origin'</code> properties are used to compute the
                <a href="#TermTransformationMatrix"><i>transformation matrix</i></a>, as described above.
              </p>

              <p>If only one value is specified, the second value is assumed to be
              'center'. If two values are given and at least one value is not a keyword,
              then the first value represents the horizontal position (or offset) and
              the second represents the vertical position (or
              offset). <var>&lt;percentage&gt;</var> and <var>&lt;length&gt;</var>
              values here represent an offset of the transform origin from the top left corner
              of the element's bounding box.
              </p>
              
              <p>For SVG elements without an associated CSS layout box the <var>&lt;length&gt;</var>
              values represent an offset from the point of origin of the element's local coordinate space.
              </p>

              <p>If three or four values are given, then
              each <var>&lt;percentage&gt;</var> or<var>&lt;length&gt;</var>
              represents an offset and must be preceded by a keyword,
              which specifies from which edge of the bounding box the offset is given. For example,
              ''transform-origin: bottom 10px right 20px'' represents a
              ''10px'' vertical offset up from the bottom edge and a
              ''20px'' horizontal offset leftward from the right edge. If
              three values are given, the missing offset is assumed to be zero.
              </p>

              <p>Positive values represent an offset <em>inward</em> from the edge of
              the bounding box. Negative values represent an offset
              <em>outward</em> from the edge of the bounding box.
              </p>

              <div class="issue">
                <p class="desc">Need to add 3D transform-origin variant in a way that is not ambiguous
                  with the background-origin syntax (<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=15432">bug 15432</a>).</p>
              </div>

              <!-- ======================================================================================================= -->

              <h2 id="transform-style-property">
                The <code class="property">'transform-style'</code> Property
              </h2>
              <table class="propdef">
                <tbody>
                  <tr>
                    <td>
                      <em>Name:</em>
                    </td>
                    <td>
                      <dfn id="transform-style">transform-style</dfn>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Value:</em>
                    </td>
                    <td>
                      flat | preserve-3d
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Initial:</em>
                    </td>
                    <td>
                      flat
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Applies&nbsp;to:</em>
                    </td>
                    <td>
                      <a href="#TermTransformableElement">transformable elements</a>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Inherited:</em>
                    </td>
                    <td>
                      no
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Percentages:</em>
                    </td>
                    <td>
                      N/A
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Media:</em>
                    </td>
                    <td>
                      visual
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Computed value:</em>
                    </td>
                    <td>
                      Same as specified value.
                    </td>
                  </tr>
                </tbody>
              </table>

              <p>
                A value of <code class="css">preserve-3d</code> for <code class="property">transform-style</code>
                establishes a stacking context.
              </p>

              <p>
                The following CSS property values require the user agent to create a flattened representation of
                the descendant elements before they can be applied, and therefore override the behavior of 
                <code class="property">transform-style</code>: <code class="css">preserve-3d</code>:
                <ul>
                  <li><code class="property">overflow</code>: any value other than 'visible'.</li>
                  <li><code class="property">opacity</code>: any value other than 1.</li>
                  <li><code class="property">filter</code>: any value other than 'none'.</li>
                  <!-- Others? -->
                </ul>
              </p>
              <div class="issue">
                <p class="desc">Should this affect the computed value of transform-style?</p>
              </div>
              <p>
                The values of the <code class="property">'transform'</code> and 
                <code class="property">'transform-origin'</code> properties are used to compute the
                <a href="#TermTransformationMatrix"><i>transformation matrix</i></a>, as described above.
              </p>

              <!-- ======================================================================================================= -->

              <h2 id="perspective-property">
                The <code class="property">'perspective'</code> Property
              </h2>
              <table class="propdef">
                <tbody>
                  <tr>
                    <td>
                      <em>Name:</em>
                    </td>
                    <td>
                      <dfn id="perspective">perspective</dfn>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Value:</em>
                    </td>
                    <td>
                      none | &lt;length&gt;
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Initial:</em>
                    </td>
                    <td>
                      none
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Applies&nbsp;to:</em>
                    </td>
                    <td>
                      <a href="#TermTransformableElement">transformable elements</a>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Inherited:</em>
                    </td>
                    <td>
                      no
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Percentages:</em>
                    </td>
                    <td>
                      N/A
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Media:</em>
                    </td>
                    <td>
                      visual
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Computed value:</em>
                    </td>
                    <td>
                      Same as specified value.
                    </td>
                  </tr>
                </tbody>
              </table>

              <p>
                If the value is <code class="css">'none'</code>, less than or equal to 0 no
                perspective transform is applied.
              </p>
              <p>
                The use of this property with any value other than 'none' establishes a
                stacking context. It also establishes a containing block (somewhat
                similar to position:relative), just like the 'transform' property does.
              </p>
              <p>
                The values of the <code class="property">perspective</code> and <code class="property">perspective-origin</code>
                properties are used to compute the <a href="#TermPerspectiveMatrix"><i>perspective matrix</i></a>, as described above.
              </p>
              
              <!-- ======================================================================================================= -->
              
              <h2 id="perspective-origin-property">
                The <code class="property">'perspective-origin'</code> Property
              </h2>
              <p>
                The <code class="property">'perspective-origin'</code> property
                establishes the origin for the <em>perspective</em> property. It
                effectively sets the X and Y position at which the viewer appears to be
                looking at the children of the element.
              </p>
              <table class="propdef">
                <tbody>
                  <tr>
                    <td>
                      <em>Name:</em>
                    </td>
                    <td>
                      <dfn id="perspective-origin">perspective-origin</dfn>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Value:</em>
                    </td>
                    <td>
                      [ [ &lt;percentage&gt; | &lt;length&gt; | left | center | right ] [
                      &lt;percentage&gt; | &lt;length&gt; | top | center | bottom ]? ] | [ [ left |
                      center | right ] || [ top | center | bottom ] ]
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Initial:</em>
                    </td>
                    <td>
                      50% 50%
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Applies&nbsp;to:</em>
                    </td>
                    <td>
                      <a href="#TermTransformableElement">transformable elements</a>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Inherited:</em>
                    </td>
                    <td>
                      no
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Percentages:</em>
                    </td>
                    <td>
                      refer to the size of the element's bounding box
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Media:</em>
                    </td>
                    <td>
                      visual
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Computed value:</em>
                    </td>
                    <td>
                      Same as specified value.
                    </td>
                  </tr>
                </tbody>
              </table>
              <p>
                The values of the <code class="property">perspective</code> and <code class="property">perspective-origin</code>
                properties are used to compute the <a href="#TermPerspectiveMatrix"><i>perspective matrix</i></a>, as described above.
              </p>
              
              <!-- ======================================================================================================= -->

              <h2 id="backface-visibility-property">
                The <code class="property">'backface-visibility'</code> Property
              </h2>
              <p>
                The <code class="property">'backface-visibility'</code> property
                determines whether or not the "back" side of a transformed element is
                visible when facing the viewer. With an identity transform, the front
                side of an element faces the viewer. Applying a rotation about Y of 180
                degrees (for instance) would cause the back side of the element to face
                the viewer.
              </p>
              <!-- This should not be in a normative section. -->
              <p>
                This property is useful when you place two elements back-to-back, as you
                would to create a playing card. Without this property, the front and
                back elements could switch places at times during an animation to flip
                the card. Another example is creating a box out of 6 elements, but where
                you want to see the inside faces of the box. This is useful when
                creating the backdrop for a 3 dimensional stage.
              </p>
              <table class="propdef">
                <tbody>
                  <tr>
                    <td>
                      <em>Name:</em>
                    </td>
                    <td>
                      <dfn id="backface-visibility">backface-visibility</dfn>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Value:</em>
                    </td>
                    <td>
                      visible | hidden
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Initial:</em>
                    </td>
                    <td>
                      visible
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Applies&nbsp;to:</em>
                    </td>
                    <td>
                      <a href="#TermTransformableElement">transformable elements</a>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Inherited:</em>
                    </td>
                    <td>
                      no
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Percentages:</em>
                    </td>
                    <td>
                      N/A
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Media:</em>
                    </td>
                    <td>
                      visual
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Computed value:</em>
                    </td>
                    <td>
                      Same as specified value.
                    </td>
                  </tr>
                </tbody>
              </table>
              <p>
                The visibility of an element with <code class="css">backface-visibility: hidden</code> is determined
                as follows:
                <ol>
                  <li>Compute a matrix representing the accumulated transform from the viewport, taking the translations
                    due to the CSS visual formatting mode, the perpsective and transformation matrices into account,
                    in a similar manner to the computation of the accumulated transform for an element in a
                    3D rendering context.
                  </li>
                  <li>
                    If the component of the matrix in row 3, column 3 is negative, then the element should be hidden,
                    otherwise it is visible.
                  </li>
                </ol>
                <div class="issue">
                  Is the relevant matrix here really relative to the viewport, or to the root of the 3D rendering context?
                </div>
              </p>

              <!-- ======================================================================================================= -->

              <h2 id="transform-functions">
                The Transformation Functions
              </h2>
              <p>
                The value of the <code class="property">transform</code> property is a
                list of &lt;transform-functions&gt; applied in the order provided. The
                individual transform functions are separated by whitespace. The
                set of allowed transform functions is given below. In this list the
                type &lt;translation-value&gt; is defined as a &lt;length&gt; or
                &lt;percentage&gt; value, and the &lt;angle&gt; type is defined by <a
                href="http://www.w3.org/TR/css3-values/">CSS Values and Units.</a>
                Wherever &lt;angle&gt; is used in this specification, a &lt;number&gt; that is equal to
                zero is also allowed, which is treated the same as an angle of zero degrees.
              </p>

              <h3 id="two-d-transform-functions">2D Transformation Functions</h3>
              <dl>
                <dt>
                  <code class="css">matrix(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;)</code>
                </dt>
                <dd>
                  specifies a 2D transformation in the form of a <a href="#MatrixDefined">transformation matrix</a> of the six values a-f.
                </dd>
                <dt>
                  <code class="css">translate(&lt;translation-value&gt;[, &lt;translation-value&gt;])</code>
                </dt>
                <dd>
                  specifies a <a href="#TranslateDefined">2D translation</a> by the vector [tx, ty], where tx is the first translation-value parameter and ty is the optional second translation-value parameter. If <em>&lt;ty&gt;</em> is not provided, ty has zero as a value.
                </dd>
                <dt>
                  <code class="css">translateX(&lt;translation-value&gt;)</code>
                </dt>
                <dd>
                  specifies a <a href="#TranslateDefined">translation</a> by the given amount in the X direction.
                </dd>
                <dt>
                  <code class="css">translateY(&lt;translation-value&gt;)</code>
                </dt>
                <dd>
                  specifies a <a href="#TranslateDefined">translation</a> by the given amount in the Y direction.
                </dd>
                <dt>
                  <code class="css">scale(&lt;number&gt;[, &lt;number&gt;])</code>
                </dt>
                <dd>
                  specifies a <a href="#ScaleDefined">2D scale</a> operation by the [sx,sy] scaling vector described by the 2 parameters. If the second parameter is not provided, it is takes a value equal to the first. For example, scale(1, 1) would leave an element unchanged, while scale(2, 2) would cause it to appear twice as long in both the X
                  and Y axes, or four times its typical geometric size.
                </dd>
                <dt>
                  <code class="css">scaleX(&lt;number&gt;)</code>
                </dt>
                <dd>
                  specifies a <a href="#ScaleDefined">2D scale</a> operation using the [sx,1] scaling vector, where sx is given as the parameter.
                </dd>
                <dt>
                  <code class="css">scaleY(&lt;number&gt;)</code>
                </dt>
                <dd>
                  specifies a <a href="#ScaleDefined">2D scale</a> operation using the [1,sy] scaling vector, where sy is given as the parameter.
                </dd>
                <dt>
                  <code class="css">rotate(&lt;angle&gt;[, &lt;translation-value&gt;, &lt;translation-value&gt;])</code>
                </dt>
                <dd>
                  specifies a <a href="#RotateDefined">2D rotation</a> by the angle specified in the parameter about the origin of the element, as defined by the <em>transform-origin</em> property, or a given point as to the origin of the element. For example, rotate(90deg) would cause elements to appear
                  rotated one-quarter of a turn in the clockwise direction. With rotate(90deg, 100px, 100px) the element appears rotated after a translation of 100px in the vertical and horizontal direction. The actual origin of the element is not affected.
                </dd>
                <dt>
                  <code class="css">skew(&lt;angle&gt;[, &lt;angle&gt;])</code>
                </dt>
                <dd>
                  specifies a <a href="#SkewDefined">2D skew</a> by [ax,ay] for X and Y. If the second parameter is not provided, it is has a zero value.
                </dd>
                <dt>
                  <code class="css">skewX(&lt;angle&gt;)</code>
                </dt>
                <dd>
                  specifies a <a href="#SkewDefined">2D skew transformation along the X axis</a> by the given angle. The skew vector is [ax,0].
                </dd>
                <dt>
                  <code class="css">skewY(&lt;angle&gt;)</code>
                </dt>
                <dd>
                  specifies a <a href="#SkewDefined">2D skew transformation along the Y axis</a> by the given angle. The skew vector is [0,ay].
                </dd>
              </dl>


              <h3 id="three-d-transform-functions">3D Transformation Functions</h3>
              <dl>
                <dt>
                  <code class="css">matrix3d(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;)</code>
                </dt>
                <dd>
                  specifies a 3D transformation as a 4x4 homogeneous matrix of 16 values in column-major order.
                </dd>
                <dt>
                  <code class="css">translate3d(&lt;translation-value&gt;, &lt;translation-value&gt;, &lt;length&gt;)</code>
                </dt>
                <dd>
                  specifies a <a href="#Translate3dDefined">3D translation</a> by the vector [tx,ty,tz], with tx, ty and tz being the first, second and third translation-value parameters respectively.
                </dd>
                <dt>
                  <code class="css">translateZ(&lt;length&gt;)</code>
                </dt>
                <dd>
                  specifies a <a href="#Translate3dDefined">3D translation</a> by the vector [0,0,tz] with the given amount in the Z direction.
                </dd>
                <dt>
                  <code class="css">scale3d(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;)</code>
                </dt>
                <dd>
                  specifies a <a href="#Scale3dDefined">3D scale</a> operation by the [sx,sy,sz] scaling vector described by the 3 parameters.
                </dd>
                <dt>
                  <code class="css">scaleZ(&lt;number&gt;)</code>
                </dt>
                <dd>
                  specifies a <a href="#Scale3dDefined">3D scale</a> operation using the [1,1,sz] scaling vector, where sz is given as the parameter.
                </dd>
                <dt>
                  <code class="css">rotate3d(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;angle&gt;)</code>
                </dt>
                <div class="todo">Clarify "clockwise". Describe in terms of right-hand rule?</div>
                <dd>
                  specifies a clockwise <a href="#Rotate3dDefined">3D rotation</a> by the angle specified in last
                  parameter about the [x,y,z] direction vector described by the first 3
                  parameters. If the direction vector is not of unit length, it will be
                  normalized. A direction vector that cannot be normalized, such as [0,0,0], will cause the rotation to not be applied.
                </dd>
                <dt>
                  <code class="css">rotateX(&lt;angle&gt;)</code>
                </dt>
                <dd>
                  specifies a clockwise <a href="#RotateXDefined">3D rotation</a> by the given angle about the X axis.
                </dd>
                <dt>
                  <code class="css">rotateY(&lt;angle&gt;)</code>
                </dt>
                <dd>
                  specifies a clockwise <a href="#RotateYDefined">3D rotation</a> by the given angle about the Y axis.
                </dd>
                <dt>
                  <code class="css">rotateZ(&lt;angle&gt;)</code>
                </dt>
                <dd>
                  specifies a clockwise <a href="#RotateZDefined">3D rotation</a> by the given angle about the Z axis. This is a synonym for <code class="css">rotate(&lt;angle&gt;)</code>.
                </dd>
                <dt id="perspective-function">
                  <code class="css">perspective(&lt;length&gt;)</code>
                </dt>
                <dd>
                  specifies a <a href="#PerspectiveDefined">perspective projection matrix</a>. This matrix scales points in X and Y based on their Z value,
                  scaling points with positive Z values away from the origin, and those with negative Z values towards the
                  origin. Points on the z=0 plane are unchanged. The <em>depth</em>, given as the parameter to the function,
                  represents the distance of the z=0 plane from the viewer. Lower values give a more flattened pyramid and
                  therefore a more pronounced perspective effect. For example, a value of 1000px
                  gives a moderate amount of foreshortening and a value of 200px gives an extreme amount. The value for depth must be greater than zero, otherwise the function is invalid.
                </dd>
              </dl>

              <!-- ======================================================================================================= -->

              <h2 id="transform-values">
                Transform Values and Lists
              </h2>
              <p>
                The &lt;translation-value&gt; values are defined as [&lt;percentage&gt; | &lt;length&gt;]. All other value types are described <a href="http://www.w3.org/TR/REC-CSS2/syndata.html#values">as CSS types</a>. If a list of transforms is provided, then the net effect is as if each transform had been specified separately in the order provided. For example,
              </p>
<pre>
&lt;div style="transform:translate(-10px,-20px) scale(2) rotate(45deg) translate(5px,10px)"/&gt;
</pre>
              <p>
                is functionally equivalent to:
              </p>
<pre>
&lt;div style="transform:translate(-10px,-20px)"&gt;
  &lt;div style="transform:scale(2)"&gt;
    &lt;div style="transform:rotate(45deg)"&gt;
      &lt;div style="transform:translate(5px,10px)"&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
          <p>
            That is, in the absence of other styling that affects position and dimensions, a nested set of transforms is equivalent to a single list of transform functions, applied from the outside in. The resulting transform is the matrix multiplication of the list of transforms.
          </p>
          <!-- ======================================================================================================= -->

              <h2 id="animation">
                Transitions and Animations between Transform Values
              </h2>

              <p>
                When animating or transitioning the value of a transform property
                the rules described below are applied. The 'from' transform is
                the transform at the start of the transition or current keyframe. The
                'end' transform is the transform at the end of the transition or
                current keyframe.
              </p>

              <ul>
                <li>
                  If the 'from' and 'to' transforms are both single functions
                  of the same type:
                  <ul>
                    <li>
                      For translate, translate3d, translateX, translateY, translateZ, scale,
                      scale3d, scaleX, scaleY, scaleZ, rotate, rotateX, rotateY, rotateZ, skew, skewX
                      and skewY functions:
                        <ul>
                          <li>
                            the individual components of the function are
                            interpolated numerically.
                          </li>
                        </ul>
                    </li>
                    <li>
                      For perspective, matrix, matrix3d and rotate3d:
                        <ul>
                          <li>
                            the values are first converted to a 4x4 matrix, then
                            decomposed using <a
                            href="#unmatrix">the
                            method described by unmatrix</a> into separate translation,
                            scale, rotation, skew and perspective matrices, then each
                            decomposed matrix is interpolated numerically, and finally
                            combined in order to produce a resulting 4x4 matrix.
                          </li>
                        </ul>
                    </li>
                  </ul>
                </li>
                <li>
                  If both the 'from' and 'to' transforms are "none":
                  <ul>
                    <li>
                      There is no interpolation necessary
                    </li>
                  </ul>
                </li>
                <li>
                  If one of the 'from' or 'to' transforms is "none":
                  <ul>
                    <li>
                      The 'none' is replaced by an equivalent identity function list for
                      the corresponding transform function list.
                      <p>
                        For example, if the 'from' transform is "scale(2)" and the 'to'
                        transform is "none" then the value "scale(1)" will be used as the
                        'to' value, and animation will proceed using the rule above.
                        Similarly, if the 'from' transform is "none" and the 'to' transform
                        is "scale(2) rotate(50deg)" then the animation will execute as
                        if the 'from' value is "scale(1) rotate(0)".
                      </p>
                      <p>
                        The identity functions are translate(0), translate3d(0, 0, 0),
                        translateX(0), translateY(0), translateZ(0), scale(1), scale3d(1, 1, 1),
                        scaleX(1), scaleY(1), scaleZ(1), rotate(0), rotate3d(1, 1, 1, 0),
                        rotateX(0), rotateY(0), rotateZ(0), skew(0), skewX(0), skewY(0),
                        matrix(1, 0, 0, 1, 0, 0) and
                        matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1).
                      </p>
                    </li>
                  </ul>
                </li>
                <li>
                  If both the 'from' and 'to' transforms have the same number of
                  transform functions and corresponding functions in each transform
                  list are of the same type:
                  <ul>
                    <li>
                      Each transform function is animated with its corresponding
                      destination function in isolation using the rules described above.
                      The individual values are then applied as a list to produce
                      resulting transform value.
                    </li>
                  </ul>
                </li>
                <li>
                  Otherwise:
                  <ul>
                    <li>
                      The transform function lists are each converted into the
                      equivalent matrix3d value and animation proceeds using the rule
                      for a single function above.
                    </li>
                  </ul>
                </li>
              </ul>

              <p>
                In some cases, an animation might cause a transformation matrix to
                be singular or non-invertible. For example, an animation in which
                scale moves from 1 to -1. At the time when the matrix is in such 
                a state, the transformed element is not rendered.
              </p>

              <h2 id="matrix-decomposition">
                Matrix Decomposition for Animation
              </h2>

              <p>
                When interpolating between 2 matrices, each is decomposed into the
                corresponding translation, rotation, scale, skew and perspective
                values. Not all matrices can be accurately described by these values.
                Those that can't are decomposed into the most accurate representation
                possible, using the technique below. This technique is taken from the
                "unmatrix" method in "Graphics Gems II, edited by Jim Arvo".
                The pseudocode below works on a 4x4 homogeneous matrix.
              </p>

              <h3 id="unmatrix">Unmatrix</h3>
              <pre>
          Input:  matrix      ; a 4x4 matrix
          Output: translation ; a 3 component vector
                  rotation    ; Euler angles, represented as a 3 component vector
                  scale       ; a 3 component vector
                  skew        ; skew factors XY,XZ,YZ represented as a 3 component vector
                  perspective ; a 4 component vector
          Returns false if the matrix cannot be decomposed, true if it can

          Supporting functions (point is a 3 component vector, matrix is a 4x4 matrix):
            double  determinant(matrix)         returns the 4x4 determinant of the matrix
            matrix inverse(matrix)              returns the inverse of the passed matrix
            matrix transpose(matrix)            returns the transpose of the passed matrix
            point  multVecMatrix(point, matrix) multiplies the passed point by the passed matrix 
                                                and returns the transformed point
            double  length(point)               returns the length of the passed vector
            point  normalize(point)             normalizes the length of the passed point to 1
            double  dot(point, point)           returns the dot product of the passed points
            double  cos(double)                 returns the cosine of the passed angle in radians
            double  asin(double)                returns the arcsine in radians of the passed value
            double  atan2(double y, double x)   returns the principal value of the arc tangent of 
                                                y/x, using the signs of both arguments to determine 
                                                the quadrant of the return value

          Decomposition also makes use of the following function:
            point combine(point a, point b, double ascl, double bscl)
                result[0] = (ascl * a[0]) + (bscl * b[0])
                result[1] = (ascl * a[1]) + (bscl * b[1])
                result[2] = (ascl * a[2]) + (bscl * b[2])
                return result

          // Normalize the matrix.
          if (matrix[3][3] == 0)
              return false

          for (i = 0; i < 4; i++)
              for (j = 0; j < 4; j++)
                  matrix[i][j] /= matrix[3][3]

          // perspectiveMatrix is used to solve for perspective, but it also provides
          // an easy way to test for singularity of the upper 3x3 component.
          perspectiveMatrix = matrix

          for (i = 0; i < 3; i++)
              perspectiveMatrix[i][3] = 0

          perspectiveMatrix[3][3] = 1

          if (determinant(perspectiveMatrix) == 0)
              return false

          // First, isolate perspective.
          if (matrix[0][3] != 0 || matrix[1][3] != 0 || matrix[2][3] != 0)
              // rightHandSide is the right hand side of the equation.
              rightHandSide[0] = matrix[0][3];
              rightHandSide[1] = matrix[1][3];
              rightHandSide[2] = matrix[2][3];
              rightHandSide[3] = matrix[3][3];

              // Solve the equation by inverting perspectiveMatrix and multiplying
              // rightHandSide by the inverse.
              inversePerspectiveMatrix = inverse(perspectiveMatrix)
              transposedInversePerspectiveMatrix = transposeMatrix4(inversePerspectiveMatrix)
              perspective = multVecMatrix(rightHandSide, transposedInversePerspectiveMatrix)

               // Clear the perspective partition
              matrix[0][3] = matrix[1][3] = matrix[2][3] = 0
              matrix[3][3] = 1
          else
              // No perspective.
              perspective[0] = perspective[1] = perspective[2] = 0
              perspective[3] = 1

          // Next take care of translation
          translate[0] = matrix[3][0]
          matrix[3][0] = 0
          translate[1] = matrix[3][1]
          matrix[3][1] = 0
          translate[2] = matrix[3][2]
          matrix[3][2] = 0

          // Now get scale and shear. 'row' is a 3 element array of 3 component vectors
          for (i = 0; i < 3; i++)
              row[i][0] = matrix[i][0]
              row[i][1] = matrix[i][1]
              row[i][2] = matrix[i][2]

          // Compute X scale factor and normalize first row.
          scale[0] = length(row[0])
          row[0] = normalize(row[0])

          // Compute XY shear factor and make 2nd row orthogonal to 1st.
          skew[0] = dot(row[0], row[1])
          row[1] = combine(row[1], row[0], 1.0, -skew[0])

          // Now, compute Y scale and normalize 2nd row.
          scale[1] = length(row[1])
          row[1] = normalize(row[1])
          skew[0] /= scale[1];

          // Compute XZ and YZ shears, orthogonalize 3rd row
          skew[1] = dot(row[0], row[2])
          row[2] = combine(row[2], row[0], 1.0, -skew[1])
          skew[2] = dot(row[1], row[2])
          row[2] = combine(row[2], row[1], 1.0, -skew[2])

          // Next, get Z scale and normalize 3rd row.
          scale[2] = length(row[2])
          row[2] = normalize(row[2])
          skew[1] /= scale[2]
          skew[2] /= scale[2]

          // At this point, the matrix (in rows) is orthonormal.
          // Check for a coordinate system flip.  If the determinant
          // is -1, then negate the matrix and the scaling factors.
          pdum3 = cross(row[1], row[2])
          if (dot(row[0], pdum3) < 0)
              for (i = 0; i < 3; i++) {
                  scale[0] *= -1;
                  row[i][0] *= -1
                  row[i][1] *= -1
                  row[i][2] *= -1

          // Now, get the rotations ou
          rotate[1] = asin(-row[0][2]);
          if (cos(rotate[1]) != 0)
             rotate[0] = atan2(row[1][2], row[2][2]);
             rotate[2] = atan2(row[0][1], row[0][0]);
          else
             rotate[0] = atan2(-row[2][0], row[1][1]);
             rotate[2] = 0;

          return true;</pre>

              <h3>Animating the components</h3>
              <p>
                  Once decomposed, each component of each returned value of the source matrix is linearly interpolated 
                  with the corresponding component of the destination matrix. For instance, the translate[0] and
                  translate[1] values are interpolated numerically, and the result is used to set the 
                  translation of the animating element. 
              </p>
              <h3>Recomposing the matrix</h3>
              <p><em>This section is not normative.</em></p>
              <p>
                  After interpolation the resulting values are used to position the element. One way to use these values
                  is to recompose them into a 4x4 matrix. This can be done using the Transformation Functions of the 
                  <em>transform</em> property. This can be done by the following pseudo code. The
                  values passed in are the output of the Unmatrix function above:
              </p>
              <pre>
          matrix3d(1,0,0,0, 0,1,0,0, 0,0,1,0, perspective[0], perspective[1], perspective[2], perspective[3])
          translate3d(translation[0], translation[1], translation[2])
          rotateX(rotation[0]) rotateY(rotation[1]) rotateZ(rotation[2])
          matrix3d(1,0,0,0, 0,1,0,0, 0,skew[2],1,0, 0,0,0,1)
          matrix3d(1,0,0,0, 0,1,0,0, skew[1],0,1,0, 0,0,0,1)
          matrix3d(1,0,0,0, skew[0],1,0,0, 0,0,1,0, 0,0,0,1)
          scale3d(scale[0], scale[1], scale[2])</pre>
          
              <h2 id="mathematical-description">
                Mathematical Description of Transformation Functions
              </h2>
              <p>
                Mathematically, all transformation functions can be represented as 4x4 transformation matrices of the following form:
              </p>
              <img src="4x4matrix.png" title="\begin{bmatrix} m11 & m21 & m31 & m41 \\ m12 & m22 & m32 & m42 \\ m13 & m23 & m33 & m43 \\ m14 & m24 & m34 & m44 \end{bmatrix}" width="222" height="106">

              <ul>
                <li id="MatrixDefined">
                  <p>
                    A 2D 3x2 matrix with six parameters <em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>, <em>e</em> and <em>f</em> is equivalent to to the matrix:
                  </p>
                  <img src="matrix.png" title="\begin{bmatrix} a & c & 0 & e \\ b & d & 0 & f \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="108" height="106">
                </li>
                <li id="TranslateDefined">
                  <p>
                    A 2D translation with the parameters <em>tx</em> and <em>ty</em> is equivalent to a <a href="#Translate3dDefined">3D translation</a> where <em>tz</em> has zero as a value.
                  </p>
                </li>
                <li id="ScaleDefined">
                  <p>
                    A 2D scaling with the parameters <em>sx</em> and <em>sy</em> is equivalent to a <a href="#Scale3dDefined">3D scale</a> where <em>sz</em> has one as a value.
                  </p>
                </li>
                <li id="RotateDefined">
                  <p>
                    A 2D rotation with the parameter <em>alpha</em> is equivalent to a <a href="#RotateZDefined">rotation around the Z axis</a>.
                  </p>
                </li>
                <li id="SkewDefined">
                  <p>
                    A 2D skew transformation with the parameters <em>alpha</em> and <em>beta</em> is equivalent to the matrix:
                  </p>
                  <img src="skew.png" title="\begin{bmatrix} 1 & \tan(\alpha) & 0 & 0 \\ \tan(\beta) & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="205" height="106">
                </li>
                <li id="Translate3dDefined">
                  <p>
                    A 3D translation with the parameters <em>tx</em>, <em>ty</em> and <em>tz</em> is equivalent to the matrix:
                  </p>
                  <img src="translate3d.png" title="\begin{bmatrix} 1 & 0 & 0 & tx \\ 0 & 1 & 0 & ty \\ 0 & 0 & 1 & tz \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="114" height="106">
                </li>      
                <li id="Scale3dDefined">
                  <p>
                    A 3D scaling with the parameters <em>sx</em>, <em>sy</em> and <em>sz</em> is equivalent to the matrix:
                  </p>
                  <img src="scale3d.png" title="\begin{bmatrix} sx & 0 & 0 & 0 \\ 0 & sy & 0 & 0 \\ 0 & 0 & sz & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="137" height="106">
                </li>
                <li id="Rotate3dDefined">
                  <p>
                    A 3D rotation with the vector [x,y,z] and the parameter <em>alpha</em> is equivalent to the matrix:
                  </p>
                  <img src="rotate3dmatrix.png" title="\begin{bmatrix} 1 - 2 \cdot (y^2 + z^2) \cdot sq & 2 \cdot (x \cdot y \cdot sq - z \cdot sc) & 2 \cdot (x \cdot z \cdot sq + y \cdot sc) & 0 \\ 2 \cdot (x \cdot y \cdot sq + z \cdot sc) & 1 - 2 \cdot (x^2 + z^2) \cdot sq & 2 \cdot (y \cdot z \cdot sq - x \cdot sc) & 0 \\ 2 \cdot (x \cdot z \cdot sq - y \cdot sc) & 2 \cdot (y \cdot z \cdot sq + x \cdot sc) & 1 - 2 \cdot (x^2 + y^2) \cdot sq & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="647" height="106">
                  <p>
                    where:
                  </p>
                  <img src="rotate3dvariables.png" title="\newline sc = \sin (\alpha/2) \cdot \cos (\alpha/2) \newline sq = \sin^2 (\alpha/2)" width="221" height="50">
                </li>
                <li id="RotateXDefined">
                  <p>
                    A 3D rotation about the X axis with the parameter <em>alpha</em> is equivalent to the matrix:
                  </p>
                  <img src="rotateX.png" title="\begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & \cos(\alpha) & -\sin(\alpha) & 0 \\ 0 & \sin(\alpha) & \cos(\alpha) & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="220" height="106">
                </li>
                <li id="RotateYDefined">
                  <p>
                    A 3D rotation about the Y axis with the parameter <em>alpha</em> is equivalent to the matrix:
                  </p>
                  <img src="rotateY.png" title="\begin{bmatrix} \cos(\alpha) & 0 & \sin(\alpha) & 0 \\ 0 & 1 & 0 & 0 \\ -\sin(\alpha) & 0 & \cos(\alpha) & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="220" height="106">
                </li>
                <li id="RotateZDefined">
                  <p>
                    A 3D rotation about the Z axis with the parameter <em>alpha</em> is equivalent to the matrix:
                  </p>
                  <img src="rotateZ.png" title="\begin{bmatrix} \cos(\alpha) & -\sin(\alpha) & 0 & 0 \\ \sin(\alpha) & \cos(\alpha) & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="220" height="106">
                </li>
                <li id="PerspectiveDefined">
                  <p>
                    A perspective projection matrix with the parameter <em>d</em> is equivalent to the matrix:
                  </p>
                  <img src="perspective.png" title="\begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & -1/d & 1 \end{bmatrix}" width="143" height="106">
                </li>
              </ul>


        <h2>References</h2>

        <h3 class="no-num">Normative references</h3>
        <!--normative-->

        <h3 class="no-num">Other references</h3>
        <!--informative-->



        <h2 class="no-num">Property index</h2>
        <!-- properties -->



        <h2 class="no-num" id="index">Index</h2>
        <!--index-->

  </body>
</html>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-declaration:"~/SGML/HTML4.decl"
sgml-default-doctype-name:"html"
sgml-minimize-attributes:t
sgml-nofill-elements:("pre" "style" "br")
sgml-live-element-indicator:t
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:t
sgml-general-insert-case:lower
sgml-always-quote-attributes:t
sgml-indent-step:nil
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
 
