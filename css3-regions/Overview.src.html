<!doctype html public '-//W3C//DTD HTML 4.01//EN'
  'http://www.w3.org/TR/html4/strict.dtd'>
 
<html dir="ltr" lang="en">
    <head profile="http://www.w3.org/2006/03/hcard">
	    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    	<title>CSS Regions Module</title>
    
	    <link href="http://dev.w3.org/csswg/default.css" rel="stylesheet" type="text/css" />
	    <link href="http://www.w3.org/StyleSheets/TR/W3C-ED.css" rel="Stylesheet" type="text/css" /> 
    </head>
    
    <body>
        <div class="head">
        	<!--begin-logo-->
            <p><a href="http://www.w3.org/"><img alt=W3C height=48 src="http://www.w3.org/Icons/w3c_home" width=72></a> 
            <!--end-logo-->
                
            <h1>CSS Regions Module</h1>
            <h2 class="no-num no-toc" id="longstatus-date">Editor's Draft [DATE]</h2>
            <dl>
                <dt>This version:</dt>
                <dd><a href="[VERSION]"> 
                    http://www.w3.org/csswg/css3-regions</a>
                <dt>Latest version:</dt>
                <dd><a href="http://www.w3.org/TR/css3-regions"> 
                    http://www.w3.org/csswg/css3-regions</a>
                <dt>Previous version:</dt>
                <dd>none</a>

                <dt>Editors:</dt>
                <dd class="vcard"><span class="fn">Alexandru Chiculita</span>, <span class="org">Adobe Systems, Inc.</span>, <span class="email">achicu@adobe.com</span></dd>
                <dd class="vcard"><span class="fn">Andrei Bucur</span>, <span class="org">Adobe Systems, Inc.</span>, <span class="email">abucur@adobe.com</span></dd>
                <dd class="vcard"><span class="fn">Mihnea Ovidenie</span>, <span class="org">Adobe Systems, Inc.</span>, <span class="email">mihnea@adobe.com</span></dd>
                <dd class="vcard"><span class="fn">Peter Sorotokin</span>, <span class="org">Adobe Systems, Inc.</span>, <span class="email">psorotok@adobe.com</span></dd>
                <dd class="vcard"><span class="fn">Virgil Palanciuc</span>, <span class="org">Adobe Systems, Inc.</span>, <span class="email">virgilp@adobe.com</span></dd>
                <dd class="vcard"><span class="fn">Arno Gourdol</span>, <span class="org">Adobe Systems, Inc.</span>, <span class="email">agourdol@adobe.com</span></dd>
            </dl>

            <!--begin-copyright--> 
            <!--end-copyright-->

            <hr title="Separator for header" />
        </div>
        
        <h2 class="no-num no-toc" id="abstract">Abstract</h2>
        
		<p>This document defines a set of features intended to provide rich layout capabilities to CSS, including the ability to define containers using a CSS-based syntax (slots), flow text across multiple containers (regions), and specify areas of these containers that should be avoided for the purpose of text layout (exclusions).</p>
		
		<p><em>
			These three key concepts (slots, regions and exclusions), could be considered independently of each other. For example, exclusions could be applied to other elements, such as the Grid Cells of the css-grid-align proposal. Likewise, slots could be used for purposes other than to flow text into. We would welcome editorial feedback regarding the disposition of these proposals, whether they should be made into distinct modules, integrated into existing modules, or kept together as one module, which is the approach we have followed for now.
		</em></p>
		

        <h2 class="no-num no-toc" id="status">Status of this document</h2>
        <!--begin-status--> 
	  <p><em>This section describes the status of this document at the time of
	   its publication. Other documents may supersede this document. A list of
	   current W3C publications and the latest revision of this technical report
	   can be found in the <a href="http://www.w3.org/TR/">W3C technical reports
	   index at http://www.w3.org/TR/.</a></em> 

		<p>This is a public copy of the editors' draft. It is provided for discussion only and may change at any moment. Its publication here does not imply endorsement of its contents by W3C. Don't cite this document other than as work in progress.</p>
		
		<p>The archived public mailing list www-style@w3.org is preferred for discussion of this specification. When sending e-mail, please put the text "css3-regions" in the subject, preferably like this: "[css3-regions] …summary of comment…"</p>
		
		<p>This draft is related to the drafts about Grid Layout <a href='#CSS3GRID'>[CSS3GRID]</a>, Flexible Box Layout <a href='#CSS3FLEXBOX'>[CSS3FLEXBOX]</a>, Multi-column Layout <a hreg='#CSSMULTICOL'>[CSSMULTICOL]</a> and Template Layout <a href='#CSSTEMPLATELAYOUT'>[CSSTEMPLATELAYOUT]</a>.</p>
		
		
        <!--end-status-->
        
        <h2 class="no-num no-toc" id="contents">Table of contents</h2>
        <!--begin-toc--> 
        <!--end-toc-->

        <h2 id="slot-abstract">Slots: Introduction</h2>

		        <p>The following sections define a way to create display elements using only CSS stylesheets. The feature is intended to be used with other layout modules like Grid Layout <a href='#CSS3GRID'>[CSS3GRID]</a>, Template Layout <a href='#CSSTEMPLATELAYOUT'>[CSSTEMPLATELAYOUT]</a> or Flexible Box Layout <a href='#CSS3FLEXBOX'>[CSS3FLEXBOX]</a> and helps keep the separation between presentation and structural markup.</p>

		        <p>The new concept is designed to integrate with the regions that are introduced later. Regions allow any block element to become a container that will be filled with text and for text to flow from one column of text to another. With slots, CSS rules can be used to create new regions without corresponding HTML markup. When slots are combined with media-queries, designers can define presentations for devices with different resolutions.</p>


		        <h2 id="slot-syntax">Slot Syntax</h2>

				<pre>
		[&lt;CSS selector&gt]::slot([ident]) { };</pre>

		        <h2 id="slot-description">Description</h2>

		        <p>The <code>::slot()</code> pseudo-element creates CSS slot elements as children of the elements matching the <code>&lt;CSS selector&gr;</code>. The new elements are inserted in the document tree, meaning that CSS selectors like <code>body > *</code> or <code>p + p</code> will match slot elements added using the <code>::slot()</code> pseudo-element. However, scripting will not be able to query the slot elements, meaning that properties like <code>firstChild</code>, <code>nextSibiling</code> or <code>querySelector</code> will not return slot elements. Moreover, no DOM events are triggered when new slots are created or destroyed.</p>
		        <br />
		        <p>There are several reasons to avoid exposing CSS elements through scripting:</p>

		        <ul>
		        	<li>Slots are designed to help designers keep the presentation layer inside CSS and avoid using scripting or HTML markup to define how parts of the design look like.</li>
		            <li>If a script needs to create an element, DOM already has enough methods to create one.</li>
		            <li>Any element has a state represented by CSS rules and the document tree. That state can be queried using document tree APIs. Because of the dynamic nature of a slot element, the state can only be defined using CSS.</li>
		        </ul>

		        <p>Z-index can be used to define a different child ordering for rendering. However, because layout doesn't take into account the z-index property (e.g. floats require different position in the document tree), the <code>::slot()</code> syntax can also place the new element in a specific location in the document tree by using combinations of pseudo selectors like <code>':after'</code>, <code>':before'</code>, <code>':nth-child'</code> in the CSS selector.</p>

		        <p>If the <strong>CSS selector has no matching element</strong>, the rule will be ignored until a matching element becomes available.</p>

		        <p>If no CSS selector is specified in the <code>::slot()</code> rule, the element will be created as a root element. When used in conjunction with the 'page' property, the element will be created only when the specified page is used.</p>

		        <p>Specifying an identifier makes it easier to reference the slot in other CSS selectors. The specified <code>'ident'</code> can also take part of any CSS selector by using the '%' prefix, so that one could define styles and new child slots for a specific slot. Example:</p>

		        <div class="example">
		        	<p>Create 'slot_name' as a child of body element and then two nested anonymous slots as children of 'slot_name' block.</p>
		            <pre>
		&lt;style&gt;
			body::slot(slot_name) { };
			%slot_name::slot() { content: 'first child slot'; }
			%slot_name::slot() { content: 'second child slot'; }
		&lt;/style&gt;
					</pre>
		        </div>

		        <p>CSS Slot elements have several advantages over DOM block elements:</p>
				<ol>

		            <li>They can be created using only CSS rules and are compatible with the Media Queries module.</li>
					<li>They can be used with other layout module (e.g. Flex and Grid).</li>
					<li>They are not visible from scripting and can only be changed from scripting by changing the CSS style-sheets rules.
			            <ul>
		                    <li>By not exposing the slot elements to scripting, they can be recreated on the fly without keeping track of the state of the element. </li>
		                    <li>When using a pseudo-element like <code>':hover'</code> that has a small life-cycle, if a script changes the content of a dynamic slot element, the content will be lost when it is recreated. </li>
		                    <li>Multiple slots can be created because of CSS selectors that match more elements and it becomes difficult to track slot changes from scripting.</li>
		                </ul>
		            </li>
		        </ol>

		        <h2 id="slot-examples">Examples</h2>

		        <div class="example">
			        <p><strong>Create a block element using only CSS</strong></p>
		            <pre>
		&lt;style&gt;
			body::slot(element1) {
				content: "CSS Paragraph";
			}
		&lt;/style&gt;
		&lt;body&gt;
			&lt;p&gt;First paragraph.&lt;/p&gt;
		&lt;/body&gt;</pre>

		        <p>The outpul will be</p>

		        <pre>
		First paragraph
		CSS paragraph</pre>

				</div>

		        <div class="example">
			        <p><strong>Add the CSS slot element before the contents of the body</strong></p>
		            <pre>
		&lt;style&gt;
			body:before ::slot(element1) {
				content: "CSS Paragraph";
			}
		&lt;/style&gt;
		&lt;body&gt;
			&lt;p&gt;First paragraph&lt;/p&gt;
		&lt;/body&gt;</pre>

		        <p>The outpul will be</p>

		        <pre>
		CSS paragraph
		First paragraph</pre>

				</div>

		        <div class="example">
			        <p><strong>Add the CSS Slot element after the third <code>'p'</code> element</strong></p>

		            <pre>
		&lt;style&gt;
			body &gt; p:nth-child(3) ::slot(element1) {
				content: "CSS Paragraph";
			}
		&lt;/style&gt;
		&lt;body&gt;
			&lt;p&gt;First paragraph&lt;/p&gt;
			&lt;p&gt;Second paragraph&lt;/p&gt;
			&lt;p&gt;Third paragraph&lt;/p&gt;
			&lt;p&gt;Fourth paragraph&lt;/p&gt;
		&lt;/body&gt;
		            </pre>

		            <p>The output will be</p>

		            <pre>
		First paragraph.
		Second paragraph.
		Third paragraph.
		CSS Paragraph.
		Fourth paragraph.</pre>

		        </div>

		        <p><strong>Note:</strong> Examples 2, 3 and 4 can actually be done today using ':after' and ':before' pseudo-selectors. However, stacking multiple elements cannot be done using standard pseudo-selectors since ':before' and ':after' are able to create only one item.</p>

		        <div class="example">
		        <p><strong>Add multiple CSS slot elements</strong></p>

		        <pre>
		&lt;style&gt;
			body::slot(element1) { content: "box one" };
			body::slot(element2) { content: "box two" };
			body::slot(element3) { content: "box three"};

		    %element1, %element2, %element3 {
				float: left;
				width: 100px;
				height: 100px;
			}
		&lt;/style&gt;
		&lt;body&gt;
			&lt;p&gt;First paragraph&lt;/p&gt;
		&lt;/body&gt;
		            </pre>

		            <p>The output will be</p>

		            <pre>
		First paragraph.
		box one
		box two
		box three</pre>
		        </div>

		        <div class="example">
		        	<p><strong>Use Flex Box Layout Module to lay out the CSS generated slots</strong></p>
		            <pre>
		&lt;style&gt;
		    body::slot(page1) {
		        /* layout as a flexible box */
		        display: box;
		    }

		    body %page1 ::slot(column1) { }
		    body %page1 ::slot(column2) { }

		    %column1, %column2 {
		        /* both columns are flexible */
		        box-flex: 1.0;
		    }
		&lt;/style&gt;
		            </pre>
		        </div>

				<div class="example">

		        <p><strong>Adding a new CSS Slot &lt;li&gt; item every other 2 DOM defined &lt;li&gt; items</strong></p>

		        <pre>
		&lt;style&gt;
			ul &gt; *:nth-child(2n):after ::slot(new_element) {
				display: list-item;
				content: "new element";
			}

			%new_element:first-of-type { 
				// make only the first one use bold
				font-weight: bold;
			}
		&lt;/style&gt;
		&lt;ul&gt;
		    &lt;li&gt;1&lt;/li&gt;
		    &lt;li&gt;2&lt;/li&gt;
		    &lt;li&gt;3&lt;/li&gt;
		    &lt;li&gt;4&lt;/li&gt;
		    &lt;li&gt;5&lt;/li&gt;
		&lt;/ul&gt;</pre>

		        <p>Output will be</p>
		        <ul>
		            <li>1</li>
		            <li>2</li>
		            <li><strong>new element</strong></li>
		            <li>3</li>
		            <li>4</li>
		            <li>new element</li>
		            <li>5</li>
		        </ul>

		        </div>

		        <h2 id="slot-regions">Using Slots with Regions</h2>

		        <p>Slots provide a convenient way to define containers in which to flow text using the Regions defined below, without having to use HTML or other structural markup to create the containers. This allows a clean separation of the presentation and the structural markup. For example, it becomes possible to define different arrangements of columns in which the text is flowed using media-queries for different classes of devices.</p>


			<p>Other CSS modules related to layout, such as Flex Box or Grid can also be used to define containers in which text is flowed. However, a consistent way to define Slots using CSS across modules could be beneficial. <em>In that context, consideration should be given whether separating Slots in their own module, or incorporating them as part of another module would be a valuable approach.</p>

		        <div class="example">
		        	<p>Creates a multi-column layout using other layout modules like Flex Box or Grid and concepts from CSS Regions module and CSS Paged Media Module. Here we combine the <code>@page</code> rule with the "%" syntax to create page-master like templates for specific pages of an article. The whole example can be wrapped inside a media query, e.g. one that targets a specific width/height aspect ratio. The 'page' property below forces the '%' syntax create the element on a specific page.</p>

		            <p>In this example the first page will always be created, because the 'body' content has to be filled somewhere. At that moment the CSS Slot %first_page_template contains two CSS slot columns (%column1 and %column2). The "article_body" flow thread will be filled inside both columns. If after filling the columns, the flow thread 'article_body' still has overflow content, a new page is instantiated. The process will stop when all the content is laid out or there is no other way to fill the remaining content.</p>

		            <pre>
		&lt;style&gt;
			body {
				/* content of body flows into article_body flow thread */
				flow: into(article_body);
			}

			body img#side_float {
				/* take the image outside the body flow */
				flow: into(article_side_image);
			}

			/* associate names to pages using @page rule + pseudo selectors */
			@page first_page:first {
			}

			@page second_page:nth-child(1) {
			}

			@page third_page:nth-child(2) {
			}

			/* Selected when nothing matches before it */
			@page overflow_page {
			}

			/* because no selector is preceding the % syntax, the Slot element will be created as a sibling of body */
			::slot(first_page_template) { }

			%first_page_template ::slot(column1) { };
			%first_page_template ::slot(column2) { };

			::slot(second_page_template) { }
			%second_page_template ::slot(column1) { }

			%first_page_template {
				display: box; /* use any other layout method here (ex. grid, templates, table) */
				page: first_page; /* limit the generated element to the first-page */
			}

			/*  Using a simple syntax makes it easy to reference the element in other selectors. 
				The following selector will create a new element called "column1" inside the 
				"first_page_template" element created earlier */

			%first_page_template %column1 {
				content-order: 2; /* column1 appears on the left, but the designer wants the text flowed in a different order */
				content: from(article_body);
			}

			%first_page_template %column2 {
				content-order: 1;
				content: from(article_body);
			}

			%first_page_template %side_image {
				position: absolute;
				left: 5gr;
				top: 4gr;
				width: 2gr;
				content: from(article_side_image);
			}

			%second_page_template {
				display: box;
				page: second_page;
			}

			%second_page_template %column1 {
				content: from(article_body);
			}

			/* %elements can be references as usual elements, just that they are prefixed with % */
			%column1, %column2 {
				/* add properties common to all columns across all pages
				the properties defined here apply only to the boxes that
				define the columns, and not to the content displayed in them */
				border: 1px solid red;
			}

			%column1 {
				/* assign a different styling for all the first columns across all pages */
				content-styling: first_column_on_page;
			}

			p:style(first_column_on_page) {
				/* Make only the paragraphs that are displayed 
				inside the first column use different font size. */
				font-size: 15px;
			}
		&lt;/style&gt;

		&lt;body&gt;
			&lt;p&gt;
				The text will be displayed across column 1 and column 2
				&lt;img id="side_float" src="image.jpg" title="The image will flow into %side_image box" /&gt;
			&lt;/p&gt;
		&lt;/body&gt;</pre>

		        </div>

		        <h2 id="slot-gridcells">Comparison with grid cells</h2>

		        <p>The main difference is that text threading is separated from the layout itself, meaning that Grid cell names are only used for positioning while the 'content' property drives the threading as defined in the CSS Regions module. The <code>'::slot()'</code> notation can use the cell naming from the 'grid-cell' notation, so the positioning can still be done using the cell name.</p>

				<br />

		        <p><strong>Current syntax from Grids</strong></p>

		        <table>
			        <tr>
		        		<td style="vertical-align:top">
		                	<p>Existing examples from the Grid Alignment module:</p>
							<pre>
		&lt;style&gt;
			#grid {
				display: grid;
				grid-columns: 150px "cell-start" 1fr "cell-end";
				grid-rows: "cell-start" 50px 1fr 50px "cell-end";
			}

			#grid::grid-cell("cell") {
				grid-column: "cell-start" "cell-end";
				grid-row: "cell-start" "cell-end";
			}

			#item2 { grid-cell: "cell" }
			#item3 { grid-cell: "cell" }
		&lt;/style&gt;</pre>

						</td>
						<td style="vertical-align:top">
							<p>Equivalent markup using the template syntax from the grid alignment spec:</p>
							<pre>
		&lt;style&gt;
			#grid {
				display: grid;
				grid-template:	"ad"
						"bd"
						"cd";
				grid-columns: 150px 1fr;
				grid-rows: 50px 1fr 50px;
			}



			#item2 { grid-cell: "b" }
			#item3 { grid-cell: "b" }
		&lt;/style&gt;</pre>
						</td>
		    	    </tr>
		        </table>

		        <p><strong>New syntax using CSS Slots</strong></p>

		        <table>
			        <tr style="background-color:#EEE">
		        		<td style="vertical-align:top">
		                	<pre>
		&lt;style&gt;
			#grid {
				display: grid;
				grid-columns: 150px "cell-start" 1fr "cell-end";
				grid-rows: "cell-start" 50px 1fr 50px "cell-end";



			}

			#grid::slot(cell) {
				grid-column: "cell-start" "cell-end";
				grid-row: "cell-start" "cell-end";
				contents: from(cell_content_flow);
			}

			#item2, #item3 { flow: into(cell_content_flow); }
		&lt;/style&gt;</pre>

						</td>
						<td style="vertical-align:top">
							<pre>
		&lt;style&gt;
			#grid {
				display: grid;
				grid-template:	"ad"
						"bd"
						"cd";
				grid-columns: 150px 1fr;
				grid-rows: 50px 1fr 50px;
			}

			#grid::slot(b) { 


				contents: from(cell_content_flow); 
			}

			#item2, #item3 { flow: into(cell_content_flow); }
		&lt;/style&gt;</pre>
						</td>
		    	    </tr>
		        </table>

        <h2 id="regions-abstract">Regions: Introduction</h2>

        <p>The following sections define a set of features that will improve the way of flowing text into multiple containers (regions).>
                
        <p>A <strong>region</strong> is an element whose content is defined by CSS rules.</p>
                
        <p>Capturing in digital form the complex layouts of a typical magazine, newspaper, or textbook require capabilities beyond those possible with the existing CSS modules.</p>
	
	<p>This document describes how content creators can use some basic building blocks to express complex layouts using CSS. It does not aim to cover higher-level layout issues (e.g. allocating areas to fit all the content completely or placing areas on the page). These issues can be addressed by using either scripting or another CSS modules like CSS Grid, CSS Template Layout or Flexible Box Layout.</p>
        
        <p>With CSS Multi-column layouts, columns are all of the same dimensions and placed next to each other. However, for more complex layouts, content need to flow from one area of the page to next one without limitation of the area sizes and positions. For complex layouts, these areas need to be explicitly defined; in this document they are called regions. Regions are based on the rectangular geometry of the CSS box model.</p>
        
        <p>One other feature that is commonly found in complex layouts is region-based styling. Region-based styling allows styling to be assigned based on the content placement (e.g. in which region it falls), rather than structure (e.g. selectors). This can be seen as an extension of the CSS 2.1 <code>:first-line</code> pseudo-element.</p>
        
        <h2 id="regions-examples">Examples</h2>
        
        <div class="example">
        	<p>Flow content from one region to another, grid layout and CSS slots
http://www.w3.org/TR/css3-grid/</p>
        	<pre>
&lt;style&gt;
    body {
        flow: into(article_body);
    }
    
    body::slot(page1) {
        position: absolute;
    	// similar to column-count: 3 and gaps of 1em
    	grid-columns: * (1em *)[2];
    }
    
    body %page1 ::slot(column1), 
    body %page2 ::slot(column2), 
    body %page3 ::slot(column3) {
        width: 1gr;
        content: from(article_body);
    }
    
    %column1 { left: 0; }
    %column2 { left: 2gr; }
    %column3 { left: 4gr; }
&lt;/style&gt;

&lt;body&gt;
    &lt;p&gt;Text to be threaded comes here&lt;/p&gt;
&lt;/body&gt;</pre>
        </div>
        
        
        <div class="example">
        	<p>Same example using the new grid proposal and CSS slots (http://www.interoperabilitybridges.com/css3-grid-align/)</p>
        	<pre>
&lt;style&gt;
    body {
        flow: into(article_body);
    }
    
    body::slot(page1) {
        display: grid;
	    grid-columns: 1fr 1fr 1fr;
    	grid-rows: 1fr;
    }
    
    body %page1::slot(column1), 
    body %page1::slot(column2), 
    body %page1::slot(column3) {
        content: from(article_body);
    }
    
    %column1 { grid-column: 1; grid-row: 1; }
    %column2 { grid-column: 2; grid-row: 1; }
    %column3 { grid-column: 3; grid-row: 1; }
&lt;/style&gt;

&lt;body&gt;
    &lt;p&gt;Text to be threaded comes here&lt;/p&gt;
&lt;/body&gt;</pre>
        </div>
        
        <div class="example">
        	<p>Multiple flows - defining floating elements</p>
        	<pre>
&lt;style&gt;
    body {
        flow: into(article_body);
    }
    
    body img.floating_image {
        flow: into(article_side_image);
    }
    
    body::slot(page1) {
        display: box; // use any method here
    }
    
    %page1::slot(column1), 
    %page1::slot(column2) {
        content: from(article_body);
    }
    
    %page1::slot(side_box) {
	    content: from(article_side_image);
    }
&lt;/style&gt;

&lt;body&gt;
    &lt;p&gt;
    	Text to be threaded comes here
        &lt;img src="side_image.jpg" class="floating_image" /&gt;
    &lt;/p&gt;
&lt;/body&gt;</pre>
        </div>
        
        <h2 id="regions-properties">Properties</h2>
        
        <h3>The 'flow' property</h3>
        
        <p>The 'flow' property is used to assign an element to the flowing thread with the specified name. Elements that belong to a flowing thread are always displayed in the region marked for the same flowing thread (with the 'content' property). If no region with the specified flowing thread is available, the elements in the flowing thread are not displayed at all.</p>

		<p>Multiple flow threads can be created from nested elements. The content will not be duplicated across flow threads. A thread that uses a descendant element, will extract the content from a thread that uses an ancestor element as a source. See Example 3 above for details.</p>

		<p>Elements with a specified flow name will be taken out of the normal layout flow and rendered inside the associated regions. The 'flow' property does not affect CSS cascade and inheritance.</p>

		<p>If the 'display' property is set to 'none' then the 'flow' property will be ignored and the content will not take part in the layout process.</p>

		<p><strong>Note: </strong>All the elements participating inside a flow thread will be rendered as children of an anonymous block that spans across all the regions assigned to the specified thread. The elements flowed inside the same flow-thread are taken in the order they appear in the source page.</p>

		<p><var class="issue">We have considered also <code>float: into(article_body)</code>. Using flow seems to better capture the meaning.</var></p>
		        
        <table class="propdef">
            <tr>
                <th>Name:</th>
                <td><dfn id="flow">flow</dfn></td>
            </tr>
            <tr>
                <th>Value:</th>
                <td>none | into(&lt;name&gt;)</td>
            </tr>
            <tr>
                <th>Initial:</th>
                <td>none</td>
            </tr>
            <tr>
                <th>Applies to:</th>
                <td>any element</td>
            </tr>
            <tr>
                <th>Inherited:</th>
                <td>no</td>
			</tr>
            <tr>
                <th>Percentages:</th>
                <td>N/A</td>
            </tr>
            <tr>
                <th>Media:</th>
                <td>visual</td>
	        </tr>
            <tr>
                <th>Computed&nbsp;value:</th>
                <td>as specified</td>
            </tr>
        </table>
        
        <h3>The 'content' property</h3>
        
        <p>Assigns the region to display the contents of a specified flowing thread. The content that participates in the specified flowing thread will be laid out across all the regions in the same order as it appears in DOM.</p>

		<p>The content of region elements will be suppressed. It is recommended to use other layout methods like Flex, Grid or Template modules in conjunction with the new CSS Slots specification to dynamically create regions that can be based on media queries. By using the slots with the layout methods, one can achieve the CSS goal of separating the document presentation from the document content.</p>
        
        <table class="propdef">
            <tr>
                <th>Name:</th>
                <td><dfn id="content">content</dfn></td>
            </tr>
            <tr>
                <th>Value:</th>
                <td>from(&lt;name&gt;) | other values specified in CSS3</td>
            </tr>
            <tr>
                <th>Initial:</th>
                <td>none</td>
            </tr>
            <tr>
                <th>Applies to:</th>
                <td>any block element</td>
            </tr>
            <tr>
                <th>Inherited:</th>
                <td>no</td>
			</tr>
            <tr>
                <th>Percentages:</th>
                <td>N/A</td>
            </tr>
            <tr>
                <th>Media:</th>
                <td>visual</td>
	        </tr>
            <tr>
                <th>Computed&nbsp;value:</th>
                <td>as specified</td>
            </tr>
        </table>
        
        <h3>The 'content-order' property</h3>
        
        <p>Defines the order in which the content is flowed inside the regions. If region A has its 'content-order' lower than region B 'content-order', the content will flow in region A before region B (both regionA and regionB receive content from the same flowing thread).</p>

		<p>Negative values are allowed for this property.
By default all the regions will be sorted using DOM order.
Regions with equal values will be sorted using the order in the source DOM.
CSS Slots will be sorted using the order they were declared in the CSS stylesheet.</p>

		<table class="propdef">
            <tr>
                <th>Name:</th>
                <td><dfn id="content-order">content-order</dfn></td>
            </tr>
            <tr>
                <th>Value:</th>
                <td>&lt;integer&gt;</td>
            </tr>
            <tr>
                <th>Initial:</th>
                <td>none</td>
            </tr>
            <tr>
                <th>Applies to:</th>
                <td>any block element</td>
            </tr>
            <tr>
                <th>Inherited:</th>
                <td>no</td>
			</tr>
            <tr>
                <th>Percentages:</th>
                <td>N/A</td>
            </tr>
            <tr>
                <th>Media:</th>
                <td>visual</td>
	        </tr>
            <tr>
                <th>Computed&nbsp;value:</th>
                <td>as specified</td>
            </tr>
        </table>
		
        <h3>The 'content-style' property</h3>
        
        <p>The styling of the elements in the flow is determined, in general, by the same rules as for all other content. When the content is placed in the region, an additional higher-specificity styling can be applied only to the content. When content is flowed from one region to another, only the fragment of the content that is rendered inside the new region will be restyled using the new computed style.</p>

		<p>Using a new pseudo-selector 'style' keyword, you can define additional styling rules that will to be applied to the content falling into a specific region. The content laid out in the region is not inheriting properties from the region itself, but from the region styling associated with it.</p>
        
        <table class="propdef">
            <tr>
                <th>Name:</th>
                <td><dfn id="content-style">content-style</dfn></td>
            </tr>
            <tr>
                <th>Value:</th>
                <td>&lt;name&gt; | none</td>
            </tr>
            <tr>
                <th>Initial:</th>
                <td>none</td>
            </tr>
            <tr>
                <th>Applies to:</th>
                <td>any element</td>
            </tr>
            <tr>
                <th>Inherited:</th>
                <td>no</td>
			</tr>
            <tr>
                <th>Percentages:</th>
                <td>N/A</td>
            </tr>
            <tr>
                <th>Media:</th>
                <td>visual</td>
	        </tr>
            <tr>
                <th>Computed&nbsp;value:</th>
                <td>as specified</td>
            </tr>
        </table>
        
        <h4>Content style block syntax</h4>
        
        <pre>
    &lt;CSS selector&gt;::style(content_style_name) {
    ... CSS styling rules ...
    }
		</pre>
        
        <p>Regions can use the specified region styling by using the "content-style" property. The "content_style_name" is used to define a mapping between the regions and the styling rules that are to be applied to the content that flows into the region.</p>
        
        <p>The styling rules are only applied to the elements that belong to the region's thread and they are only active for the content that falls in the particular region to which they apply. The specificity of region styling rules is considered to be greater than all of the regular rules and also also greater than the inline rules (which come from style attribute).</p>
        
        <dl>
        	<dt>Only some of the CSS properties are available when styling the region:</dt>
            <dd>
                <ul>
                    <li>font properties</li>
                    <li>color properties</li>
                    <li>background properties</li>
                    <li>word-spacing</li>
                    <li>letter-spacing</li>
                    <li>text-decoration</li>
                    <li>vertical-align</li>
                    <li>text-transform</li>
                    <li>line-height</li>
                    <li>clear</li>
                </ul>
            </dd>
        </dl>
                
        <p><strong>Note:</strong> The above properties are similar to those available to first-line pseudo-selector.</p>
        
        <h3>Content-style for non-region elements</h3>

		<p>We can also extend 'content-styling' to non-region elements. It can help sand-boxing different states of a specific element: ex. <code>content-style: open, content-style: closed;</code></p>

		<pre>
    &lt;style&gt;
        /* create an element inside the "button" div, before any other element */
        .button &gt; *:before ::slot(left_image) {
            position: absolute;
        }
        
        .button %left_image:style(enabled) {
            background: url(enabled_button_icon.png);
        }
        
        .button %left_image:style(disabled) {
            background: url(disabled_button_icon.png);
        }
    &lt;/style&gt;
    
    &lt;div class=&quot;button&quot; style=&quot;content-style: disabled&quot;&gt;My Button&lt;/div&gt;</pre>

		<p>Moreover, styling can apply to @page rules. There should be a simple way to define the style for content depending on what page it is shown. The paged media already defines a way to change styling, but there's no way to select what elements on that page should be affected.</p>

		<pre>
    @page :first {
        content-style: for_first_page;
    }
    
    h1:style(for_first_page) {
        color: green;
    }
    
    p:style(for_first_page) {
        color: red;
    }</pre>
    
    	<h3>Region breaks</h2>
    
    	<p>Similar properties to the ones defined by the Paged Media module are used to define the breaks across multiple regions. Each region break ends layout in the current region block and causes remaining pieces of content from the flowing thread to be laid out in a new region block.</p>

		<p>When a region break splits a block, the block's bottom margins, borders, and padding have no visual effect where the split occurs; the block's background and left and right margins, border, and padding extend to the bottom of the region, onto the top of the subsequent region.</p>
    
        <table class="propdef">
            <tr>
                <th>Name:</th>
                <td><dfn id="region-break-before">region-break-before</dfn></td>
            </tr>
            <tr>
                <th>Value:</th>
                <td>auto | always | avoid</td>
            </tr>
            <tr>
                <th>Initial:</th>
                <td>auto</td>
            </tr>
            <tr>
                <th>Applies to:</th>
                <td>block elements, table rows</td>
            </tr>
            <tr>
                <th>Inherited:</th>
                <td>no</td>
            </tr>
            <tr>
                <th>Percentages:</th>
                <td>N/A</td>
            </tr>
            <tr>
                <th>Media:</th>
                <td>visual</td>
            </tr>
            <tr>
                <th>Computed&nbsp;value:</th>
                <td>as specified</td>
            </tr>
        </table>
        
        <table class="propdef">
            <tr>
                <th>Name:</th>
                <td><dfn id="region-break-after">region-break-after</dfn></td>
            </tr>
            <tr>
                <th>Value:</th>
                <td>auto | always | avoid</td>
            </tr>
            <tr>
                <th>Initial:</th>
                <td>auto</td>
            </tr>
            <tr>
                <th>Applies to:</th>
                <td>block elements, table rows</td>
            </tr>
            <tr>
                <th>Inherited:</th>
                <td>no</td>
            </tr>
            <tr>
                <th>Percentages:</th>
                <td>N/A</td>
            </tr>
            <tr>
                <th>Media:</th>
                <td>visual</td>
            </tr>
            <tr>
                <th>Computed&nbsp;value:</th>
                <td>as specified</td>
            </tr>
        </table>
        
        <table class="propdef">
            <tr>
                <th>Name:</th>
                <td><dfn id="region-break-inside">region-break-inside</dfn></td>
            </tr>
            <tr>
                <th>Value:</th>
                <td>auto | avoid</td>
            </tr>
            <tr>
                <th>Initial:</th>
                <td>auto</td>
            </tr>
            <tr>
                <th>Applies to:</th>
                <td>block elements, table rows</td>
            </tr>
            <tr>
                <th>Inherited:</th>
                <td>no</td>
            </tr>
            <tr>
                <th>Percentages:</th>
                <td>N/A</td>
            </tr>
            <tr>
                <th>Media:</th>
                <td>visual</td>
            </tr>
            <tr>
                <th>Computed&nbsp;value:</th>
                <td>as specified</td>
            </tr>
        </table>
        
        <dl>
        	<dt>auto</dt>
            <dd>Neither force nor forbid a page break before / after / inside the generated box.</dd>
        	<dt>always</dt>
            <dd>Always force a page break before / after the generated box.
</dd>
        	<dt>avoid</dt>
            <dd>Avoid a page break before / after / inside the generated box.
</dd>
        </dl>
        
        <p><strong>Note:</strong> When the 'avoid' value is used, regions may overflow. In that case the 'overflow' property specified on the region element should be used to determine how to render the overflow.</p>



        <h2 id="exclusions-abstract">Exclusions: Introduction</h2>
        
        <p>The sections below define features that allow text to wrap around and inside non-rectangular shapes. The term <strong>"exclusion shape"</strong> refers to the exterior of the shape that text wraps around and the term <strong>"content shape"</strong> refers to the interior of the shape that text wraps inside.</p>

		        <h3 id="background">Background</h3>

		        <p><em>This section is not normative.</em></p>

		        <p>Exclusions are arbitrary shapes that will be avoided by the user agent when laying out content. The exclusion shape of an element is generated from the element's 'wrap-shape' property. The exclusion area is computed relative to the content box of the element on which the exclusion is specified.</p>

		        <p>Exclusion shapes affect only the content outside the element on which the exclusion was defined. To clarify, the exclusion does not affect the element's children.</p>

		        <p>The 'wrap-shape-mode' property is used to enable the definition of exclusion 
		            shape. Setting 'wrap-shape-mode' to something other than 'none' will affect both 
		            exterior and interior element's content. It will make all the elements outside 
		            the element wrap around the shape defined by 'wrap-shape'. Moreover, the child 
		            elements will wrap inside the specified shape. There are two other properties 
		            that can be used in conjunction with the 'wrap-shape':
		            <ul>
		                <li><strong>'wrap-shape-padding'</strong>: contracts the boundary of the wrap shape to obtain a content shape</li>
		                <li><strong>'wrap-shape-margin'</strong>: expands the boundary of the wrap shape to obtain an exclusion shape</li>
		            </ul>
		        </p>

		        <p>By default the shape is defined by the content box of the element. The content 
		            shape will be intersected with the exclusion shape at the content-block coordinate 
		            space using exclusion shape projections. If multiple parent elements define content 
		            shapes, only the nearest one in the DOM tree is used to calculate the wrapping area.</p>

		        <p>Another property 'wrap-shape-order' describes the 
		            layer at which the exclusion works. An exclusion can affect all the elements 
		            with the 'wrap-shape-order' smaller or equal to its 'wrap-shape-order'. If not 
		            specified, the 'wrap-shape-order' has the default value of 0.</p>

		        <p>The 'wrap-shape-order' property was necessary to describe a sort of grouping 
		            between the elements affected by exclusion shapes. We wanted to avoid overloading 
		            the meaning of 'z-index' property (which is available only for elements with ''position'' 
		            property set) and also we wanted something more than just the DOM order.</p>
		        <p><span>	The &lsquo;wrap-shape-order&rsquo; property does not influence the positioning of DOM elements. </span><br></p>
		    <p>When laying out content, the user agent will compute a dependency graph for DOM elements that will take wrap shapes into account. The dependency graph will be computed based on the values of 'wrap-shape-order' property. For elements with equal 'wrap-shape-order' values, sorting is based on the order of the elements in DOM.</p>
		    <p>&nbsp;</p>

		<h2 id="properties">Properties</h2>

		<h3>The 'wrap-shape-mode' property</h3>

		        <p>By default the property has the value 'none' and the engine will not use the 
		            element as an text-wrapping exclusions for other elements. Setting the property 
		            to 'around', 'left', 'right', 'maximum' or 'top-bottom' will enable the 
		            exclusion text-wrapping features and the wrapping mode for the outside 
		            content. The element's inside content will always fill the content shape. </p>
		         <p>The element will be considered an exclusion for anything outside the element and a 
		            content shape for everything inside that element. By 'outside' we mean the elements in DOM that are not children of the element on which the wrap shape was defined. By 'inside' we mean the children of the element on which the wrap shape was defined. The default shape is the 
		            content box as defined by the CSS box model.</p>

		        <p>When the property is set to 'content' only the elements inside the element 
		            will wrap inside the content shape. 'content' is used to disable the 
		            exclusion shape while still keeping the content shape enabled.</p>

		        <p>The content shape does not affect the element's children with 'position' = 
		            fixed or absolute (and the children of these elements).</p>

		        <table class="propdef">
		            <tr>
		                <th>Name:</th>
		                <td><dfn id="wrap-shape-mode">wrap-shape-mode</dfn></td>
		            </tr>
		            <tr>
		                <th>Value:</th>
		                <td>none | around | left | right | maximum | top-bottom | content</td>
		            </tr>
		            <tr>
		                <th>Initial:</th>
		                <td>none</td>
		            </tr>
		            <tr>
		                <th>Applies to:</th>
		                <td>any block element</td>
		            </tr>
		            <tr>
		                <th>Inherited:</th>
		                <td>no</td>
					</tr>
		            <tr>
		                <th>Percentages:</th>
		                <td>N/A</td>
		            </tr>
		            <tr>
		                <th>Media:</th>
		                <td>visual</td>
			        </tr>
		            <tr>
		                <th>Computed&nbsp;value:</th>
		                <td>as specified</td>
		            </tr>
		        </table>


		        <p>
		            <ul>
		                <li><strong>none</strong>: Disables the text wrapping feature.</li>
		                <li><strong>around</strong>: Wrap the outside content on all sides of the exclusion (see the example 1).</li>
		                <li><strong>left</strong>: Wrap the outside content on the left side of the exclusion.</li>
		                <li><strong>right</strong>: Wrap the outside content on the right side of the exclusion.</li>
		                <li><strong>maximum</strong>: Wrap the outside content only in the segment (left/right) with the maximum size.</li>
		                <li><strong>top-bottom</strong>: Wrap the outside content on top and bottom of the exclusion.</li>
		                <li><strong>content</strong>: Do not wrap the outside content. Wrap only the inside content.</li>
		            </ul>
		        </p>

		        <table>
		            <tr>
		                <td><img src="images/wrap-shape-mode-around.jpg" alt="Example rendering for wrap-shape-mode: around" /></td>
		                <td><img src="images/wrap-shape-mode-content.jpg" alt="Example rendering for wrap-shape-mode: content" /></td>
		            </tr>
		            <tr>
		                <td><img src="images/wrap-shape-mode-left.jpg" alt="Example rendering for wrap-shape-mode: left" /></td>
		                <td><img src="images/wrap-shape-mode-right.jpg" alt="Example rendering for wrap-shape-mode: right" /></td>
		            </tr>
		            <tr>
		                <td><img src="images/wrap-shape-mode-max.jpg" alt="Example rendering for wrap-shape-mode: maximum" /></td>
		                <td><img src="images/wrap-shape-mode-top-bottom.jpg" alt="Example rendering for wrap-shape-mode: top-bottom" /></td>
		            </tr>
		        </table>

		        <div class="example">
		            <p>Define a circle as an exclusion shape. The center of the circle shape is 
		                computed as follows: cx = 50% from the div width, cy = 50% from the div height. 
		                The div has the id = "circle" and the center of the circle is calculated percent 
		                from the div box dimensions. The radius cannot be specified as percent, therefore 
		                is specified in units.</p>

		               	<pre>
			&lt;style&gt;
			#circle {
			  wrap-shape: circle(50%, 50%, 30px);
			  wrap-shape-margin: 10px;
			}
			&lt;/style&gt;

			&lt;div id="circle"&gt;
			&lt;img src="mycircle.png"/&gt;
			&lt;/div&gt;
			&lt;div&gt;Lorem ipsum&lt;/div&gt;</pre>

		            <p>It might be easier to just use the original image alpha channel to define the exclusion shape.</p>
		            <pre>
			&lt;style&gt;
			#circle {
			  background: url(mycircle.png);
			  wrap-shape-image: url(mycircle.png);
			  wrap-shape-margin: 10px;
			}
			&lt;/style&gt;

			&lt;div id="circle"&gt;&lt;/div&gt;
			&lt;div&gt;Lorem ipsum&lt;/div&gt;</pre>

		            <div class="figure"> 
		            	<p><img src="images/example1.jpg" alt="Text wrapping around a circle" /></p>
		                <p class=caption>The #circle DIV's shape is used as an exclusion for the region with content.
		                    Note: mycircle.png has a solid fill</p>
		            </div>
		        </div>

		        <h4>Combining exclusions</h4>

		        <p>There are cases when multiple exclusions with different 'left' or 'right' 
		            modes will overlap the same text lines. In that case the rules will still 
		            apply, meaning that overlapping lines will be skipped (see the image below for 
		            more details).</p>

		        <p><img src="images/wrap-shape-mode-combine.jpg" alt="Combining exclusions with left and right wrap modes" /></p>

		        <p>We thought about defining a value 'exclusion' ('no-content') for the 
		            'wrap-shape-mode' property. Such value would make the wrap shape as exclusion 
		            only, as opposed to content. However, we were unable to find a compelling 
		            reason/use case for such a value.</p>

		        <h3>The 'wrap-shape-order' property</h3>

		        <p>Exclusions will only affect the block elements that have an equal or smaller 
		            'wrap-shape-order' number. The values can be both positive and negative. The 
		            user agent will sort all the elements using the 'wrap-shape-order' property. The 
		            elements with a smaller order will wrap around the elements with bigger 
		            'wrap-shape-order'. Elements with equal 'wrap-shape-order' values will be sorted using the order in the source DOM.</p>

		        <p>When the 'wrap-shape-order' is set to inherit, the 'wrap-shape-order' takes the 
		            value of the parent element.</p>

		        <p>When the 'wrap-shape-order' is set to auto, the 'wrap-shape-order' is set to 0.</p>

		        <table class="propdef">
		            <tr>
		                <th>Name:</th>
		                <td><dfn id="wrap-shape-order">wrap-shape-order</dfn>
		            </td>
		            <tr>
		                <th>Value:</th>
		                <td><var>&lt;integer&gt;</var> | auto | inherit</td>
		            </tr>
		            <tr>
		                <th>Initial:</th>
		                <td>auto</td>
		            </tr>
		            <tr>
		                <th>Applies to:</th>
		                <td>any block element, exclusions</td>
		            </tr>
		            <tr>
		                <th>Inherited:</th>
		                <td>yes</td>
		            </tr>
		            <tr>
		                <th>Percentages:</th>
		                <td>N/A</td>
		            </tr>
		            <tr>
		                <th>Media:</th>
		                <td>visual</td>
		            </tr>
		            <tr>
		                <th>Computed&nbsp;value:</th>
		                <td>as specified</td>
		            </tr>
		        </table>

		        <h3>The 'wrap-shape' property</h3>

		        <p>Exclusion shape can get out of the content box of the element on which it is 
		            defined. In this case, the exclusion shape is not clipped to the margins of the 
		            element box.</p>

		        <p>As opposed to the exclusion shape, the content shape will be clipped by the 
		            content-box rectangle.</p>

		        <div class="example">
		            <p>Exclusion shape (and content shape) defined using a polygon</p>
		            <pre>wrap-shape: polygon(x1, y1, &hellip;, xn, yn);</pre>
		        </div>

		        <table class="propdef">
		            <tr>
		                <th>Name:</th>
		                <td><dfn id="wrap-shape">wrap-shape</dfn></td>
		            </tr>
		            <tr>
		                <th>Value:</th>
		                <td><var>&lt;shape&gt;</var></td>
		            </tr>
		            <tr>
		                <th>Initial:</th>
		                <td>EMPTY</td>
		            </tr>
		            <tr>
		                <th>Applies to:</th>
		                <td>any block element</td>
		            </tr>
		            <tr>
		                <th>Inherited:</th>
		                <td>no</td>
		            </tr>
		            <tr>
		                <th>Percentages:</th>
		                <td>relative to the element width or height</td>
		            </tr>
		            <tr>
		                <th>Media:</th>
		                <td>visual</td>
		            </tr>
		            <tr>
		                <th>Computed&nbsp;value:</th>
		                <td>the specified value</td>
		            </tr>
		        </table>

		        <h4>Shapes</h4>

		        <p>Shapes are used to describe the value of the 'wrap-shape' property. The 
		            'wrap-shape' property is used to define the boundary in which to flow content 
		            and also used to define the area to be avoided when laying out content. </p>

		        <p>The shape can be defined using SVG style basic shapes as defined by the SVG 
		            Shapes.</p>

		        <h4>Computing the shapes</h4>

		        <p>All the lengths can be expressed in percentages and are defined in the 
		            coordinate space of the element. Percentages will take into account the element 
		            width/height excluding any padding or margins. The (x,y) coordinates are 
		            relative to the block's content box.</p>

		        <p>When defining a polygon area using percentages, the content box of the 
		            element must always be fully known in advance.</p>

				<dl>
		            <dt>rect(x, y, width, height, [[rx], ry])</dt>

		            <dd>
		                <ul>
		                    <li><strong>x, y, width and height</strong> - define the bounding box of the rectangle</li>
		                    <li><strong>rx</strong> - For rounded rectangles, the x-axis radius of the ellipse used to round off the corners of the rectangle</li>
		                    <li><strong>ry</strong> - For rounded rectangles, the y-axis radius of the ellipse used to round off the corners of the rectangle</li>
		                </ul>
		            </dd>


		            <dt>circle(cx, cy, r)</dt>
		            <dd>
		                <ul>
		                    <li> <strong>cx</strong> - The x-axis coordinate of the center of the circle</li>
		                    <li> <strong>cy</strong> - The y-axis coordinate of the center of the circle</li>
		                    <li> <strong>r</strong> - The radius of the circle. Note: Cannot be expressed as a percentage.</li>
		                </ul>
		            </dd>

		            <dt>ellipse(cx, cy, rx, ry)</dt>
		            <dd>
		                <ul>
		                    <li> <strong>cx</strong> - The x-axis coordinate of the center of the ellipse</li>
		                    <li> <strong>cy</strong> - The y-axis coordinate of the center of the ellipse</li>
		                    <li> <strong>rx</strong> - The x-axis radius of the ellipse</li>
		                    <li> <strong>ry</strong> - The y-axis radius of the ellipse</li>
		                </ul>
					</dd>

		            <dt>polygon([fillRule], x1, y1 x2, y2 x3, y3 &hellip; xn, yn)</dt>
		            <dd>
		                <ul>
		                    <li><strong>fillRule</strong> - The filling rule used to determine the interior of the polygon. See fill-rule property in SVG for details. Possible values are nonzero or evenodd. Default value when omitted is nonzero.</li>
		                    <li> <strong>xi</strong> - The x-axis coordinate of the i-th vertex of the polygon</li>
		                    <li> <strong>yi</strong> - The y-axis coordinate of the i-th vertex of the polygon</li>
		                </ul>

		            	<p>If the polygon is not closed the user-agent will automatically add a new vertex 
		                	at the end.</p><br>
		            </dd>

		            <dt>path([fillRule], ...)</dt>

		            <dd>
		                <ul>
		                    <li><strong>fillRule</strong> - The filling rule used to determine the interior of the polygon. See fill-rule property in SVG for details. Possible values are nonzero or evenodd. Default value when omitted is nonzero.</li>
		                </ul>

		                <p> The content of the path() function will be parsed using SVG PathData
		                    notation.</p>
					</dd>

		         </dl>

		        <div class="example">
		            <pre>
			&lt;div id="circle" style="wrap-shape: circle(50%, 50%, 40px); width: 100px;
			height: 100px;"&gt;&lt;/div&gt;
					</pre>
		            <p>In this example, the actual position of the exclusion shape polygon is 
		                determined based on the position of the "circle" div element. </p>
		        </div>

		        <h3>Define exclusion using an image alpha channel: 'wrap-shape-image' property</h3>

		        <p>One can define an exclusion by specifying a source image whose alpha channel is 
		            used to compute the exclusion shape. As image, one can specify the same values 
		            as the ones used when defining the values for the 'background-image' property. </p>

		        <p>The exclusion shape is computed to be the path that encloses the area where the 
		            opacity of the specified image is greater than the 'wrap-shape-image-threshold' 
		            value. If the 'wrap-shape-image-threshold' is not specified, the default value 
		            to be considered is 50%.</p>

		        <p>Note: Images can also define cavities and text should wrap inside them. In order 
		            to avoid that, another exclusion element can be overlaid.</p>

		        <div class="example">
		            <p>Exclusion shape defined using the alpha channel of the specified 
		                image, opacity threshold 50%.</p>

		            <pre>
			&lt;style&gt;
			#id {
				wrap-shape-image: url(myimage.png);
			}
			&lt;/style&gt;
					</pre>
		        </div>

		        <table class="propdef">
		            <tr>
		                <th>Name:</th>
		                <td><dfn id="wrap-shape-image">wrap-shape-image</dfn></td>
		            </tr>
		            <tr>
		                <th>Value:</th>
		                <td>none | <var>&lt;url&gt;</var></td>
		            </tr>
		            <tr>
		                <th>Initial:</th>
		                <td>none</td>
		            </tr>
		            <tr>
		                <th>Applies to:</th>
		                <td>any block element</td>
		            </tr>
		            <tr>
		                <th>Inherited:</th>
		                <td>no</td>
		            </tr>
		            <tr>
		                <th>Percentages:</th>
		                <td>N/A</td>
		            </tr>
		            <tr>
		                <th>Media:</th>
		                <td>visual</td>
		            </tr>
		            <tr>
		                <th>Computed&nbsp;value:</th>
		                <td>the specified value</td>
		            </tr>
		        </table>

		        <h3>'wrap-shape-image-threshold' property</h3>

		        <p>Defines the alpha channel threshold used to define the shape using an image. The 
		            default is 50%, meaning that all the pixels that are more than 50% transparent 
		            define the path of the exclusion shape.</p>

		        <div class="example">
		            <p>Exclusion shape defined using the alpha channel of the specified 
		                image, opacity filter 75%.</p>

		            <pre>
			&lt;style&gt;
			#id {
				wrap-shape-image: url(myimage.png);
				wrap-shape-image-threshold: 75%;
			}
			&lt;/style&gt;
					</pre>
		        </div>

		        <table class="propdef">
		            <tr>
		                <th>Name:</th>
		                <td><dfn id="wrap-shape-image-threshold">wrap-shape-image-threshold</dfn></td>
		            </tr>
		            <tr>
		                <th>Value:</th>
		                <td><var>&lt;percent&gt;</var></td>
		            </tr>
		            <tr>
		                <th>Initial:</th>
		                <td>50%</td>
		            </tr>
		            <tr>
		                <th>Applies to:</th>
		                <td>any block element</td>
		            </tr>
		            <tr>
		                <th>Inherited:</th>
		                <td>no</td>
		            </tr>
		            <tr>
		                <th>Percentages:</th>
		                <td>N/A</td>
		            </tr>
		            <tr>
		                <th>Media:</th>
		                <td>visual</td>
		            </tr>
		            <tr>
		                <th>Computed&nbsp;value:</th>
		                <td>the specified value</td>
		            </tr>
		        </table>

		        <h3>Other wrap-shape-image properties</h3>

		        <p>'wrap-shape-image-repeat', 'wrap-shape-image-attachment',
		            'wrap-shape-image-position', 'wrap-shape-image-size'</p>

		        <p>These properties are equivalent to the ones available for the ''background'' 
		            property as defined in CSS Background module . The properties apply only to the 
		            'wrap-shape-image'. </p>

		        <h3>'wrap-shape-margin', 'wrap-shape-padding' properties</h3>

		        <p>Because the 'wrap-shape' and 'wrap-shape-image' properties define a single shape 
		            for both the exclusion shape and the content shape, two new properties allow to 
		            distinguish between them even more using specified offsets: 
		            'wrap-shape-margin' property can be used to offset the exclusion shape from the 
		            one specified with 'wrap-shape' or 'wrap-shape-image' properties.
		            'wrap-shape-padding' property can be used to offset the content shape from the 
		            one specified with 'wrap-shape' or 'wrap-shape-image' properties.</p>

		        <p>The exclusion shape is used to wrap elements that are not content of the 
		            specified block. The content shape is used to wrap the content elements. </p>

		        <p>Both margin and padding can take negative values. However, the content shape 
		            will be clipped by the content-box rectangle, so that interior elements will not 
		            be rendered outside the content-box of the block element.</p>

		        <div class="example">
		            <p>Text wrapping around an irregular shape.</p>
		            <pre>
			&lt;style&gt;
			#div2 {
				wrap-shape: poly(50px, 50px, 10px);
				wrap-shape-margin: 10px;
				wrap-shape-padding: 10px;
			}
			&lt;/style&gt;
					</pre>
		        </div>

		        <table class="propdef">
		            <tr>
		                <th>Name:</th>
		                <td><dfn id="wrap-shape-margin">wrap-shape-margin</dfn></td>
		            </tr>
		            <tr>
		                <th>Value:</th>
		                <td>length</td>
		            </tr>
		            <tr>
		                <th>Initial:</th>
		                <td>0</td>
		            </tr>
		            <tr>
		                <th>Applies to:</th>
		                <td>any block element</td>
		            </tr>
		            <tr>
		                <th>Inherited:</th>
		                <td>no</td>
		            <tr>
		                <th>Percentages:</th>
		                <td>N/A</td>
		            </tr>
		            <tr>
		                <th>Media:</th>
		                <td>visual</td>
		            </tr>
		            <tr>
		                <th>Computed&nbsp;value:</th>
		                <td>the specified value</td>
		            </tr>
		        </table>

		        <table class="propdef">
		            <tr>
		                <th>Name:</th>
		                <td><dfn id="wrap-shape-padding">wrap-shape-padding</dfn></td>
		            </tr>
		            <tr>
		                <th>Value:</th>
		                <td>length</td>
		            </tr>
		            <tr>
		                <th>Initial:</th>
		                <td>0</td>
		            </tr>
		            <tr>
		                <th>Applies to:</th>
		                <td>any block element</td>
		            </tr>
		            <tr>
		                <th>Inherited:</th>
		                <td>no</td>
		            </tr>
		            <tr>
		                <th>Percentages:</th>
		                <td>N/A</td>
		            </tr>
		            <tr>
		                <th>Media:</th>
		                <td>visual</td>
		            </tr>
		            <tr>
		                <th>Computed&nbsp;value:</th>
		                <td>the specified value</td>
		            </tr>
		        </table>

		        <p><img src="images/shapes.png" alt="Visual example for wrap-shape-padding and wrap-shape-margin" /></p>

 
        <h2 id='q-and-a'>Q&amp;A</h3>
        
			        <p><em>1. Can the wrap-shape-margin and wrap-shape-padding be negative?</em><br>
			            In the CSS box model only the margins can be negative. This is also applicable in the wrap-shape case to obtain a pull content effect for exclusions.</p>

			        <p><em>2. How is wrapping around concave shapes?</em><br>
			            The text will be flowed around the concave shape and will fill all the available outer space.</p>

			        <p><em>3. All of the wrap-shape-mode values other than &lsquo;none&rsquo; define a content shape for child elements, and while the different values (left, right, around) may affect how the exclusion shape interacts with other elements, they do not change how the content shape works. Correct?</em><br>
			            Yes.</p>

			        <p><em>4. How does a content shape interact with non-text content?</em><br>
			        	The content shape does not affect elements with position absolute or fixed.</p>
			        <p><em>4.1 Does it clip an image?</em><br>
			            No.</p>

			      <p><em>4.2 Does it clip the background-color and background-image?</em><br>
			            No.</p>

			        <p><em>4.3 If there is a border defined does it draw around the content shape (plus wrap-shape-padding) boundary?</em><br>
			            No.</p>

			        <p><em>5. I am assuming that a content shape (and perhaps the content itself) may determine an element&rsquo;s height and width if they are not specified, but they do not override explicit height and width.</em><br>
			            Yes, the content shape do not override explicit height and width. The content shape is clipped by the content-box margins.<br>
			            When the content box of the element is not defined, the content shape cannot be defined using percentages. In this case, the content shape will determine the elements width and height.</p>

			        <p><em>6. The permissible wrap-shape-order property values should include &ldquo;auto&rdquo; and &ldquo;inherit.&rdquo;</em><br>
			            This is correct.</p>
			        <p><em>7. The element will be considered an exclusion for anything outside the element and a content shape for everything inside that element.</em></p>
			        <p><em>7.1 Does "anything outside the element" include content that came before the element in DOM order? </em><br>
			          Yes. </p>
			        <p><em>7.2 If I put a wrap on an element, and then cause it to be positioned *above* where it would normally go, will the text in the previous element wrap around it? </em><br>
			          It depends.</p>
			        <div class="example">
						<p>Example 7.2.A:</p>
							<pre>
			&lt;style&gt;
				#div1 { }
				#div2 {
					wrap-shape-mode: left;
					wrap-shape: poly(...);
					position: absolute;
					top: 5px;
				}
				&lt;/style&gt;
			&lt;div id="div1"&gt;Text inside div1&lt;/div&gt;
			&lt;div id="div2"&gt;Text inside div2&lt;/div&gt;
						</pre>
					<p>
						In this case, the second div, on which the wrap-shape is defined, is absolutely positioned. Because of that, the exclusion shape can be computed. The text inside the 'div1' will flow around the exclusion shape.
					</p>  

					</div>
			        <div class="example">
			        <p>Example 7.2.B:</p>
			        <pre>
			&lt;style&gt;
			    #div1 { }
			    #div2 {
				    wrap-shape-mode: left;
				    wrap-shape: poly(...);
			    }
			&lt;/style&gt;
			&lt;div id="div1"&gt;Text inside div1&lt;/div&gt;
			&lt;div id="div2"&gt;Text inside div2&lt;/div&gt;
				</pre>
			    <p>
			In this case, both divs are statically positioned. The second div can be positioned only after the first div is positioned. Because of that, the wrap shape defined on the second div does not influence the text layout for the first div. 
			</p>
				</div>
					<div class="example">
			        <p>Example 7.2.C:</p>
			        <pre>
			&lt;style&gt;
				#div1 { }
			    #div2 {
				    wrap-shape-mode: left;
				    wrap-shape: poly(...);
				    position: relative;
				    top: -50px;
			    }
			&lt;/style&gt;
			&lt;div id="div1"&gt;Text inside div1&lt;/div&gt;
				&lt;div id="div2"&gt;Text inside div2&lt;/div&gt;
					</pre>
					<p>
			        In this case, the second div is positioned after the first div is positioned. Therefore, the wrap shape cannot be computed so that it can be taken into account when the first div is laid out. Even if the divs will overlap, the wrap shape does not influence the layout of text from 'div1'.
					</p>
			        </div>

			        <div class="example">
			        <p>Example 7.2.D:</p>
			        <pre>
			&lt;style&gt;
				#div1 {
					wrap-shape-mode: right;
					wrap-shape: poly(...);
					position: absolute;
					top: 50px;
					left: 10px;
				}
				#div2 {
					wrap-shape-mode: left;
					wrap-shape: poly(...);
					position: absolute;
					top: 50px;
					left: 50px;
				}
			&lt;/style&gt;
			&lt;div id="div1"&gt;Text inside div1&lt;/div&gt;
			&lt;div id="div2"&gt;Text inside div2&lt;/div&gt;
					</pre>
			        <p>
			In this case, both divs are absolutely positioned. They both have 
			the 'wrap-shape-order' equal to 0. Since the first div is the first 
			one in DOM, it's 'wrap-shape' influences the layout of the second 
			div. The second div 'wrap-shape' does not influence the layout of the first div.
			        </p>
			        </div>

        	        <p><em>8. In CSS2.1, content property cannot be inherited. 
	In CSS3, content property might be inherited. 
	Will <code>content: flow(region_thread_name)</code> be inherited?</em><br>
			            No.</p>
		
        <h2 id="conformance">Conformance</h2>
        
        
        <h2 class="no-num" id="acknowledgments">Acknowledgments</h2>
        <h2 class="no-num" id="references">References</h2>
        <h3 class="no-num" id="normative-references">Normative references</h3>
        <!--begin-normative--> 
        <!--end-normative-->
        
        <h3 class="no-num" id="other-references">Other references</h3>
		<!--begin-informative-->
	    <!----> 

	   <dt id=CSS21>[CSS21]

	   <dd>Bert Bos; et al. <a
	    href="http://www.w3.org/TR/2009/CR-CSS2-20090908"><cite>Cascading Style
	    Sheets Level 2 Revision 1 (CSS 2.1) Specification.</cite></a> 8 September
	    2009. W3C Candidate Recommendation. (Work in progress.) URL: <a
	    href="http://www.w3.org/TR/2009/CR-CSS2-20090908">http://www.w3.org/TR/2009/CR-CSS2-20090908</a> 
	    </dd> 
	   <!----> 

 		<dt id='CSS3-FLEXBOX'>[CSS3FLEXBOX]

		 <dd>L. David Baron. <a
		  href="http://www.w3.org/TR/2011/WD-css3-flexbox-20110322/"><cite>Flexible
		  Box Layout Module.</cite></a> 22 March 2011. W3C Working Draft. (Work in progress.) URL: <a
		  href="http://www.w3.org/TR/2011/WD-css3-flexbox-20110322/">http://www.w3.org/TR/2011/WD-css3-flexbox-20110322/</a> 
		  </dd> 
		 <!----> 
		 <dt id='CSS3GCPM'>[CSS3GCPM]

		 <dd>Håkon Wium Lie. <a
		  href="http://www.w3.org/TR/2010/WD-css3-gcpm-20100608"><cite>CSS3 module:
		  Generated Content for Paged Media.</cite></a> 8 June 2010. W3C Working
		  Draft. (Work in progress.) URL: <a
		  href="http://www.w3.org/TR/2010/WD-css3-gcpm-20100608">http://www.w3.org/TR/2010/WD-css3-gcpm-20100608</a> 
		  </dd> 
		 <!----> 
	   <dt id='CSSMULTICOL'>[CSSMULTICOL]

	   <dd>Håkon Wium Lie. <a
	    href="http://www.w3.org/TR/2009/CR-css3-multicol-20091217"><cite>CSS Multi-column Layout Module.</cite></a> 17 December 2009. W3C Candidate Recommendation. (Work in progress.) URL: <a href='http://www.w3.org/TR/2009/CR-css3-multicol-20091217'>http://www.w3.org/TR/2009/CR-css3-multicol-20091217</a>
	    </dd> 

		 <!----> 
	   <dt id='CSS3GRID'>[CSS3GRID]

	   <dd>Alex Mogilevsky; Markus Mielke. <a
	    href="http://www.w3.org/TR/2007/WD-css3-grid-20070905"><cite>CSS Grid
	    Positioning Module Level 3.</cite></a> 5 September 2007. W3C Working
	    Draft. (Work in progress.) URL: <a
	    href="http://www.w3.org/TR/2007/WD-css3-grid-20070905">http://www.w3.org/TR/2007/WD-css3-grid-20070905</a> 
	    </dd> 
	   <!----> 


		 <!----> 
	   <dt id='CSSTEMPLATELAYOUT'>[CSSTEMPLATELAYOUT]

	   <dd>Bert Bos; César Acebal. <a
	    href="http://www.w3.org/TR/2010/WD-css3-layout-20100429"><cite>CSS Template Layout Module</cite></a> 29 April 2010. W3C Working
	    Draft. (Work in progress.) URL: <a
	    href="http://www.w3.org/TR/2010/WD-css3-layout-20100429">http://www.w3.org/TR/2010/WD-css3-layout-20100429</a> 
	    </dd> 
	   <!----> 

		<!--end-informative-->
        
        <h2 class="no-num" id="index">Index</h2>
        <!--index-->
        
        <h2 class="no-num" id="property-index">Property index</h2>
        <!-- properties -->
    </body>
</html>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-declaration:"~/SGML/HTML4.decl"
sgml-default-doctype-name:"html"
sgml-minimize-attributes:t
sgml-nofill-elements:("pre" "style" "br")
sgml-live-element-indicator:t
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:t
sgml-general-insert-case:lower
sgml-always-quote-attributes:t
sgml-indent-step:nil
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->