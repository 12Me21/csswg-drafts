<!DOCTYPE html>
<html lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>CSS Syntax Module Level 3 (CSS3 Syntax)</title>
	<link rel=contents href="#contents">
	<link rel=index href="#index">
	<link rel="stylesheet" type="text/css" href="../default.css">
	<link rel="stylesheet" type="text/css"
				href="http://www.w3.org/StyleSheets/TR/W3C-[STATUS].css">
	<style type="text/css">
		/* delete this block when you've cleared out all the .replaceme elements */
		.replaceme {
			border: solid red;
			padding: 0 0.5em;
			margin: 0 0.1em;
			background: yellow;
			color: green;
		}
		.replaceme:before {
			 content: "FIXME(";
			 color: black;
		}
		.replaceme:after {
			 content: ")";
			 color: black;
		}
	</style>
</head>

<div class="head">
<!--logo-->

<h1>CSS Syntax Module Level 3</h1>

<h2 class="no-num no-toc">[LONGSTATUS] [DATE]</h2>
<dl>
	<dt>This version:
	<dd>
		<a href="http://dev.w3.org/csswg/css3-syntax/">http://dev.w3.org/csswg/css3-syntax/</a>
<!--
	<dt>Latest version:
	<dd>
		<a href="http://www.w3.org/TR/css3-syntax/">http://www.w3.org/TR/css3-syntax/</a>
-->
	<dt>Editor's draft:
	<dd>
		<a href="http://dev.w3.org/csswg/css3-syntax/">http://dev.w3.org/csswg/css3-syntax/</a>

	<dt>Previous version:
	<dd>
		<a href="http://www.w3.org/TR/2003/WD-css3-syntax-20030813/">http://www.w3.org/TR/2003/WD-css3-syntax-20030813/</a>

	<dt>Issue Tracking:</dt>
	<dd>
		<a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=CSS&component=Syntax">W3C Bugzilla</a>

	<dt>Feedback:</dt>
	<dd>
		<a href="http://lists.w3.org/Archives/Public/www-style/">www-style@w3.org</a> 
		with subject line &ldquo;<kbd>[css3-syntax] <var>&hellip; message topic &hellip;</var></kbd>&rdquo;

	<dt>Editors:
	<dd class="h-card vcard">
			<a class="p-name fn u-url url" rel="author"
				 href="http://www.xanthir.com/">Tab Atkins Jr.</a>
			(<span class="p-org org">Google, Inc.</span>),
			<span class="u-email email">jackalmage@gmail.com</span>
</dl>

<!--copyright-->

<hr title="Separator for header">
</div>

<h2 class="no-num no-toc" id="abstract">Abstract</h2>

	<p>
		<a href="http://www.w3.org/TR/CSS/">CSS</a> is a language for describing the rendering of structured documents (such as HTML and XML) on screen, on paper, in speech, etc. 
		This module describes, in general terms, the basic structure and syntax of CSS stylesheets.
		It defines, in detail, the syntax and parsing of CSS - how to turn a stream of bytes into a meaningful stylesheet. 

<h2 class="no-num no-toc" id="status">Status of this document</h2>

<!--status-->

<p>The following features are at risk: &hellip;

<h2 class="no-num no-toc" id="contents">
Table of contents</h2>

<!--toc-->

<h2 id="intro">
Introduction</h2>

	<p><em>This section is not normative.</em>

	<p><var class="replaceme">Provide background, motivation, etc.</var></p>

<h3 id="placement">
Module interactions</h3>

	<p>
		This module defines the syntax and parsing of CSS stylesheets.
		It supersedes the lexical scanner and grammar defined in CSS 2.1.

<h2 id='syntax-description'>
Description of CSS's Syntax</h2>

	<p><em>This section is not normative.</em>

	<p>
		A CSS document is a series of <i>rules</i>, 
		which apply CSS properties to elements in the source document, 
		and <i>at-rules</i>, 
		which define special processing rules or values for the CSS document.

	<p>
		A <dfn>rule</dfn> starts with a selector
		(defined by the <a href="http://www.w3.org/TR/selectors/">Selectors specification</a>),
		then has a {}-wrapped block containing a sequence of declarations.
		The selector specifies which elements the declarations will apply to.
		Each declaration has a property name, 
		followed by a colon and the property value,
		and finished with a semicolon.

	<div class='example'>
		<p>
			A typical rule might look something like this:

		<pre>
p > a { 
	color: blue;
	text-decoration: underline;
}</pre>

		<p>
			In the above rule, "<code>p > a</code>" is the selector,
			which, if the source document is HTML,
			selects any <code>&lt;a></code> elements that are children of a <code>&lt;p></code> element.

		<p>
			"<code>color: blue;</code>" is a declaration specifying that, 
			for the elements that match the selector,
			their 'color' property should have the value ''blue''.
			Similiarly, their 'text-decoration' property should have the value ''underline''.
	</div>

	<p>
		<dfn title="at-rule">At-rules</dfn> are all different, but they have a basic structure in common.
		They start with an "@" character followed by their name.
		Some <i>at-rules</i> are simple statements,
		with their name followed by more CSS values to specify their behavior,
		and finally ended by a semicolon.
		Others are blocks;
		they can have CSS values following their name, 
		but they end with a {}-wrapped block,
		similar to a <i>rule</i>.
		Even the contents of these blocks are specific to the given <i>at-rule</i>:
		sometimes they contain a sequence of declarations, like a <i>rule</i>;
		other times, they may contain additional blocks, or at-rules, or other structures altogether.

	<div class='example'>
		<p>
			Here are several examples of <i>at-rules</i> that illustrate the varied syntax they may contain.

		<pre>@import "my-styles.css";</pre>

		<p>
			The ''@import'' <i>at-rule</i> is a simple statement.
			After its name, it takes a single string or ''url()'' function to indicate the stylesheet that it should import.

		<pre>
@page :left {
	margin-left: 4cm;
	margin-right: 3cm;
}</pre>

		<p>
			The ''@page'' <i>at-rule</i> consists of an optional page selector (the ":left" pseudoclass),
			followed by a block of properties that apply to the page when printed.
			In this way, it's very similar to a normal <i>rule</i>,
			except that its properties don't apply to any "element",
			but rather the page itself.

		<pre>
@media print {
	body { font-size: 10pt }
}</pre>

		<p>
			The ''@media'' <i>at-rule</i> begins with a media type
			and a list of optional media queries.
			Its block contains entire rules,
			which are only applied when the ''@media''s conditions are fulfilled.
	</div>

	<p>
		Property names and <i>at-rule</i> names are always <b>identifiers</b>,
		which have to start with a letter or a hyphen followed by a letter,
		and then can contain letters, numbers, hyphens, or underscores.
		You can include any character at all,
		even ones that CSS uses in its syntax,
		by escaping it with a backslash (\) or by using a hexadecimal escape.

	<p>
		The syntax of selectors is defined in the <a href="http://www.w3.org/TR/selectors/">Selectors spec</a>.
		Similarly, the syntax of the wide variety of CSS values is defined in the <a href="http://www.w3.org/TR/css3-values/">Values &amp; Units spec</a>.
		The special syntaxes of individual <i>at-rules</i> can be found in the specs that define them.
	
<h2>
Parsing</h2>

	<p>
		User agents must use the parsing rules described in this section to generate the CSSOM trees from text/css resources. 
		Together, these rules define what is referred to as the CSS parser.

	<p>
		This specification defines the parsing rules for CSS documents, whether they are syntactically correct or not. 
		Certain points in the parsing algorithm are said to be parse errors. 
		The error handling for parse errors is well-defined: 
		user agents must either act as described below when encountering such problems, 
		or must abort processing at the first error that they encounter for which they do not wish to apply the rules described below.

	<p>
		Conformance checkers must report at least one parse error condition to the user if one or more parse error conditions exist in the document and must not report parse error conditions if none exist in the document. 
		Conformance checkers may report more than one parse error condition if more than one parse error condition exists in the document. 
		Conformance checkers are not required to recover from parse errors.

<h3>
Overview of the Parsing Model</h3>

	<p>
		The input to the CSS parsing process consists of a stream of Unicode code points, 
		which is passed through a tokenization stage followed by a tree construction stage. 
		The output is a CSSStyleSheet object.

	<p class='note'>
		Implementations that do not support scripting do not have to actually create a CSSOM CSSStyleSheet object, 
		but the CSSOM tree in such cases is still used as the model for the rest of the specification.

<h3>
The input byte stream</h3>

	<p>
		The stream of Unicode code points that comprises the input to the tokenization stage will be initially seen by the user agent as a stream of bytes 
		(typically coming over the network or from the local file system). 
		The bytes encode the actual characters according to a particular character encoding, 
		which the user agent must use to decode the bytes into characters.

	<p>
		The <i>encoding sniffing algorithm</i> defined below is used to determine the character encoding.

	<p>
		Given an encoding, 
		the bytes in the input byte stream must be converted to Unicode code points for the tokenizer's input stream, 
		as described by the rules for that encoding, 
		except that the leading U+FEFF BYTE ORDER MARK character, if any, 
		must not be stripped by the encoding layer (it is stripped by the rule below).

	<p>
		Bytes or sequences of bytes in the original byte stream that could not be converted to Unicode code points 
		must be converted to U+FFFD REPLACEMENT CHARACTERs. 
		Specifically, 
		if the encoding is UTF-8, 
		the bytes must be decoded with the error handling defined in this specification.

	<p class='note'>
		Bytes or sequences of bytes in the original byte stream that did not conform to the encoding specification 
		(e.g. invalid UTF-8 byte sequences in a UTF-8 input byte stream) 
		are errors that conformance checkers are expected to report.

<h4>
Determining the character encoding</h4>

	<div class='issue'>
		<p>
			General algorithm:

		<ol>
			<li>
				If the stylesheet is embedded, 
				the charset is the charset of the outer document.

			<li>
				If the resource carried a Charset header,
				and the value of the header is a valid charset,
				that's the charset of the stylesheet.

			<li>
				If the document contains an @charset rule at the very top
				(specify how to parse this in the presence of arbitrary charsets)
				and it specifies a valid charset,
				that's the charset of the stylesheet.

			<li>
				The charset is UTF-8.
		</ol>
	</div>

<h4>
Preprocessing the input stream</h4>

	<p>
		The input stream consists of the characters pushed into it as the input byte stream is decoded.

	<p>
		One leading U+FEFF BYTE ORDER MARK character must be ignored if any are present in the input stream.

	<p class='note'>
		The requirement to strip a U+FEFF BYTE ORDER MARK character regardless of whether that character was used to determine the byte order is a willful violation of Unicode, motivated by a desire to increase the resilience of user agents in the face of naïve transcoders.

	<p>
		U+000D CARRIAGE RETURN (CR) characters and U+000A LINE FEED (LF) characters are treated specially. All CR characters must be converted to LF characters, and any LF characters that immediately follow a CR character must be ignored. Thus, newlines in CSS stylesheets are represented by LF characters, and there are never any CR characters in the input to the tokenization stage.

	<p>
		The <dfn>next input character</dfn> is the first character in the input stream that has not yet been consumed or explicitly ignored by the requirements in this section. Initially, the <i>next input character</i> is the first character in the input. The <dfn>current input character</dfn> is the last character to have been consumed.

	<p>
		The "EOF" character in the tables below is a conceptual character representing the end of the input stream.

<h3>
Parse State</h3>

	<p>
		...

<h3>
Tokenization</h3>

	<p>
		Implementations must act as if they used the following state machine to tokenize HTML. 
		The state machine must start in the <i>data state</i>. 
		Most states consume a single character, 
		which may have various side-effects, 
		and either switches the state machine to a new state to reconsume the same character, 
		or switches it to a new state to consume the next character, 
		or stays in the same state to consume the next character. 
		Some states have more complicated behavior and can consume several characters before switching to another state.

	<p>
		The output of the tokenization step is a series of zero or more of the following tokens:
		identifier,
		function,
		at-keyword,
		hash,
		string,
		bad-string,
		url,
		bad-url,
		delim,
		number,
		percentage,
		dimension,
		unicode-range,
		whitespace,
		cdo,
		cdc,
		colon,
		semicolon,
		open-brace,
		close-brace,
		open-paren,
		close-paren,
		open-bracket,
		close-bracket.

	<p>
		Identifier, function, at-keyword, hash, string, and url tokens have a value composed of zero or more characters.
		Delim tokens have a value composed of a single character.
		Number, percentage, and dimension tokens have a representation composed of 1 or more character, a numeric value, and a type flag set to either "integer" or "number".  The type flag defaults to "integer" if not otherwise set.
		Dimension tokens additionally have a unit composed of one or more characters.
		Unicode-range tokens have a range of characters.

	<p>
		The tokenizer state machine consists of the states defined in the following subsections.

<h4>
Tokenizer Flags</h4>

	<p>
		The tokenizer can be run with any of several flags that alter its behavior.

	<dl>
		<dt>the <dfn>supports scientific notation</dfn> flag
		<dd>
			This flag is set if the tokenizer supports scientific notation in numbers.
			When this is set, a sequence of characters like "12e3" will tokenize
			as a number token with the value "12000".
			(Without the flag, they would tokenize as a dimension token with value "12" and unit "e3".)

			<p>
				Currently, this flag is only set when parsing SVG presentational attributes.

		<dt>the <dfn>transform function whitespace</dfn> flag
		<dd>
			This flag is set when parsing SVG's <code>transform</code> attribute.
			When this is set, whitespace is allowed between the name of a transform function and its opening parenthesis.
	</dl>

<h4>
Definitions</h4>

	<p>
		This section defines several terms used during the tokenization phase.

	<dl>
		<dt><dfn>digit</dfn>
		<dd>
			A character between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).

		<dt><dfn>hex digit</dfn>
		<dd>
			A <i>digit</i>,
			or a character between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F), 
			or a character between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).

		<dt><dfn>uppercase letter</dfn>
		<dd>
			A character between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).

		<dt><dfn>lowercase letter</dfn>
		<dd>
			A character between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).

		<dt><dfn>letter</dfn>
		<dd>
			An <i>uppercase letter</i>
			or a <i>lowercase letter</i>.

		<dt><dfn>non-ASCII character</dfn>
		<dd>
			A character with a codepoint equal to or greater than U+00A0 NO-BREAK SPACE.

		<dt><dfn>name-start character</dfn>
		<dd>
			A <i>letter</i>,
			a <i>non-ASCII character</i>,
			or U+005F LOW LINE (_).

		<dt><dfn>name character</dfn>
		<dd>
			A <i>name-start character</i>,
			A <i>digit</i>,
			or U+002D HYPHEN-MINUS (-).

		<dt><dfn>non-printable character</dfn>
		<dd>
			A character between U+0000 NULL and U+0008 BACKSPACE
			or a character between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE
			or a character between U+007F DELETE and U+009F APPLICATION PROGRAM COMMAND.

		<dt><dfn>newline</dfn>
		<dd>
			U+000A LINE FEED or U+000C FORM FEED. 
			<span class='note'>
				Note that U+000D CARRIAGE RETURN is not included in this definition, 
				as it is removed from the stream during preprocessing.
			</span>

		<dt><dfn>whitespace</dfn>
		<dd>A <i>newline</i>, U+0009 CHARACTER TABULATION, or U+0020 SPACE.

		<dt><dfn>maximum allowed codepoint</dfn>
		<dd>The greatest codepoint defined by Unicode.  This is currently U+10FFFF.

	</dl>

<h4>
<dfn>Data state</dfn></h4>

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt><i>whitespace</i>
		<dd>
			Consume as much <i>whitespace</i> as possible.
			Emit a whitespace token.
			Remain in this state.

		<dt>U+0022 QUOTATION MARK (")
		<dd>
			Switch to the <i>double-quote-string state</i>.

		<dt>U+0023 NUMBER SIGN (#)
		<dd>
			Switch to the <i>hash state</i>.

		<dt>U+0027 APOSTROPHE (&apos;)
		<dd>
			Switch to the <i>single-quote-string state</i>.

		<dt>U+0028 LEFT PARENTHESIS (()
		<dd>
			Emit an open-paren token.
			Remain in this state.

		<dt>U+0029 RIGHT PARENTHESIS ())
		<dd>
			Emit a close-paren token.
			Remain in this state.

		<dt>U+002B PLUS SIGN (+)
		<dd>
			If the <i>next input character</i> is
			a <i>digit</i>,
			or the <i title="next input character">next 2 input characters</i> are
			U+002E FULL STOP (.)
			followed by a <i>digit</i>,
			switch to the <i>number state</i>.
			Reconsume the <i>current input character</i>.

			<p>
				Otherwise,
				emit a delim token
				with its value set to U+002B PLUS SIGN (+).
				Remain in this state</i>.

		<dt>U+002D HYPHEN-MINUS (-)
		<dd>
			If the <i title="next input character">next 2 input characters</i> are
			U+002D HYPHEN-MINUS
			U+003E GREATER-THAN SIGN
			(->),
			consume them,
			emit a CDC token,
			and remain in this state.

			<p>
				Otherwise,
				if the <i>next input character</i> is
				a <i>digit</i>,
				or the <i title="next input character">next 2 input characters</i> are
				U+002E FULL STOP (.)
				followed by a <i>digit</i>,
				switch to the <i>number state</i>.
				Reconsume the <i>current input character</i>.

			<p>
				Otherwise,
				if the <i>next input character</i> is
				a <i>name-start character</i>,
				switch to the <i>identifier state</i>.
				Reconsume the <i>current input character</i>.

			<p>
				Otherwise,
				emit a delim token
				with its value set to U+002D HYPHEN-MINUS (-).
				Remain in this state.

		<dt>U+002E FULL STOP (.)
		<dd>
			If the <i>next input character</i> is a digit,
			switch to the <i>number state</i>.
			Reconsume the <i>current input character</i>.

			<p>
				Otherwise,
				emit a delim token
				with its value set to U+002E FULL STOP (.).
				Remain in this state.

		<dt>U+002F SOLIDUS (/)
		<dd>
			If the <i>next input character</i> is U+002A ASTERISK (*),
			consume it
			and switch to the <i>comment state</i>.

			<p>
				Otherwise,
				emit a delim token
				with its value set to U+002F SOLIDUS (/).
				Remain in this state.

		<dt>U+003A COLON (:)
		<dd>
			Emit a colon token.
			Remain in this state.

		<dt>U+003B SEMICOLON (;)
		<dd>
			Emit a semicolon token.
			Remain in this state.

		<dt>U+003C LESS-THAN SIGN (&lt;)
		<dd>
			If the <i title="next input character">next 3 input characters</i> are
			U+0021 EXCLAMATION MARK
			U+002D HYPHEN-MINUS
			U+002D HYPHEN-MINUS
			(!--),
			consume them
			and emit a cdo token.
			Remain in this state.

			<p>
				Otherwise,
				emit a delim token
				with its value set to U+003C LESS-THAN SIGN (&lt;).
				Remain in this state.

		<dt>U+0040 COMMERCIAL AT (@)
		<dd>
			Switch to the <i>at-keyword state</i>.

		<dt>U+005B LEFT SQUARE BRACKET ([)
		<dd>
			Emit an open-bracket token.
			Remain in this state.

		<dt>U+005C REVERSE SOLIDUS (\)
		<dd>
			If the <i>next input character</i> is 
			a <i>newline</i>
			or EOF,
			this is a <i>parse error</i>.
			Emit a delim token
			with its value set to U+005C REVERSE SOLIDUS (\).
			Remain in this state.

			<p>
				Otherwise, switch to the <i>identifier state</i>.
				Reconsume the <i>current input character</i>.

		<dt>U+005D RIGHT SQUARE BRACKET (])
		<dd>
			Emit a close-bracket token.
			Remain in this state.

		<dt>U+007B LEFT CURLY BRACKET ({)
		<dd>
			Emit an open-brace token.
			Remain in this state.

		<dt>U+007D RIGHT CURLY BRACKET (})
		<dd>
			Emit a close-brace token.
			Remain in this state.

		<dt><i>digit</i>
		<dd>
			Switch to the <i>number state</i>.
			Reconsume the <i>current input character</i>.

		<dt>U+0055 LATIN CAPITAL LETTER U (U)
		<dt>U+0075 LATIN SMALL LETTER U (u)
		<dd>
			If the <i title="next input character">next 2 input character</i> are
			U+002B PLUS SIGN (+)
			followed by a <i>hex digit</i>,
			consume the <i>next input character</i>.
			<span class='note'>Note: don't consume both of them.</span>
			Switch to the <i>unicode-range state</i>.

			<p>
				Otherwise,
				if the <i title="next input character">next 3 input characters</i> are
				U+0052 LATIN CAPITAL LETTER R (R) or U+0072 LATIN SMALL LETTER R (r)
				followed by U+004C LATIN CAPITAL LETTER L (L) or U+006C LATIN SMALL LETTER L (l)
				followed by U+0028 LEFT PARENTHESIS ((),
				consume them.
				Switch to the <i>url state</i>.

			<p>Otherwise,
				switch to the <i>identifier state</i>.
				Reconsume the <i>current input character</i>.

		<dt><i>name-start character</i>
		<dd>
			Switch to the <i>identifier state</i>.
			Reconsume the <i>current input character</i>.

		<dt>EOF
		<dd>
			Emit an end-of-file token.

		<dt>anything else
		<dd>
			Emit a delim token
			with its value set to the <i>current input character</i>.
			Remain in this state.
	</dl>

<h4>
<dfn>Double-quote-string state</dfn></h4>

	<p>
		If a string token has not yet been created since entering this state,
		create a string token
		with its value initially set to the empty string.

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt>U+0022 QUOTATION MARK (")
		<dd>
			Emit the string token.
			Return to the <i>data state</i>.

		<dt>EOF
		<dd>
			This is a <i>parse error</i>.
			Emit the string token.
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.

		<dt><i>newline</i>
		<dd>
			This is a <i>parse error</i>.
			Emit a bad-string token.
			Switch to the <i>data state</i>.

		<dt>U+005C REVERSE SOLIDUS (\)
		<dd>
			If the <i>next input character</i>
			is an EOF,
			this is a <i>parse error</i>.
			Append a U+005C REVERSE SOLIDUS (\)
			to the string token's value
			and emit the string token,
			then switch to the <i>data state</i>.

			<p>
				Otherwise,
				if the <i>next input character</i> is
				a <i>newline</i>,
				consume it.
				Remain in this state.

			<p>
				Otherwise,
				<i>consume an escaped character</i>.
				Append the returned character to the string token's value.
				Remain in this state.

		<dt>anything else
		<dd>
			Append the <i>current input character</i>
			to the string token's value.
			Remain in this state.
	</dl>

<h4>
<dfn>Single-quote-string state</dfn></h4>

	<p>
		If a string token has not yet been created since entering this state,
		create a string token
		with its value initially set to the empty string.

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt>U+0027 APOSTROPHE (&apos;)
		<dd>
			Emit the string token.
			Return to the <i>data state</i>.

		<dt>EOF
		<dd>
			This is a <i>parse error</i>.
			Emit the string token.
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.

		<dt><i>newline</i>
		<dd>
			This is a <i>parse error</i>.
			Emit a bad-string token.
			Switch to the <i>data state</i>.

		<dt>U+005C REVERSE SOLIDUS (\)
		<dd>
			If the <i>next input character</i>
			is an EOF,
			this is a <i>parse error</i>.
			Append a U+005C REVERSE SOLIDUS (\)
			to the string token's value
			and emit the string token,
			then switch to the <i>data state</i>.

			<p>
				Otherwise,
				if the <i>next input character</i> is
				a <i>newline</i>,
				consume it.
				Remain in this state.

			<p>
				Otherwise,
				<i>consume an escaped character</i>.
				Append the returned character to the string token's value.
				Remain in this state.

		<dt>anything else
		<dd>
			Append the <i>current input character</i>
			to the string token's value.
			Remain in this state.
	</dl>

<h4>
<dfn>Hash state</dfn></h4>

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt><i>name character</i>
		<dd>
			Create a hash token
			with its value set to the <i>current input character</i>.
			Switch to the <i>hash-rest state</i>.

		<dt>U+005C REVERSE SOLIDUS (\)
		<dd>
			If the <i>next input character</i> is
			a <i>newline</i> or EOF,
			emit a delim token
			with its value set to U+0023 NUMBER SIGN (#).
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.

			<p>
				Otherwise, 
				<i>consume an escaped character</i>.
				Create a hash token
				with its value set to the returned character.
				Switch to the <i>hash-rest state</i>.

		<dt>anything else
		<dd>
			Emit a delim token 
			with its value set to U+0023 NUMBER SIGN (#).
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.
	</dl>

<h4>
<dfn>Hash-rest state</dfn></h4>

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt><i>name character</i>
		<dd>
			Append the <i>current input character</i>
			to the hash token's value.
			Remain in this state.

		<dt>U+005C REVERSE SOLIDUS (\)
		<dd>
			If the <i>next input character</i> is
			a <i>newline</i> or EOF,
			emit the hash token.
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.

			<p>
				Otherwise, 
				<i>consume an escaped character</i>.
				Append the returned character to the hash token's value.
				Remain in this state.

		<dt>anything else
		<dd>
			Emit the hash token.
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.
	</dl>

<h4>
<dfn>Comment state</dfn></h4>

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt>U+002A ASTERISK (*)
		<dd>
			If the <i>next input character</i> is
			U+002F SOLIDUS (/),
			consume it,
			and switch to the <i>data state</i>.

			<p>
				Otherwise,
				do nothing
				and remain in this state.

		<dt>EOF
		<dd>
			This is a <i>parse error</i>.
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.

		<dt>anything else
		<dd>
			Do nothing
			and remain in this state.
	</dl>

<h4>
<dfn>At-keyword state</dfn></h4>

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt>U+002D HYPHEN-MINUS (-)
		<dd>
			If the <i>next input character</i> is a <i>name-start character</i>,
			consume it.
			Create an at-keyword token
			with its value set to U+002D HYPHEN-MINUS
			followed by the <i>current input character</i>.
			Switch to the <i>at-keyword-rest state</i>.

			<p>
				Otherwise,
				emit a delim token
				with its value set to U+0040 COMMERCIAL AT (@).
				Switch to the <i>data state</i>.
				Reconsume the <i>current input character</i>.

		<dt><i>name-start character</i>
		<dd>
			Create an at-keyword token
			with its value set to the <i>current input character</i>.
			Switch to the <i>at-keyword-rest state</i>.

		<dt>U+005C REVERSE SOLIDUS (\)
		<dd>
			If the <i>next input character</i> is
			a <i>newline</i> or EOF,
			emit a delim token
			with its value set to U+0040 COMMERCIAL AT (@).
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.

			<p>
				Otherwise, 
				<i>consume an escaped character</i>.
				Create an at-keyword token
				with its value set to the returned character.
				Switch to the <i>at-keyword-rest state</i>.

		<dt>anything else
		<dd>
			Emit a delim token
			with its value set to U+0040 COMMERCIAL AT (@).
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.
	</dl>

<h4>
<dfn>At-keyword-rest state</dfn></h4>

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt><i>name character</i>
		<dd>
			Append the <i>current input character</i>
			to the at-keyword token's value.
			Remain in this state.

		<dt>U+005C REVERSE SOLIDUS (\)
		<dd>
			If the <i>next input character</i> is
			a <i>newline</i> or EOF,
			emit the at-keyword token.
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.

			<p>
				Otherwise, 
				<i>consume an escaped character</i>.
				Append the returned character to the at-keyword token's value.
				Remain in this state.

		<dt>anything else
		<dd>
			Emit the at-keyword token.
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.
	</dl>

<h4>
<dfn>Identifier state</dfn></h4>

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt>U+002D HYPHEN-MINUS (-)
		<dd>
			If the <i>next input character</i> is
			a <i>name-start character</i>,
			create an identifer token
			with its value initially set to U+002D HYPHEN-MINUS.
			Switch to the <i>identifier-rest state</i>.

			<p>
				Otherwise,
				switch to the <i>data state</i>.
				Reconsume the <i>current input character</i>.

		<dt><i>name-start character</i>
		<dd>
			Create an identifier token
			with its value set to the <i>current input character</i>.
			Switch to the <i>identifier-rest state</i>.

		<dt>U+005C REVERSE SOLIDUS (\)
		<dd>
			If the <i>next input character</i> is
			a <i>newline</i> or EOF,
			switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.

			<p>
				Otherwise, 
				<i>consume an escaped character</i>.
				Create an identifier token
				with its value set to the returned character.
				Switch to the <i>identifier-rest state</i>.

		<dt>anything else
		<dd>
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.
	</dl>

<h4>
<dfn>Identifier-rest state</dfn></h4>

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt><i>name character</i>
		<dd>
			Append the <i>current input character</i>
			to the identifier token's value.
			Remain in this state.

		<dt>U+005C REVERSE SOLIDUS (\)
		<dd>
			If the <i>next input character</i> is
			a <i>newline</i> or EOF,
			emit the identifier token.
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.

			<p>
				Otherwise, 
				<i>consume an escaped character</i>.
				Append the returned character to the identifier token's value.
				Remain in this state.

		<dt>U+0028 LEFT PARENTHESIS (()
		<dd>
			Emit a function token
			with its value set to the identifer token's value.
			Switch to the <i>data state</i>.

		<dt><i>whitespace</i>
		<dd>
			If the <i>transform function whitespace</i> flag is set,
			switch to the <i>transform-function-whitespace state</i>.

			<p>
				Otherwise,
				emit the identifier token.
				Switch to the <i>data state</i>.
				Reconsume the <i>current input character</i>.

		<dt>anything else
		<dd>
			Emit the identifier token.
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.
	</dl>

<h4>
<dfn>Transform-function-whitespace state</dfn></h4>

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt><i>whitespace</i>
		<dd>
			Remain in this state.

		<dt>U+0028 LEFT PARENTHESIS (()
		<dd>
			Emit a function token
			with its value set to the identifer token's value.
			Switch to the <i>data state</i>.

		<dt>anything else
		<dd>
			Emit the identifier token.
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.
	</dl>


<h4>
<dfn>Number state</dfn></h4>

	<p>
		Create a number token
		with its representation initially set to the emptry string.

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt>U+002D HYPHEN-MINUS (-)
		<dd>
			If the <i>next input character</i> is
			a <i>digit</i>,
			consume it.
			Append U+002D HYPHEN-MINUS (-) to the number token's representation.
			Append the <i>digit</i> to the number token's representation.
			Switch to the <i>number-rest state</i>.

			<p>
				Otherwise,
				if the <i title="next input character">next 2 input characters</i> are
				U+002E FULL STOP
				followed by a <i>digit</i>,
				consume them.
				Append U+002D HYPHEN-MINUS (-) to the number token's representation.
				Append U+002E FULL STOP (.) to the number token's representation.
				Append the <i>digit</i> to the number token's representation.
				Switch to the <i>number fraction</i> state.

			<p>
				Otherwise,
				switch to the <i>data state</i>.
				Reconsume the <i>current input character</i>.

		<dt>U+002B PLUS SIGN (+)
		<dd>
			If the <i>next input character</i> is
			a <i>digit</i>,
			consume it.
			Append U+002D PLUS SIGN (+) to the number token's representation.
			Append the <i>digit</i> to the number token's representation.
			Switch to the <i>number-rest state</i>.

			<p>
				Otherwise,
				if the <i title="next input character">next 2 input characters</i> are
				U+002E FULL STOP
				followed by a <i>digit</i>,
				consume them.
				Append U+002D PLUS SIGN (+) to the number token's representation.
				Append U+002E FULL STOP (.) to the number token's representation.
				Append the <i>digit</i> to the number token's representation.
				Switch to the <i>number fraction</i> state.

			<p>
				Otherwise,
				switch to the <i>data state</i>.
				Reconsume the <i>current input character</i>.

		<dt><i>digit</i>
		<dd>
			Append the <i>current input character</i>
			to the number token's representation.
			Switch to the <i>number-rest state</i>.

		<dt>U+002E FULL STOP (.)
		<dd>
			If the <i>next input character</i> is
			a <i>digit</i>,
			consume it.
			Append U+002E FULL STOP (.) to the number token's representation.
			Append the <i>digit</i> to the number token's representation.
			Switch to the <i>number-fraction state</i>.

			<p>
				Otherwise,
				switch to the <i>data state</i>.
				Reconsume the <i>current input character</i>.

		<dt>anything else
		<dd>
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.
	</dl>

<h4>
<dfn>Number-rest state</dfn></h4>

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt><i>digit</i>
		<dd>
			Append the <i>current input character</i>
			to the number token's representation.
			Remain in this state.

		<dt>U+002E FULL STOP (.)
		<dd>
			If the <i>next input character</i> is
			a <i>digit</i>,
			consume it.
			Append U+002E FULL STOP (.)
			followed by the <i>digit</i>
			to the number token's representation.
			Switch to the <i>number-fraction state</i>.

			<p>
				Otherwise,
				set the number token's value to the number
				produced by interpreting the number token's representation
				as a base-10 number
				and emit it.
				Switch to the <i>data state</i>.
				Reconsume the <i>current input character</i>.

		<dt>U+0025 PERCENT SIGN
		<dd>
			Emit a percent token
			with its value set to the number
			produced by interpreting the number token's representation
			as a base-10 number.
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.

		<dt>U+0045 LATIN CAPITAL LETTER E (E)
		<dt>U+0065 LATIN SMALL LETTER E (e)
		<dd>
			If the parser <i title="supports-scientific-notation">doesn't support scientific notation</i>,
			create a dimension token
			with its representation set to the number token's representation,
			its value set to the number
			produced by interpreting the number token's representation
			as a base-10 number,
			and a unit initially set to the <i>current input character</i>.
			Switch to the <i>dimension state</i>.

			<p>
				Otherwise,
				if the <i>next input character</i> is a <i>digit</i>,
				or the <i title="next input character">next 2 input characters</i>
				are U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-) followed by a <i>digit</i>,
				consume them
				and append them to the number token's representation.
				switch to the <i>sci-notation state</i>.

			<p>
				Otherwise,
				create a dimension token
				with its representation set to the number token's representation,
				its value set to the number
				produced by interpreting the number token's representation
				as a base-10 number,
				and a unit initially set to the <i>current input character</i>.
				Switch to the <i>dimension state</i>.

		<dt>U+002D HYPHEN-MINUS (-)
		<dd>
			If the <i>next input character</i> is
			a <i>name-start character</i>,
			consume it.
			Create a dimension token
			with its representation set to the number token's representation,
			its value set to the number
			produced by interpreting the number token's representation
			as a base-10 number,
			and a unit initially set to
			U+002D HYPHEN-MINUS
			followed by the <i>name-start character</i>.
			Switch to the <i>dimension state</i>.

			<p>
				Otherwise,
				if the <i title="next input character">next 2 input characters</i> are
				U+005C REVERSE SOLIDUS (\) followed by a <i>newline</i>,
				or U+005C REVERSE SOLIDUS (\) followed by EOF,
				set the number token's value to the number
				produced by interpreting the number token's representation
				as a base-10 number
				and emit it.
				Switch to the <i>data state</i>.
				Reconsume the <i>current input character</i>.

			<p>
				Otherwise,
				if the <i>next input character</i> is
				U+005C REVERSE SOLIDUS (\),
				consume it,
				then <i>consume an escaped character</i>.
				Create a dimension token
				with its representation set to the number token's representation,
				its value set to the number
				produced by interpreting the number token's representation
				as a base-10 number,
				and a unit initially set to
				U+002D HYPHEN-MINUS
				followed by the returned character.
				Switch to the <i>dimension state</i>.

			<p>
				Otherwise,
				set the number token's value to the number
				produced by interpreting the number token's representation
				as a base-10 number
				and emit it.
				Switch to the <i>data state</i>.
				Reconsume the <i>current input character</i>.

		<dt><i>name-start character</i>
		<dd>
			Create a dimension token
			with its representation set to the number token's representation,
			its value set to the number
			produced by interpreting the number token's representation
			as a base-10 number,
			and a unit initially set to the <i>current input character</i>.
			Switch to the <i>dimension state</i>.

		<dt>U+005C REVERSE SOLIDUS (\)
		<dd>
			If the <i>next input character</i> is
			a <i>newline</i> or EOF,
			set the number token's value to the number
			produced by interpreting the number token's representation
			as a base-10 number
			and emit it.
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.

			<p>
				Otherwise,
				<i>consume an escaped character</i>.
				Create a dimension token
				with its representation set to the number token's representation,
				its value set to the number
				produced by interpreting the number token's representation
				as a base-10 number,
				and a unit initially set to the returned character.
				Switch to the <i>dimension state</i>.

		<dt>anything else
		<dd>
			Emit a number token
			with its value set to the number
			produced by interpreting the string token's value
			as a base-10 number.
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.
	</dl>

<h4>
<dfn>Number-fraction state</dfn></h4>

	<p>
		Set the number token's type flag to "number".

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt><i>digit</i>
		<dd>
			Append the <i>current input character</i>
			to the string token's value.
			Remain in this state.

		<dt>U+002E FULL STOP (.)
		<dd>
			Set the number token's value to the number
			produced by interpreting the number token's representation
			as a base-10 number
			and emit it.
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.

		<dt>U+0025 PERCENT SIGN
		<dd>
			Emit a percent token
			with its value set to the number
			produced by interpreting the number token's representation
			as a base-10 number.
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.

		<dt>U+0045 LATIN CAPITAL LETTER E (E)
		<dt>U+0065 LATIN SMALL LETTER E (e)
		<dd>
			If the parser <i title="supports-scientific-notation">doesn't support scientific notation</i>,
			create a dimension token
			with its representation set to the number token's representation,
			its value set to the number
			produced by interpreting the number token's representation
			as a base-10 number,
			and a unit initially set to the <i>current input character</i>.
			Switch to the <i>dimension state</i>.

			<p>
				Otherwise,
				if the <i>next input character</i> is a <i>digit</i>,
				or the <i title="next input character">next 2 input characters</i>
				are U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-) followed by a <i>digit</i>,
				consume them
				and append them to the number token's representation.
				switch to the <i>sci-notation state</i>.

			<p>
				Otherwise,
				create a dimension token
				with its representation set to the number token's representation,
				its value set to the number
				produced by interpreting the number token's representation
				as a base-10 number,
				and a unit initially set to the <i>current input character</i>.
				Switch to the <i>dimension state</i>.

		<dt>U+002D HYPHEN-MINUS (-)
		<dd>
			If the <i>next input character</i> is
			a <i>name-start character</i>,
			consume it.
			Create a dimension token
			with its representation set to the number token's representation,
			its value set to the number
			produced by interpreting the number token's representation
			as a base-10 number,
			and a unit initially set to
			U+002D HYPHEN-MINUS
			followed by the <i>name-start character</i>.
			Switch to the <i>dimension state</i>.

			<p>
				Otherwise,
				if the <i title="next input character">next 2 input characters</i> are
				U+005C REVERSE SOLIDUS (\) followed by a <i>newline</i>,
				or U+005C REVERSE SOLIDUS (\) followed by EOF,
				set the number token's value to the number
				produced by interpreting the number token's representation
				as a base-10 number
				and emit it.
				Switch to the <i>data state</i>.
				Reconsume the <i>current input character</i>.

			<p>
				Otherwise,
				if the <i>next input character</i> is
				U+005C REVERSE SOLIDUS (\),
				consume it,
				then <i>consume an escaped character</i>.
				Create a dimension token
				with its representation set to the number token's representation,
				its value set to the number
				produced by interpreting the number token's representation
				as a base-10 number,
				and a unit initially set to
				U+002D HYPHEN-MINUS
				followed by the returned character.
				Switch to the <i>dimension state</i>.

			<p>
				Otherwise,
				set the number token's value to the number
				produced by interpreting the number token's representation
				as a base-10 number
				and emit it.
				Switch to the <i>data state</i>.
				Reconsume the <i>current input character</i>.

		<dt><i>name-start character</i>
		<dd>
			Create a dimension token
			with its representation set to the number token's representation,
			its value set to the number
			produced by interpreting the number token's representation
			as a base-10 number,
			and a unit initially set to the <i>current input character</i>.
			Switch to the <i>dimension state</i>.

		<dt>U+005C REVERSE SOLIDUS (\)
		<dd>
			If the <i>next input character</i> is
			a <i>newline</i> or EOF,
			set the number token's value to the number
			produced by interpreting the number token's representation
			as a base-10 number
			and emit it.
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.

			<p>
				Otherwise,
				<i>consume an escaped character</i>.
				Create a dimension token
				with its representation set to the number token's representation,
				its value set to the number
				produced by interpreting the number token's representation
				as a base-10 number,
				and a unit initially set to the returned character.
				Switch to the <i>dimension state</i>.


		<dt>anything else
		<dd>
			Emit a number token
			with its value set to the number
			produced by interpreting the string token's value
			as a base-10 number.
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.
	</dl>

<h4>
<dfn>Dimension state</dfn></h4>

	<!--
		This state is currently always entered with a dimension token
		having already been created and gotten over the "first valid character" hump,
		so the dimension token is already ready to emit.

		If this ever becomes not true, make the necessary additions here
		or things will break.
	-->

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt><i>name character</i>
		<dd>
			Append the <i>current input character</i>
			to the dimension token's unit.
			Remain in this state.

		<dt>U+005C REVERSE SOLIDUS (\)
		<dd>
			If the <i>next input character</i> is
			a <i>newline</i> or EOF,
			emit the dimension token.
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.

			<p>
				Otherwise,
				<i>consume an escaped character</i>.
				Append the returned character
				to the dimension token's unit.

		<dt>anything else
		<dd>
			Emit the dimension token.
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.
	</dl>

<h4>
<dfn>Sci-notation state</dfn></h4>

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt><i>digit</i>
		<dd>
			Append the <i>current input character</i>
			to the number token's representation.
			Remain in this state.

		<dt>anything else</i>
		<dd>
			Let <var>base</var> be the result of interpreting the portion of the number token's representation 
			preceding the U+0045 LATIN CAPITAL LETTER E (E) or U+0065 LATIN SMALL LETTER E (e)
			as a base-10 number.
			<p>
				Let <var>power</var> be the result of interpreting the portion of the number token's representation 
				following the U+0045 LATIN CAPITAL LETTER E (E) or U+0065 LATIN SMALL LETTER E (e)
				as a base-10 number.
			<p>
				Set the number token's value to <code><var>base</var> * 10<sup><var>power</var></sup></code>.
				If the number token's value is not an integer,
				set the number token's type flag to "number".
				Emit the number token.
				Switch to the <i>date state</i>.
				Reconsume the <i>current input character</i>.
	</dl>

<h4>
<dfn>URL state</dfn></h4>

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt>U+0022 QUOTATION MARK (")
		<dd>
			Switch to the <i>url-double-quote state</i>.

		<dt>U+0027 APOSTROPHE (&apos;)
		<dd>
			Switch to the <i>url-single-quote state</i>.

		<dt>U+0029 RIGHT PARENTHESIS ())
		<dd>
			Emit a url token
			with its value set to the empty string.
			Switch to the <i>data state</i>.

		<dt><i>whitespace</i>
		<dd>
			Remain in this state.

		<dt>anything else
		<dd>
			Switch to the <i>url-unquoted state</i>.
			Reconsume the <i>current input character</i>.
	</dl>

<h4>
<dfn>URL-double-quote state</dfn></h4>

	<p>
		If a url token has not yet been created since entering this state,
		create a url token
		with its value initially set to the empty string.

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt>U+0022 QUOTATION MARK (")
		<dd>
			Switch to the <i>url-end state</i>.

		<dt><i>newline</i>
		<dd>
			Emit a bad-url token.
			Switch to the <i>data state</i>.

		<dt>U+005C REVERSE SOLIDUS (\)
		<dd>
			If the <i>next input character</i> is
			EOF,
			this is a <i>parse error</i>.
			Emit a bad-url token.
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.

			<p>
				Otherwise, if the <i>next input character</i> is
				a <i>newline</i>,
				consume it
				and remain in this state.

			<p>
				Otherwise,
				<i>consume an escaped character</i>.
				Append the returned character to the url token's value.
				Remain in this state.

		<dt>anything else
		<dd>
			Append the <i>current input character</i>
			to the url token's value.
			Remain in this state.
	</dl>

<h4>
<dfn>URL-single-quote state</dfn></h4>

	<p>
		If a url token has not yet been created since entering this state,
		create a url token
		with its value initially set to the empty string.

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt>U+0027 APOSTROPHE (&apos;)
		<dd>
			Switch to the <i>url-end state</i>.

		<dt><i>newline</i>
		<dd>
			Emit a bad-url token.
			Switch to the <i>data state</i>.

		<dt>U+005C REVERSE SOLIDUS (\)
		<dd>
			If the <i>next input character</i> is
			EOF,
			this is a <i>parse error</i>.
			Emit a bad-url token.
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.

			<p>
				Otherwise, if the <i>next input character</i> is
				a <i>newline</i>,
				consume it
				and remain in this state.

			<p>
				Otherwise,
				<i>consume an escaped character</i>.
				Append the returned character to the url token's value.
				Remain in this state.

		<dt>anything else
		<dd>
			Append the <i>current input character</i>
			to the url token's value.
			Remain in this state.
	</dl>

<h4>
<dfn>URL-end state</dfn></h4>

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt><i>whitespace</i>
		<dd>
			Remain in this state.

		<dt>U+0029 RIGHT PARENTHESIS ())
		<dd>
			Emit the url token.
			Switch to the <i>data state</i>.

		<dt>anything else
		<dd>
			This is a <i>parse error</i>.
			Emit a bad-url token.
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.
	</dl>

<h4>
<dfn>URL-unquoted state</dfn></h4>

	<p>
		If a url token has not yet been created since entering this state,
		create a url token
		with its value initially set to the empty string.

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt><i>whitespace</i>
		<dd>
			Switch to the <i>url-end state</i>.

		<dt>U+0029 RIGHT PARENTHESIS ())
		<dd>
			Emit the url token.
			Switch to the <i>data state</i>.

		<dt>U+0022 QUOTATION MARK (")
		<dt>U+0027 APOSTROPHE (&apos;)
		<dt>U+0028 LEFT PARENTHESIS (()
		<dt><i>non-printing character</i>
		<dd>
			This is a <i>parse error</i>.
			Emit a bad-url token.
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.

		<dt>U+005C REVERSE SOLIDUS
		<dd>
			If the <i>next input character</i>
			is a <i>newline</i> or EOF,
			this is a <i>parse error</i>.
			Emit a bad url token.
			Switch to the <i>data state</i>.

			<p>
				Otherwise, 
				<i>consume an escaped character</i>.
				Append the returned character
				to the url token's value.
				Remain in this state.

		<dt>anything else
		<dd>
			Append the <i>current input character</i>
			to the url token's value.
			Remain in this state.
	</dl>

<h4>
<dfn>Unicode-range state</dfn></h4>

	<p>
		Create a new unicode-range token
		with an empty range.

	<p>
		Consume as many <i>hex digits</i> as possible, but no more than 6.
		If less than 6 <i>hex digits were consumed</i>,
		consume as many U+003F QUESTION MARK (?) character as possible,
		but no more than enough to make the total of <i>hex digits</i> and U+003F QUESTION MARK (?) characters equal to 6.

		<p>
			If any U+003F QUESTION MARK (?) characters were consumed,
			first interpret the consumed characters as a hexadecimal number,
			with the U+003F QUESTION MARK (?) characters replaced by U+0030 DIGIT ZERO (0) characters.
			This is the <i>start of the range</i>.
			Then interpret the consumed characters as a hexadecimal number again,
			with the U+003F QUESTION MARK (?) character replaced by U+0046 LATIN CAPITAL LETTER F (F) characters.
			This is the <i>end of the range</i>.
			<i>Set the unicode-range token's range</i>, then emit it.
			Switch to the <i>data state</i>.

		<p>
			Otherwise,
			interpret the digits as a hexadecimal number.
			This is the <i>start of the range</i>.

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt>U+002D HYPHEN-MINUS (-)
		<dd>
			If the <i>next input character</i> is a <i>hex digit</i>,
			consume as many <i>hex digits</i> as possible, but no more than 6.
			Interpret the digits as a hexadecimal number.
			This is the <i>end of the range</i>.
			<i>Set the unicode-range token's range</i>, then emit it.
			Switch to the <i>data state</i>.

			<p>
				Otherwise,
				<i>set the unicode-range token's range</i>
				and emit it.
				Switch to the <i>data state</i>.
				Reconsume the <i>current input character</i>.

		<dt>anything else
		<dd>
			<i>Set the unicode-range token's range</i>
			and emit it.
			Switch to the <i>data state</i>.
			Reconsume the <i>current input character</i>.
	</dl>

<h4>
<dfn>Consume an escaped character</dfn></h4>

	<p>
		This section describes how to <i>consume an escaped character</i>.
		It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed
		and that the next input character has already been verified
		to not be a <i>newline</i> or EOF.
		It will return a character.

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt><i>hex digit</i>
		<dd>
			Consume as many <i>hex digits</i> as possible, but no more than 5.
			<span class='note'>Note that this means 1-6 hex digits have been consumed in total.</span>
			If the <i>next input character</i> is
			<i>whitespace</i>,
			consume it as well.
			Interpret the <i>hex digits</i> as a hexadecimal number.
			If this number is greater than 
			the <i>maximum allowed codepoint</i>,
			return U+FFFD REPLACEMENT CHARACTER.
			Otherwise, return the character with that codepoint.

		<dt>anything else
		<dd>
			Return the <i>current input character</i>.
	</dl>

<h4>
<dfn>Set the unicode-range token's range</dfn></h4>

	<p>
		This section describes how to set a unicode-range token's range
		so that the range it describes 
		is within the supported range of unicode characters.

	<p>
		It assumes that the <dfn>start of the range</dfn> has been defined,
		the <dfn>end of the range</dfn> might be defined,
		and both are non-negative integers.

	<p>
		If the <i>start of the range</i> is greater than
		the <i>maximum allowed codepoint</i>,
		the unicode-range token's range is empty.

	<p>
		If the <i>end of the range</i> is defined,
		and it is less than the <i>start of the range</i>,
		the unicode-range token's range is empty.

	<p>
		If the <i>end of the range</i> is not defined,
		the unicode-range token's range
		is the single character whose codepoint is the <i>start of the range</i>.

	<p>
		Otherwise,
		if the <i>end of the range</i> is greater than
		the <i>maximum allowed codepoint</i>,
		change it to the <i>maximum allowed codepoint</i>.
		The unicode-range token's range
		is all characters between
		the character whose codepoint is the <i>start of the range</i>
		and the character whose codepoint is the <i>end of the range</i>.

<!--
PPPPPPPPPPPPPPPPP        AAA               RRRRRRRRRRRRRRRRR      SSSSSSSSSSSSSSS EEEEEEEEEEEEEEEEEEEEEERRRRRRRRRRRRRRRRR   
P::::::::::::::::P      A:::A              R::::::::::::::::R   SS:::::::::::::::SE::::::::::::::::::::ER::::::::::::::::R  
P::::::PPPPPP:::::P    A:::::A             R::::::RRRRRR:::::R S:::::SSSSSS::::::SE::::::::::::::::::::ER::::::RRRRRR:::::R 
PP:::::P     P:::::P  A:::::::A            RR:::::R     R:::::RS:::::S     SSSSSSSEE::::::EEEEEEEEE::::ERR:::::R     R:::::R
  P::::P     P:::::P A:::::::::A             R::::R     R:::::RS:::::S              E:::::E       EEEEEE  R::::R     R:::::R
  P::::P     P:::::PA:::::A:::::A            R::::R     R:::::RS:::::S              E:::::E               R::::R     R:::::R
  P::::PPPPPP:::::PA:::::A A:::::A           R::::RRRRRR:::::R  S::::SSSS           E::::::EEEEEEEEEE     R::::RRRRRR:::::R 
  P:::::::::::::PPA:::::A   A:::::A          R:::::::::::::RR    SS::::::SSSSS      E:::::::::::::::E     R:::::::::::::RR  
  P::::PPPPPPPPP A:::::A     A:::::A         R::::RRRRRR:::::R     SSS::::::::SS    E:::::::::::::::E     R::::RRRRRR:::::R 
  P::::P        A:::::AAAAAAAAA:::::A        R::::R     R:::::R       SSSSSS::::S   E::::::EEEEEEEEEE     R::::R     R:::::R
  P::::P       A:::::::::::::::::::::A       R::::R     R:::::R            S:::::S  E:::::E               R::::R     R:::::R
  P::::P      A:::::AAAAAAAAAAAAA:::::A      R::::R     R:::::R            S:::::S  E:::::E       EEEEEE  R::::R     R:::::R
PP::::::PP   A:::::A             A:::::A   RR:::::R     R:::::RSSSSSSS     S:::::SEE::::::EEEEEEEE:::::ERR:::::R     R:::::R
P::::::::P  A:::::A               A:::::A  R::::::R     R:::::RS::::::SSSSSS:::::SE::::::::::::::::::::ER::::::R     R:::::R
P::::::::P A:::::A                 A:::::A R::::::R     R:::::RS:::::::::::::::SS E::::::::::::::::::::ER::::::R     R:::::R
PPPPPPPPPPAAAAAAA                   AAAAAAARRRRRRRR     RRRRRRR SSSSSSSSSSSSSSS   EEEEEEEEEEEEEEEEEEEEEERRRRRRRR     RRRRRRR
-->

<h3>
Tree Construction</h3>

	<p>
		The input to the tree construction stage is a sequence of tokens from the tokenization stage.
		The tree construction stage is associated with a stylesheet
		(sometimes a full CSSStyleSheet object, other times a "virtual" stylesheet).
		The "output" of this stage consists of dynamically modifying or extending that stylesheet's CSSOM.

<h4>
Creating and Inserting Rules</h4>
	
	<p>
		...

<h4>
Terms</h4>

	<dl>
		<dt><dfn>Stack of pending rules</dfn>
		<dd>
			...

		<dt><dfn>Stack of open blocks</dfn>
	</dl>

<h4>
<dfn>Top-level insertion mode</dfn>

	<p>
		Consume the next input token.

	<dl>
		<dt>cdo token
		<dt>cdc token
		<dt>whitespace token
		<dd>
			Do nothing.
			Remain in this mode.

		<dt>at-keyword token
		<dd>
			If the at-keyword's value is the name of an at-rule that the UA recognizes,
			create a new <i>AtRule</i> rule
			and push it onto the <i>stack of pending rules</i>.
			Switch to the <i>after at-keyword insertion mode</i>.

			<p>
				Otherwise, this is a <i>parse error</i>.
				Switch to the <i>at-rule error mode</i>.

		<dt>start-block token
		<dd>
			This is a <i>parse error</i>.
			Push the token onto the <i>stack of open blocks</i>.
			Switch to the <i>block error mode</i>.

		<dt>anything else
		<dd>
			Create a new <i>Style</i> rule
			and append it to the <i>stack of pending rules</i>.
			Switch to the <i>in selector mode</i>.
			Reprocess the <i>current input token</i>.
	</dl>



<!--
    
TTTTTTTTTTTTTTTTTTTTTTTHHHHHHHHH     HHHHHHHHHEEEEEEEEEEEEEEEEEEEEEE
T:::::::::::::::::::::TH:::::::H     H:::::::HE::::::::::::::::::::E
T:::::::::::::::::::::TH:::::::H     H:::::::HE::::::::::::::::::::E
T:::::TT:::::::TT:::::THH::::::H     H::::::HHEE::::::EEEEEEEEE::::E
TTTTTT  T:::::T  TTTTTT  H:::::H     H:::::H    E:::::E       EEEEEE
        T:::::T          H:::::H     H:::::H    E:::::E             
        T:::::T          H::::::HHHHH::::::H    E::::::EEEEEEEEEE   
        T:::::T          H:::::::::::::::::H    E:::::::::::::::E   
        T:::::T          H:::::::::::::::::H    E:::::::::::::::E   
        T:::::T          H::::::HHHHH::::::H    E::::::EEEEEEEEEE   
        T:::::T          H:::::H     H:::::H    E:::::E             
        T:::::T          H:::::H     H:::::H    E:::::E       EEEEEE
      TT:::::::TT      HH::::::H     H::::::HHEE::::::EEEEEEEE:::::E
      T:::::::::T      H:::::::H     H:::::::HE::::::::::::::::::::E
      T:::::::::T      H:::::::H     H:::::::HE::::::::::::::::::::E
      TTTTTTTTTTT      HHHHHHHHH     HHHHHHHHHEEEEEEEEEEEEEEEEEEEEEE
                                                                    
                                                                    
                                                                   
EEEEEEEEEEEEEEEEEEEEEENNNNNNNN        NNNNNNNNDDDDDDDDDDDDD        
E::::::::::::::::::::EN:::::::N       N::::::ND::::::::::::DDD     
E::::::::::::::::::::EN::::::::N      N::::::ND:::::::::::::::DD   
EE::::::EEEEEEEEE::::EN:::::::::N     N::::::NDDD:::::DDDDD:::::D  
  E:::::E       EEEEEEN::::::::::N    N::::::N  D:::::D    D:::::D 
  E:::::E             N:::::::::::N   N::::::N  D:::::D     D:::::D
  E::::::EEEEEEEEEE   N:::::::N::::N  N::::::N  D:::::D     D:::::D
  E:::::::::::::::E   N::::::N N::::N N::::::N  D:::::D     D:::::D
  E:::::::::::::::E   N::::::N  N::::N:::::::N  D:::::D     D:::::D
  E::::::EEEEEEEEEE   N::::::N   N:::::::::::N  D:::::D     D:::::D
  E:::::E             N::::::N    N::::::::::N  D:::::D     D:::::D
  E:::::E       EEEEEEN::::::N     N:::::::::N  D:::::D    D:::::D 
EE::::::EEEEEEEE:::::EN::::::N      N::::::::NDDD:::::DDDDD:::::D  
E::::::::::::::::::::EN::::::N       N:::::::ND:::::::::::::::DD   
E::::::::::::::::::::EN::::::N        N::::::ND::::::::::::DDD     
EEEEEEEEEEEEEEEEEEEEEENNNNNNNN         NNNNNNNDDDDDDDDDDDDD        
-->

<h2 id="conformance">
Conformance</h2>

<h3 id="conventions">
Document conventions</h3>

	<p>Conformance requirements are expressed with a combination of
	descriptive assertions and RFC 2119 terminology. The key words “MUST”,
	“MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
	“RECOMMENDED”, “MAY”, and “OPTIONAL” in the normative parts of this
	document are to be interpreted as described in RFC 2119.
	However, for readability, these words do not appear in all uppercase
	letters in this specification.
	
	<p>All of the text of this specification is normative except sections
	explicitly marked as non-normative, examples, and notes. [[!RFC2119]]</p>
	
	<p>Examples in this specification are introduced with the words “for example”
	or are set apart from the normative text with <code>class="example"</code>,
	like this:
	
	<div class="example">
		<p>This is an example of an informative example.</p>
	</div>
	
	<p>Informative notes begin with the word “Note” and are set apart from the
	normative text with <code>class="note"</code>, like this:
	
	<p class="note">Note, this is an informative note.</p>

<h3 id="conformance-classes">
Conformance classes</h3>

	<p>Conformance to <var class="replaceme">CSS TEMPLATE Module</var>
	is defined for three conformance classes:
	<dl>
		<dt><dfn title="style sheet!!as conformance class">style sheet</dfn>
			<dd>A <a href="http://www.w3.org/TR/CSS21/conform.html#style-sheet">CSS
			style sheet</a>.
		<dt><dfn>renderer</dfn></dt>
			<dd>A <a href="http://www.w3.org/TR/CSS21/conform.html#user-agent">UA</a>
			that interprets the semantics of a style sheet and renders
			documents that use them.
		<dt><dfn id="authoring-tool">authoring tool</dfn></dt>
			<dd>A <a href="http://www.w3.org/TR/CSS21/conform.html#user-agent">UA</a>
			that writes a style sheet.
	</dl>
	
	<p>A style sheet is conformant to <var class="replaceme">CSS TEMPLATE Module</var>
	if all of its statements that use syntax defined in this module are valid
	according to the generic CSS grammar and the individual grammars of each
	feature defined in this module.
	
	<p>A renderer is conformant to <var class="replaceme">CSS TEMPLATE Module</var>
	if, in addition to interpreting the style sheet as defined by the
	appropriate specifications, it supports all the features defined
	by <var class="replaceme">CSS TEMPLATE Module</var> by parsing them correctly
	and rendering the document accordingly. However, the inability of a
	UA to correctly render a document due to limitations of the device
	does not make the UA non-conformant. (For example, a UA is not
	required to render color on a monochrome monitor.)
	
	<p>An authoring tool is conformant to <var class="replaceme">CSS TEMPLATE Module</var>
	if it writes style sheets that are syntactically correct according to the
	generic CSS grammar and the individual grammars of each feature in
	this module, and meet all other conformance requirements of style sheets
	as described in this module.

<h3 id="partial">
Partial implementations</h3>

	<p>So that authors can exploit the forward-compatible parsing rules to
	assign fallback values, CSS renderers <strong>must</strong>
	treat as invalid (and <a href="http://www.w3.org/TR/CSS21/conform.html#ignore">ignore
	as appropriate</a>) any at-rules, properties, property values, keywords,
	and other syntactic constructs for which they have no usable level of
	support. In particular, user agents <strong>must not</strong> selectively
	ignore unsupported component values and honor supported values in a single
	multi-value property declaration: if any value is considered invalid
	(as unsupported values must be), CSS requires that the entire declaration
	be ignored.</p>
	
<h3 id="experimental">
Experimental implementations</h3>

	<p>To avoid clashes with future CSS features, the CSS2.1 specification
	reserves a <a href="http://www.w3.org/TR/CSS21/syndata.html#vendor-keywords">prefixed
	syntax</a> for proprietary and experimental extensions to CSS.
	
	<p>Prior to a specification reaching the Candidate Recommendation stage
	in the W3C process, all implementations of a CSS feature are considered
	experimental. The CSS Working Group recommends that implementations
	use a vendor-prefixed syntax for such features, including those in
	W3C Working Drafts. This avoids incompatibilities with future changes
	in the draft.
	</p>
 
<h3 id="testing">
Non-experimental implementations</h3>

	<p>Once a specification reaches the Candidate Recommendation stage,
	non-experimental implementations are possible, and implementors should
	release an unprefixed implementation of any CR-level feature they
	can demonstrate to be correctly implemented according to spec.
	
	<p>To establish and maintain the interoperability of CSS across
	implementations, the CSS Working Group requests that non-experimental
	CSS renderers submit an implementation report (and, if necessary, the
	testcases used for that implementation report) to the W3C before
	releasing an unprefixed implementation of any CSS features. Testcases
	submitted to W3C are subject to review and correction by the CSS
	Working Group.
	
	<p>Further information on submitting testcases and implementation reports
	can be found from on the CSS Working Group's website at
	<a href="http://www.w3.org/Style/CSS/Test/">http://www.w3.org/Style/CSS/Test/</a>.
	Questions should be directed to the
	<a href="http://lists.w3.org/Archives/Public/public-css-testsuite">public-css-testsuite@w3.org</a>
	mailing list.

<h3 id="cr-exit-criteria">
CR exit criteria</h3>

	<p class=issue>[Change or remove the following CR exit criteria if
	the spec is not a module, but, e.g., a Note or a profile. This text was <a
	href="http://www.w3.org/Style/CSS/Tracker/actions/44"> decided on 2008-06-04.</a>]</p>

	<p>
	For this specification to be advanced to Proposed Recommendation,
	there must be at least two independent, interoperable implementations
	of each feature. Each feature may be implemented by a different set of
	products, there is no requirement that all features be implemented by
	a single product. For the purposes of this criterion, we define the
	following terms:
	
	<dl>
		<dt>independent <dd>each implementation must be developed by a
		different party and cannot share, reuse, or derive from code
		used by another qualifying implementation. Sections of code that
		have no bearing on the implementation of this specification are
		exempt from this requirement.
	
		<dt>interoperable <dd>passing the respective test case(s) in the
		official CSS test suite, or, if the implementation is not a Web
		browser, an equivalent test. Every relevant test in the test
		suite should have an equivalent test created if such a user
		agent (UA) is to be used to claim interoperability. In addition
		if such a UA is to be used to claim interoperability, then there
		must one or more additional UAs which can also pass those
		equivalent tests in the same way for the purpose of
		interoperability. The equivalent tests must be made publicly
		available for the purposes of peer review.
	
		<dt>implementation <dd>a user agent which:
	
		<ol class=inline>
			<li>implements the specification.
	
			<li>is available to the general public. The implementation may
			be a shipping product or other publicly available version
			(i.e., beta version, preview release, or “nightly build”). 
			Non-shipping product releases must have implemented the
			feature(s) for a period of at least one month in order to
			demonstrate stability.
	
			<li>is not experimental (i.e., a version specifically designed
			to pass the test suite and is not intended for normal usage
			going forward).
		</ol>
	</dl>
	
	<p>The specification will remain Candidate Recommendation for at least
	six months.

<h2 class=no-num id="acknowledgments">
Acknowledgments</h2>

	<p><var class="replaceme">[acknowledgments]</var></p>

<h2 class=no-num id="references">
References</h2>

<h3 class="no-num" id="normative-references">
Normative references</h3>
<!--normative-->

<h3 class="no-num" id="other-references">
Other references</h3>
<!--informative-->

<h2 class="no-num" id="index">
Index</h2>
<!--index-->

<h2 class="no-num" id="property-index">
Property index</h2>
<!-- properties -->

</body>
</html>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-declaration:"~/SGML/HTML4.decl"
sgml-default-doctype-name:"html"
sgml-minimize-attributes:t
sgml-nofill-elements:("pre" "style" "br")
sgml-live-element-indicator:t
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:t
sgml-general-insert-case:lower
sgml-always-quote-attributes:t
sgml-indent-step:nil
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
 
