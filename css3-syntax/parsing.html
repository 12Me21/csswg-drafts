CSS Syntax

<h2>Parsing</h2>

<h3>
Parsing CSS Documents</h3>

	<p>
		User agents must use the parsing rules described in this section to generate the CSSOM trees from text/css resources. 
		Together, these rules define what is referred to as the CSS parser.

	<p>
		This specification defines the parsing rules for CSS documents, whether they are syntactically correct or not. 
		Certain points in the parsing algorithm are said to be parse errors. 
		The error handling for parse errors is well-defined: 
		user agents must either act as described below when encountering such problems, 
		or must abort processing at the first error that they encounter for which they do not wish to apply the rules described below.

	<p>
		Conformance checkers must report at least one parse error condition to the user if one or more parse error conditions exist in the document and must not report parse error conditions if none exist in the document. 
		Conformance checkers may report more than one parse error condition if more than one parse error condition exists in the document. 
		Conformance checkers are not required to recover from parse errors.

<h3>
Overview of the Parsing Model</h3>

	<p>
		The input to the CSS parsing process consists of a stream of Unicode code points, 
		which is passed through a tokenization stage followed by a tree construction stage. 
		The output is a Stylesheet object.

	<p class='note'>
		Implementations that do not support scripting do not have to actually create a CSSOM Stylesheet object, 
		but the CSSOM tree in such cases is still used as the model for the rest of the specification.

<h3>
The input byte stream</h3>

	<p>
		...

<h3>
Determining the character encoding</h3>

	<p>
		...

<h3>
Preprocessing the input stream</h3>

	<p>
		The input stream consists of the characters pushed into it as the input byte stream is decoded or from the various APIs that directly manipulate the input stream.

	<p>
		One leading U+FEFF BYTE ORDER MARK character must be ignored if any are present in the input stream.

	<p class='note'>
		The requirement to strip a U+FEFF BYTE ORDER MARK character regardless of whether that character was used to determine the byte order is a willful violation of Unicode, motivated by a desire to increase the resilience of user agents in the face of na√Øve transcoders.

	<p>
		Any occurrences of any characters in the ranges U+0001 to U+0008, U+000E to U+001F, U+007F to U+009F, U+FDD0 to U+FDEF, and characters U+000B, U+FFFE, U+FFFF, U+1FFFE, U+1FFFF, U+2FFFE, U+2FFFF, U+3FFFE, U+3FFFF, U+4FFFE, U+4FFFF, U+5FFFE, U+5FFFF, U+6FFFE, U+6FFFF, U+7FFFE, U+7FFFF, U+8FFFE, U+8FFFF, U+9FFFE, U+9FFFF, U+AFFFE, U+AFFFF, U+BFFFE, U+BFFFF, U+CFFFE, U+CFFFF, U+DFFFE, U+DFFFF, U+EFFFE, U+EFFFF, U+FFFFE, U+FFFFF, U+10FFFE, and U+10FFFF are parse errors. These are all control characters or permanently undefined Unicode characters (noncharacters).

	<p>
		U+000D CARRIAGE RETURN (CR) characters and U+000A LINE FEED (LF) characters are treated specially. All CR characters must be converted to LF characters, and any LF characters that immediately follow a CR character must be ignored. Thus, newlines in HTML DOMs are represented by LF characters, and there are never any CR characters in the input to the tokenization stage.

	<p>
		The next input character is the first character in the input stream that has not yet been consumed or explicit ignored by the requirements in this section. Initially, the next input character is the first character in the input. The current input character is the last character to have been consumed.

	<p>
		The insertion point is the position (just before a character or just before the end of the input stream) where content inserted using document.write() is actually inserted. The insertion point is relative to the position of the character immediately after it, it is not an absolute offset into the input stream. Initially, the insertion point is undefined.

	<p>
		The "EOF" character in the tables below is a conceptual character representing the end of the input stream.

<h3>
Parse State</h3>

<h3>
Tokenization</h3>

	<p>
		...

<h4>
Definitions</h4>

	<p>
		This section defines several terms used during the tokenization phase.

	<dl>
		<dt><dfn>digit</dfn>
		<dd>
			A character between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9)

		<dt><dfn>hexadecimal character</dfn>
		<dd>
			A <i>digit</i>, or a character between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).


	</dl>

<h4>
<dfn>Top-level State</dfn></h4>

	<p>
		Consume the <i>next input character</i>:

	<dl>
		<dt><i>whitespace</i>
		<dd>
			Do nothing, and remain in this state.

		<dt>U+003C LESS-THAN SIGN (&lt;)
		<dd>
			Switch to the <i>cdo-1 state</i>.

		<dt>U+002D HYPHEN-MINUS (-)
		<dd>
			Switch to the <i>cdc-1 state</i>

		<dt>U+0040 COMMERCIAL AT (@)
		<dd>
			Switch to the <i>at-keyword-start state</i>.

		<dt>U+002F SOLIDUS (/)
		<dd>
			Record the <i>top-level state</i> as the <i>last visited state</i>.
			Switch to the <i>comment state</i>.

		<dt>U+007B LEFT CURLY BRACKET ({)
		<dd>
			<i>Parse error</i>. 
			Switch to the <i>block-error state</i>.

		<dt>anything else
		<dd>
			Create a new selector token
			with its value initially set to the <i>current input character</i>.

			<p>
				Switch to the <i>selector state</i>.
	</dl>

<h4>
<dfn>CDO-1 state</dfn></h4>

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt>U+0021 EXCLAMATION MARK (!)
		<dd>
			Switch to the <i>cdo-2 state</i>.

		<dt>anything else
		<dd>
			Create a new selector token
			with its value initially set to U+003C LESS-THAN SIGN (&lt;).

			<p>
				Switch to the <i>selector state</i>.  Reconsume the <i>current input character</i>.
	</dl>

<h4>
<dfn>CDO-2 state</dfn></h4>

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt>U+002D HYPHEN-MINUS (-)
		<dd>
			Switch to the <i>cdo-3 state</i>.

		<dt>anything else
		<dd>
			Create a new selector token
			with its value initially set to U+003C LESS-THAN SIGN U+0021 EXCLAMATION MARK (&lt;!).

			<p>
				Switch to the <i>selector state</i>.  Reconsume the <i>current input character</i>.
	</dl>

<h4>
<dfn>CDO-3 state</dfn></h4>

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt>U+002D HYPHEN-MINUS (-)
		<dd>
			Switch to the <i>top-level state</i>.

		<dt>anything else
		<dd>
			Create a new selector token
			with its value initially set to U+003C LESS-THAN SIGN U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS (&lt;!-).

			<p>
				Switch to the <i>selector state</i>.  Reconsume the <i>current input character</i>.
	</dl>

<h4>
<dfn>CDC-1 state</dfn></h4>

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt>U+002D HYPHEN-MINUS (-)
		<dd>
			Switch to the <i>cdc-2 state</i>.

		<dt>anything else
		<dd>
			Create a new selector token
			with its value initially set to U+002D HYPHEN-MINUS (-).

			<p>
				Switch to the <i>selector state</i>.  Reconsume the <i>current input character</i>.
	</dl>

<h4>
<dfn>CDC-2 state</dfn></h4>

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt>U+003E GREATER-THAN SIGN (>)
		<dd>
			Switch to the <i>top-level state</i>.

		<dt>anything else
		<dd>
			Create a new selector token
			with its value initially set to U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (--).

			<p>
				Switch to the <i>selector state</i>.  Reconsume the <i>current input character</i>.
	</dl>


<h4>
<dfn>At-keyword-start state</dfn></h4>

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt><i>whitespace</i>
		<dd>
			Do nothing, and remain in this state.

		<dt>U+002F SOLIDUS (/)
		<dd>
			Record the <i>at-keyword-start state</i> as the <i>last visited state</i>.
			Switch to the <i>comment state</i>.

		<dt>anything else
		<dd>
			Switch to the <i>at-keyword-ident state</i>. Reconsume the <i>current input character</i>.
	</dl>

<h4>
<dfn>At-keyword-ident state</dfn></h4>

	<p>
		Attempt to <i>consume an identifier</i>.

	<p>
		If an identifier token is returned,
		emit an at-keyword token with its value set to the returned identifier's value.
		Switch to the <i>at-keyword-after-ident state</i>.

	<p>
		Otherwise,
		switch to the <i>block-or-statement-error state</i>.

<h4>
<dfn>At-keyword-after-ident state</dfn></h4>

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt><i>whitespace</i>
		<dd>
			Do nothing, and remain in this state.

		<dt>U+002F SOLIDUS (/)
		<dd>
			Record the <i>at-keyword-after-ident state</i> as the <i>last visited state</i>.
			Switch to the <i>comment state</i>.

		<dt>U+003B SEMICOLON (;)
		<dd>
			Emit a semicolon token.
			Switch to the <i>top-level state</i>.

		<dt>U+007B LEFT CURLY BRACKET ({)
		<dd>
			Emit a start-block token.
			Switch to the <i>in-block state</i>.

		<dt>anything else
		<dd>
			Switch to the <i>at-keyword-extra state</i>.
			Reconsume the <i>current input character</i>.
	</dl>

<h4>
Tokenizing an identifier</h4>

	<p>
		This section defines how to <dfn>consume an identifier</dfn>.  
		Create a new identifier token with a value initially equal to the empty string.

	<p>
		If the <i>next input character</i> is U+0029 HYPHEN-MINUS, 
		consume the <i>next input character</i>
		and append it to the identifier token's value.

	<p>
		Consume the <i>next input character</i>.

	<dl>
		<dt>U+0041 LATIN CAPITAL LETTER A (A) to U+005A LATIN CAPITAL LETTER Z (Z)
		<dt>U+0061 LATIN SMALL LETTER A (a) to U+007A LATIN SMALL LETTER Z (z)
		<dt>U+005F LOW LINE (_)
		<dd>
			Append the character to the identifier token's value.

		<dt>U+005C REVERSE SOLIDUS (\)
		<dd>
			Attempt to <i>consume an escaped character</i>.
			If nothing is returned, reconsume all characters consumed in this step
			and return nothing.

		<dt>anything else
		<dd>
			Reconsume all characters consumed in this step
			and return nothing.

	</dl>

	<p>
		Attempt to consume the maximum number of <i title="consume an ident-rest character">ident-rest characters</i>.
		Append any such returned characters to the identifier token's value in order.

	<p>
		Return the identifer token.

<h4>
Tokenizing an unescaped character</h4>

	<p>
		This section defines how to <dfn>consume an unescaped character</dfn>.

	<p>
		Attempt to consume 1-6 <i>hexadecimal digits</i>
		and optionally a single character of <i>whitespace</i> following them.
		If anything was consumed, 
		interpret the digits as a hexadecimal number
		and return the character with that codepoint.

	<p>
		If nothing was consumed, 
		and the <i>next input character</i> isn't a <i>whitespace</i> or EOF character,
		consume the <i>next input character</i>
		and return the <i>current input character</i>.

	<p>
		Otherwise, return nothing.