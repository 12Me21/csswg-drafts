<!doctype html public '-//W3C//DTD HTML 4.01//EN'>

<head profile="http://www.w3.org/2006/03/hcard
  http://microformats.org/wiki/rel-license">

<title>CSS basic box model</title>

<style type="text/css">
  ol.stack p {margin-top: 0}
</style>

<link rel=contents href="#contents">
<link href="../default.css" rel="stylesheet"
  title="Default" type="text/css">
<link href="http://www.w3.org/StyleSheets/TR/W3C-MO.css" rel="stylesheet"
  title="Default" type="text/css">




<div class="head">
<!--logo-->

<h1>CSS basic box model</h1>

<h2 class="no-num no-toc">[LONGSTATUS] [DATE: 26 Sep 2006]</h2>
<dl>
  <dt>This version:
    <dd><a href="[VERSION]">
	http://www.w3.org/TR/[YEAR]/ED-css3-box-[CDATE]</a>
  <dt>Latest version:
    <dd><a href="http://www.w3.org/TR/css3-box">
	http://www.w3.org/TR/css3-box</a>
  <dt>Previous version:
    <dd><a href="http://www.w3.org/TR/2002/WD-css3-box-20021024">
	http://www.w3.org/TR/2002/WD-css3-box-20021024</a>
  <dt>Editors:
    <dd class=vcard><span class=fn>Bert Bos</span> (<span
    class=org>W3C</span>) <span class=email>bert@w3.org</span>
</dl>
<!--copyright-->
<hr title="Separator for header">
</div>



<h2 class="no-num no-toc">Abstract</h2>

<p><abbr title="Cascading Style Sheets">CSS</abbr> describes the
rendering of documents on various media. When textual documents (e.g.,
HTML) are laid out on visual media (e.g., screen or print), CSS models
their layout as a collection of rectangular boxes containing words, lines,
paragraphs, tables, etc., each with properties such as size, color and
font.

<p>This module describes the basic types of boxes: block, list item,
inline, etc.; and some of their properties, including margins, padding
and width/height. It defines a layout called a “flow,” in which a
series of boxes is laid out one after the other, and it defines 
“floating” boxes. Other kinds of layout, such as tables, absolute
positioning, ruby annotations, grid layouts, columns and page boxes,
are described by other modules. Also, the layout of text inside a line
(including the handling of left-to-right and right-to-left scripts) is
defined elsewhere.

<p>In CSS level 3, boxes may contain either horizontal or vertical text. 
Different orientations can be mixed.



<h2 class="no-toc no-num">Status of this document</h2>

<!--status-->

<p>The CSS Working Group plans to ask for W3C Recommendation status
for this specification only when there are sufficiently many
implementations. See the section <a href="#exit">“CR exit criteria”
</a> for details.

<p class=mtb>This module should eventually replace corresponding parts
of the revised CSS level 2 specification [[!CSS21]]. But this is an
early draft and any differences to level 2 are most likely
unintentional, unless they concern new features, such as vertical text
or float displacement. <em>Please help us improve the next draft by
pointing out such differences.</em>



<h2 class="no-num no-toc">Table of contents</h2>

<!--toc-->



<h2>How to read this specification</h2>

<p>All sections are normative, unless stated otherwise.

<div class=example>
<p>Examples look like this and normally start with the word
&ldquo;Example.&rdquo; Examples are not normative.
</div>

<p class=note>Notes look like this and normally start with the word
&ldquo;Note.&rdquo; Notes are not normative.

<p class=issue>Editorial notes look like this. They will be removed before
the document becomes Candidate Recommendation.

<p>Each property is defined in part in the text and in part by a table that
groups together a number of facts about the property, including a regular
expression to restrict its syntax. See <span class=issue>[where?]</span>
for the meaning. The &ldquo;Inherited&rdquo; and &ldquo;Initial&rdquo; rows
in the table are used by the Cascading and Inheritance module [[CSS3CASCADE]]
and &ldquo;Media&rdquo; by the Media Queries specification [[MEDIAQ]].

<p>The specification may refer to the <em>used value</em> and the
<em>computed value</em> of a property. Unless stated explicitly, the
short form “value” means the computed value.



<h2>Dependencies on other modules</h2>

<p>This CSS module depends on the following other CSS modules:

<ul>
  <li><cite>CSS Writing Modes Module</cite> [[!CSS3-WRITING-MODES]]
    &ndash; switch between vertical and horizontal text, properties
    <dfn>block-flow</dfn> and <dfn>direction</dfn>, definitions of the
    terms <dfn>block flow direction</dfn> and <dfn>inline base
    direction.</dfn>
  <li><cite>CSS Syntax Module</cite> [[!CSS3SYN]] &ndash; syntax of
    properties and values
  <li><cite>CSS Values and Units Module</cite> [[!CSS3VAL]] &ndash;
    definitions of value types <dfn><var>&lt;number&gt;</var></dfn>,
    <dfn><var>&lt;angle&gt;</var></dfn> and
    <dfn><var>&lt;length&gt;</var></dfn>; defines the terms <dfn>computed
    value</dfn> and <dfn>used value.</dfn>
  <li><cite>CSS Text Module</cite> [[!CSS3TEXT]] &ndash; inline layout and
    definition of <dfn>line box.</dfn>
  <li><cite>CSS Generated and Replaced Content module</cite> [[!CSS3GENCON]]
    &ndash; defines the terms <dfn>replaced element</dfn>
    and <dfn>intrinsic</dfn> size (and intrinsic ratio).
  <li><cite>CSS Backgrounds and Borders Module</cite> [[!CSS3BG]] &ndash;
    defines <dfn><var>&lt;bg-position&gt;</var></dfn>
  <li><cite>CSS Basic User Interface Module</cite> [[!CSS3UI]] &ndash;
    defines <dfn>box-sizing</dfn>
  <li><cite>CSS 2D Transforms</cite> [[!CSS3-2D-TRANSFORMS]] &ndash;
    defines <dfn>transform</dfn>
</ul>



<h2>Introduction &amp; definitions</h2>

<p class=issue>Investigate if it is possible to make a pseudo-element
to select anonymous boxes ('::paragraph'). See minutes of 10 Aug 2011.

<p class=note>Note: The model in this specification differs from the
model described in the CSS level 2 specification [[!CSS21]], because
it is generalized to apply also to vertical text.

<p>CSS assumes that the document to lay out is modeled as a <span
class=index title="tree!!of elements|document tree|element
tree">tree</span> of <dfn title="element">elements.</dfn> Each element
has an ordered list of zero or more child elements, with an optional
string of text before the list, in-between the children and after the
list. Each child has one parent, except for the unique element that
has no parent, which is called the <dfn>root element.</dfn>

<p>CSS describes how each element and each string of text is laid out
by transforming the document tree into a set of rectangular boxes,
whose size, position, and stacking level on the <em>canvas</em> depend
on their properties. We say that an element <dfn title="generated
box">generates</dfn> one or more boxes. There are <em>block-level</em>
boxes, <em title="line box">line boxes</em> and <em
title="inline-level">inline-level boxes.</em> A block-level box is
like a paragraph. A line box is like a line of text. Inline-level
boxes are like words inside a line.

<p>When the specification says a box <var>A</var> <dfn>contains</dfn>
a box <var>B</var>, then <var>B</var> is a box generated by an element
that is a descendant of the element that generated
<var>A</var>. Typically, box <var>B</var> is geometrically
contained in box <var>A</var> as well, but that need not be the case,
because of, e.g., overflow or negative margins.

<p class=note>Note: The precise rules are below and in other modules, but in
summary, a block-level box contains either other block-level boxes (e.g., a
section containing paragraphs, or a table containing rows), or it contains
line boxes (e.g., a paragraph containing lines of text). A line box contains
inline-level boxes (e.g., a line with words in different styles). An
inline-level box may contain either text interspersed with more inline-level
boxes, or it may contain a block-level box (e.g., a small table that is
rendered inline).

<div class=figure>
  <p><img src="box-intro.png" alt="Schematic representation of rel">

  <p class="caption">Relation between four displayed boxes in the
  rendered document (on the right) and the three corresponding
  elements in the source document on the (left).
</div>

<div class=example>
<p>For example, a fragment of HTML such as
<pre>&lt;ul&gt;
 &lt;li&gt;The first item in the list.
 &lt;li&gt;The second item.
&lt;/ul&gt;</pre>

<p>may result in one block-level box for the <code>ul</code> element,
containing two block-level boxes for the two <code>li</code> elements, each
of which has one line box (i.e., one line of text). Both line boxes contain
two inline-level boxes: one that contains the list bullet and one that
contains the text.

<p>Note how the <code>li</code> is transformed into multiple boxes, including
one that contains &ldquo;generated content,&rdquo; viz., the list bullet,
which is not present in the source document.

<p>If the document is rendered in a narrow window, it may be that the
<code>li</code> elements get transformed into even more boxes, because the
text requires multiple lines. And if the document is rendered on paper, it
may be that a page break falls in the middle of the <code>ul</code> element,
so that it is not transformed into a single block-level box, but into two
smaller ones, each on a different page.
</div>

<p>Each box belongs to exactly one element. It is either <span
title="generated box">generated</span> directly by the element, or it
is an <em>anonymous box</em> (defined below), which is inserted
because the layout rules of CSS require a box to contain a certain
kind of other box, but the boxes generated by the child elements are
not of that kind. The anonymous box is defined to belong to the
parent.

<p class=note>Note: This is mainly important for <span
class=index>WYSIWYG document editors</span>: if the user selects a box
on the screen in order to set a property, the editor knows which
element to set the property on.

<p>Properties are set on elements and influence how the element is turned
into boxes, but in this specification we refer interchangeably to &ldquo;the
<var>P</var> property of an element&rdquo; and &ldquo;the <var>P</var>
property of a box&rdquo; (both of which actually mean &ldquo;<em>the
value</em> of property <var>P</var> of&hellip;&rdquo;), unless it is
important to distinguish the box and the element, e.g., because the element
has several boxes and they don't all have the same value for the property.

<div class=figure id=various>
  <p><img src="box.png" alt="Diagram of a typical box, showing the
  content, padding, border and margin areas">

  <p class="caption">The various areas and edges of a typical box
</div>

<p>Boxes have padding, a border and margins (see the <a
href="#various">figure</a>). Different properties determine the
thickness of each of these (which may be zero). The margins are also
subject to <em title="collapse">collapsing.</em>

<p>Each box has a <dfn>content area</dfn> (a.k.a. <dfn>content
box</dfn>). The rectangle that bounds this area is the <dfn>content
edge.</dfn> Around the content area is the <dfn>padding area</dfn> and
its outside bounds are called the <dfn>padding edge.</dfn> The padding
area and content area together form the <dfn>padding box.</dfn>
Outside the padding is the <dfn>border area</dfn> and the outside
boundary of that area is the <dfn>border edge.</dfn> The border area,
padding area and content area together form the <dfn>border box.</dfn>
Finally, outside the border is the <dfn>margin area</dfn> and its
outer edge is the <dfn>margin edge.</dfn>

<p>When the specification says that the padding or border is
&ldquo;absent&rdquo; on some side of the box, that actually means that its
thickness is zero.

<p><em title="line box">Line boxes</em> cannot have any padding,
border or margin, and therefore their margin edge, border edge,
padding edge and content edge all coincide.

<p class=note>Note that the margin, unlike the border and padding, may have
a negative thickness. That is one way to make adjacent boxes overlap each
other.

<p class=note>Note that the edges always form rectangles, even if
there is a 'border-radius' [[CSS3BG]].

<p>A box or element is <dfn>vertical</dfn> if its 'block-flow'
property is ''lr'' or ''rl'', otherwise it is <dfn>horizontal.</dfn>
The <dfn>writing mode</dfn> of a box or element is the pair of values
of its 'block-flow' and 'direction' (''ltr'' or ''rtl''). I.e., there
are eight writing modes: four horizontal ones and four vertical ones.

<p>This specification sometimes refers to abstract edges
<dfn>head,</dfn> <dfn>end,</dfn> <dfn>tail</dfn> and <dfn>start,</dfn>
which are relative to the writing mode of a box. They map to top,
right, bottom and left as follows:

    <table class=equiv-table>
      <thead>
	<tr>
	  <th>Value of 'block-flow'
	  <th>Value of 'direction'
	  <th>Meaning of “head”
	  <th>Meaning of “end”
	  <th>Meaning of “tail”
	  <th>Meaning of “start”
      <tbody>
	<tr><th>''tb'' <th>''ltr'' <td>top <td>right <td>bottom <td>left
	<tr><th>''tb'' <th>''rtl'' <td>top <td>left <td>bottom <td>right
	<tr><th>''bt'' <th>''ltr'' <td>bottom <td>right <td>top <td>left
	<tr><th>''bt'' <th>''rtl'' <td>bottom <td>left <td>top <td>right
	<tr><th>''rl'' <th>''ltr'' <td>right <td>bottom <td>left <td>top
	<tr><th>''rl'' <th>''rtl'' <td>right <td>top <td>left <td>bottom
	<tr><th>''lr'' <th>''rtl'' <td>left <td>bottom <td>right <td>top
	<tr><th>''lr'' <th>''ltr'' <td>left <td>top <td>right <td>bottom
    </table>

<p>For example, the “head padding” by default refers to the
'padding-top' and the “end border” is by default the 'border-right'.

<p>Similarly, the specification sometimes refers to the
<dfn title="inline dimension">inline</dfn> and <dfn title="block flow
dimension">block flow</dfn> dimensions of a box, instead of width and
height, as follows:

  <table class=equiv-table>
   <tr>
    <th>Value of 'block-flow'
    <th>Meaning of “inline dimension”
    <th>Meaning of “block flow dimension”
   <tr><td>tb <td>width <td>height
   <tr><td>rl <td>height <td>width
   <tr><td>lr <td>height <td>width
  </table>

<p>These correspond to the dimensions in the <em>inline base
direction</em> and the <em>block flow direction,</em> respectively.

<p>Finally, the <dfn>headside,</dfn> <dfn>endside,</dfn>
<dfn>tailside</dfn> and <dfn>startside</dfn> of a box are defined as
the sides that correspond to the <em>head,</em> <em>end,</em>
<em>tail</em> and <em>start,</em> of the <em>containing block</em> of
the box.

<div class=example>
  <p>For example, if a box has a 'block-flow' of ''tb'', then its top
  content edge acts as its <em>head</em> content edge, and the
  <em>headside</em> edges of its children are therefore their top
  edges, independent of what their own 'block-flow' is.

  <div class=figure>
    <p><img src="headside" alt="[Figure: the “head content edge” of
    the child box the right edge, but the“headside content edge” is
    the top.]">

    <p class=caption>The second child box is a vertical box and has
    its “head” content edge on the right. But its “headside” 
    content edge is at the top.
  </div>
</div>

<p class=issue>Check terms. At Cambridge ftf Aug 2008 we chose:
Property name: block-flow with values tb | lr | rl | bt. Descriptive
terms: horizontal mode (= tb &amp; bt), vertical mode (= lr &amp; rl)



<h2>The viewport and the canvas</h2>

<p>User agents for continuous media generally offer users a
<dfn>viewport</dfn> (a window or other viewing area on the screen)
through which users consult a document. User agents may change the
document's layout when the viewport is resized (see the <em>initial
containing block</em>).

<p>When the viewport is smaller than the area of the <em>canvas</em>
(see below) on which the document is rendered, the user agent should
offer a scrolling mechanism. There is at most one viewport per canvas,
but user agents may render to more than one canvas (i.e., provide
different views of the same document).

<p>For all media, the term <dfn>canvas</dfn> describes the space where
the formatting structure is rendered. The canvas is infinite for each
dimension of the space.



<h2>Aspect ratios of replaced elements</h2>

<p>For the purposes of the width and height calculations below, CSS
distinguishes four kinds of <em title="replaced element"
class=index>replaced elements</em>:

<dl>
<dt>Type 1: replaced elements with both <em class=index>intrinsic
width</em> and <em class=index>intrinsic height.</em> <dd>These are
replaced elements that are meant to be displayed with a certain fixed
factor (the <em>intrinsic ratio</em>) between their width and height
and also have a default size. Different formats may have different
ways of specifying the size, e.g., a width and a ratio, or a raster
and a resolution in dots per inch. Raster images fall in this
category.

<dt>Type 2: replaced elements with only an <em>intrinsic ratio</em>
<dd>These are replaced elements that are meant to be displayed with a
certain fixed factor between their width and height, but without a
default size. <span class=index>SVG</span> images often fall in the
this category.

<dt>Type 3: replaced elements with a <dfn>complex aspect ratio</dfn>
<dd>These are replaced elements that do not have a <em>fixed</em>
ratio between their width and height, but that do have a functional
relation between them in the sense that for every width there is a
unique height. HTML documents are examples of this: the width can be
chosen freely, but at every width there is a definite intrinsic
height.

<dt>Type 4: replaced elements without an intrinsic ratio <dd>These are
replaced elements that have no relation between their width and
height. Certain <span class=index>SVG</span> images are examples of
this.
</dl>

<p>For <span class=index>raster images</span> without reliable
resolution information, a size of 1 px unit per image source pixel
must be assumed. These images thus are of type 1.

<div class=example>
<p>E.g., in the section on <a href="#inline-replaced">inline replaced
elements,</a> if the replaced element is an HTML document and the
height is specified as ''auto'', e.g.:
<pre>
... &lt;object data="example.html"
      style="width: 30em; height: auto">&lt;/object>...
</pre>
<p>then the used height will be 150px, which is unlikely to be the
real height of the example.html document. But if the height is
specified as ''complex'', e.g.:
<pre>
... &lt;object data="example.html"
      style="width: 30em; height: complex">&lt;/object>...
</pre>
<p>then the height will be the height the example.html document
normally has when displayed on its own with the given width. This
enables almost seamless integration of external text in a document,
without a scrollbar or similar. (The external text is still displayed
with its own style sheet.)
</div>

<div class=example>
<p>An (external) mathematical formula in MathML is an example of
replaced content with an intrinsic width and height. Assume the file m.mml
contains a formula, then the HTML fragment

<pre>
... derive &lt;img src="m.mml"
alt="that the sum of p(i) for i greater than 0 equals N">
for the case...
</pre>

<p>renders the formula at its intrinsic size.
</div>

<p class=issue>The mathematical formula would however benefit from a
way to negotiate available space against intrinsic size, or even
negotiate available space against the number of boxes, so that the
formula could be broken in two or more boxes and occupy space on two
or more lines (similar to how lines of text are broken or words are
hyphenated). But an easier solution might be to extend HTML with
native support for math and CSS with math boxes, so that replaced
elements remain single boxes.



<h2>Basic flow layout</h2>

<p>As described in the introduction, elements give rise to boxes and
those boxes are laid out on a <em>canvas.</em> Different kinds of
boxes are laid out differently. This section describes the layout of
one <em>flow</em> of boxes.

<p>The approximate model for the layout of a flow of boxes is that
sibling boxes are laid out one after the other in one long series with
margins between them and parent boxes tightly wrap the series of child
boxes. The 'block-flow' property of the parent determines if that series
grows down (''tb''), to the left (''rl''), to the right (''lr'') or up
(''bt''). Although the rules below depend on terms that are only
defined further down, the rules are given at the outset, to provide at
least an approximate model of how boxes are positioned relative to one
another.

<p>The following rules define the position of <em>block-level</em>
boxes relative to the box that is their <em>flow root.</em> Other
sections and other modules describe how other boxes are laid out. 
E.g., floating boxes are described further down in this module and
absolutely positioned boxes are described in the Absolute Positioning
module [[CSS3POS]].

<p>Before applying these rules, the width, height and margins of each
box must be computed as described in the sections <a
href="#Calculating">“Calculating widths, heights and margins”</a>
and <a href="#Collapsing">“Collapsing margins.”</a>

<ul>
  <li>
    <p>Consider the first box (in document order) of a set of sibling
    boxes that all belong to the same flow. There are four cases:
    <ol>
      <li>
        <p>If none of its margins <span>collapse</span> with its
        parent's <span>head</span> margin and the box is
        not <span>collapsed through,</span> then the box is placed
        such that the box's <span>headside</span> <span>margin
        edge</span> touches the
        parent's <span>head</span> <span>content edge</span>,
        the <span>startside</span> <span>margin edge</span> touches
        the parent's <span>start</span> <span>content edge</span> and
        the <span>endside</span> <span>margin edge</span> touches the
        parent's <span>end</span> <span>content edge.</span>

        <p class=issue>[Add illustration.]

      <li>
        <p>If none of its margins <span>collapse</span> with its
        parent's <span>head</span> margin but the box
        is <span>collapsed through,</span> then its <span>content
        edge</span> (which is also its <span>border edge</span>
        and <span>padding edge</span>) is defined as what it would
        have been if the box had a non-zero <span>tailside</span>
        border. (I.e., recompute the margins given that border and
        then apply the previous rule.)

        <p class=note>Note that the box is effectively invisible, but
        the edges have to be defined to position any descendants, such
        as floating or absolutely positioned children.

      <li>
        <p>If exactly one of its margins collapses with its
        parent's <span>head</span> margin, then the box is placed such
        that the box's <span>headside</span> <span>border edge</span>
        touches the parent's <span>head</span> <span>content
        edge,</span> the <span>startside</span> <span>margin
        edge</span> touches the
        parent's <span>start</span> <span>content edge</span> and
        the <span>endside</span> <span>margin edge</span> touches the
        parent's <span>end</span> <span>content edge.</span>

        <p class=issue>[Add illustration.]

      <li>
        <p>If two of its margins collapse with its
        parent's <span>head</span> margin, then its position is such
        that its <span>content edge</span> (which is also
        its <span>border edge</span>) touches its
        parent's <span>head</span> <span>border edge</span> and that
        its <span>startside</span> <span>margin edge</span> touches
        its parent's <span>start</span> <span>content edge</span> and
        its <span>endside</span> <span>margin edge</span> touches the
        parent's <span>end</span> <span>content edge.</span>

        <p class=note>Note that the box is effectively invisible, but
        the edges have to be defined to position any descendants.
    </ol>

  <li>
    <p>For a box that has a preceding sibling in the same flow there
    are two cases:
    <ol>
      <li>
        <p>If the box is not <span>collapsed through,</span> it is
        positioned such that its <span>margin edge</span> touches the
        parent's <span>start</span> <span>content edge</span>
        and <span>end</span> <span>content edge</span> and such that
        its content edge on the touches
        the <span class=issue>[...]</span>

    <li>
      <p>A box that has a preceding sibling in the same flow and that
      is <span>collapsed
      through,</span> <span class=issue>[...]</span>
  </ol>
</ul>



<h2>Types of boxes</h2>

<p>The layout of boxes in the flow is in large part determined by the
interplay of the 'display' properties of an element and its parent,
and then fine-tuned with margins and padding.

<h3 id=display>The display property</h3>

<table class="propdef">
  <tr><td>Name: <td><dfn>display</dfn>
  <tr><td>Value: <td>inline | block | inline-block | list-item |
    run-in | compact | table | inline-table | table-row-group |
    table-header-group | table-footer-group | table-row |
    table-column-group | table-column | table-cell | table-caption |
    ruby | ruby-base | ruby-text | ruby-base-group | ruby-text-group |
    <var>&lt;template&gt;</var> | align-box | none
  <tr><td>Initial: <td>inline
  <tr><td>Applies to:<td>all elements
  <tr><td>Inherited: <td>no
  <tr><td>Percentages: <td>N/A
  <tr><td>Media: <td>visual (''none'' applies to all media)
  <tr><td>Computed value: <td>specified value, except for floats, root
    elements and positioned elements; see text
</table>

<p class=issue>There is an old proposal to split 'display' into
display-role (the function of the element in its parent) and
display-model (how the element lays out it children). That allows some
combinations that have no keyword, such as a table cell
('display-role: table-cell') that is itself a table ('display-model:
table'), without the need for an extra wrapper element. It allows
certain things (for math layout, e.g.), but is not easy to use. An
alternative proposal is an '::outside' pseudo-element to create an
extra box on which to set a different 'display' value. That is not
easy either, and doesn't cascade well. And a third proposal is to
allow two values on 'display': if there are two (in any order), one is
the role and the other the model, unless the pair makes no sense. That
doesn't make the concept any easier, but it hides the complexity
better.

<p>This property, in combination with 'float' and 'position',
determines the type of box or boxes that are generated for an element.
The values are as follows:

<dl>
  <dt>inline <dd>Inline boxes.

  <dt>block <dd>Block boxes.

  <dt>inline-block <dd>A block box, which itself is flowed as a single
  inline box, similar to a replaced element. The inside of an
  inline-block is formatted as a block box, and the box itself is
  formatted as an inline box.

  <dt>list-item <dd>One or more block boxes and one marker box. Marker
  boxes are defined in the Lists module [[CSS3LIST]]. <span
  class=issue>If the Lists module is not ready, define the position of
  the marker and the list-style property here? Or refer to CSS 2.1
  instead?</span>

  <dt>run-in <dd>Either block or inline boxes, depending on context
  (see <a href="#run-in-boxes">Run-in boxes</a>). Properties apply to
  run-in boxes based on their final status (<span>inline-level</span>
  or <span>block-level</span>).

  <dt>compact <dd>Either block boxes or a marker box, depending on
  context (see <a href="#compact-boxes">Compact boxes</a>). Properties
  apply to compact boxes based on their final status.

  <dt>table, inline-table, table-row-group, table-header-group,
  table-footer-group, table-row, table-column-group, table-column,
  table-cell, table-caption <dd>See the Tables module [[CSS3TBL]].

  <dt>ruby, ruby-base, ruby-text, ruby-base-group, ruby-text-group
  <dd>See the Ruby module [[CSS3RUBY]].

  <dt><var>&lt;template&gt;</var> <dd>See the <cite>Template Layout
  module</cite> [[CSS3LAYOUT]].

  <dt>align-box <span class=issue>or container?</span> <dd>Like
  ''block'', but forces the element to be a <em>flow root,</em>,
  which, e.g., stops its margins from collapsing with margins of child
  elements and includes floating children in its
  height. <span class=issue>[C.f.
  the <a href="#contain-floats">discussion of how to force an element
  to contain floats.</a>]</span>

  <dt>none <dd>This value causes an element to not appear in the
  formatting structure (i.e., in visual media, the element generates
  no boxes and has no effect on layout). Descendant elements do not
  generate any boxes either; the element and its content are removed
  from the formatting structure entirely. This behavior
  <strong>cannot</strong> be overridden by setting the 'display'
  property on the descendants.
</dl>

<p class=note>Note that ''none'' does not create an invisible box; it
creates no box at all. See 'visibility' for a mechanisms that enables
an element to generate boxes that affect formatting but are not
visible themselves.

<p class=note>Note that both 'clear-after' and ''align-box'' can be
used to force the next element after this one to start after any
floats inside this element, but the effect is not exactly the same.
E.g., 'display: box' also affects certain forms of margin
collapsing.

<p class=note>Note that 'vertical-align' applies to ''align-box''
elements, hence the name. The 'vertical-align' property doesn't apply
to other block-level elements, except ''table-cell'' elements.

<p class=issue>Any sense in vertically spreading out the contents,
something like 'vertical-align: justify'?

<p class=issue>Simpler to not use 'vertical-align', but creating
''top-box'', ''middle-box'' and ''bottom-box''?

<div class=example>
<p>The 'vertical-align' property applies to ''align-box''
elements <span class=issue>[check in [[!CSS3TEXT]]!]</span>, and can
thus be used to create vertically centered content, without wrapping
the content in a table (which may not be always possible, and also
causes the 'width' property to behave differently).

<pre>
div.slide {
  display: align-box;
  height: 15em;
  vertical-align: middle;
  border: thin solid }
</pre>

<p>with a document fragment like this:

<pre>
&lt;div class=slide>
  &lt;ul>
    &lt;li>Bullet lists are boring
    &lt;li>They distract from the speaker
    &lt;li>Don't use them!
  &lt;/ul>
&lt;/div>
</pre>

<p>might look like this figure:

<div class=figure>
  <p><img src="align-box.png" alt="A 15 em high box with three bullet
  items in the center">

  <p class=caption>The 'vertical-align: middle' causes the content of
  the ''align-box'' to be vertically centered.
</div>
</div>

<p>The computed value of 'display' depends on 'position' [[CSS3POS]],
'float' and 'overflow':

<ol>
  <li>If the specified value of 'display' is ''none'', then the
  computed value is ''none'' (and 'overflow', 'float' and 'position'
  do not apply).

  <li>Otherwise, if 'position' is ''absolute'' or ''fixed'', or if
  'float' is not ''none'', or if 'overflow' is not ''visible'', or if
  the element is the root element, then the computed value of
  'display' is set according to the following table:

  <table class=equiv-table>
  <thead>
  <tr><th>Specified value                      <th>Computed value
  <tbody>
  <tr><td>inline-table                         <td>table
  <tr><td>inline, run-in, table-row-group,
    table-column, table-column-group,
    table-header-group, table-footer-group,
    table-row, table-cell, table-caption,
    inline-block                               <td>block
  <tr><td>others                               <td>same as specified
  </table>

  <li>Otherwise, the computed value of 'display' is the same as the
  specified value.
</ol>



<h3>Mixing the box model with other formatting models</h3>

<p>There may be documents that combine different layout models, such
as documents that combine HTML (typically rendered with the CSS box
model) and <span class=index>SVG</span> (rendered with its own
graphics model). If an element that is rendered according to the CSS
box model has a child that is to be rendered with a different model,
that child needs to have a 'display' property with a value that
indicates that the child is not in the box model.

<p>Such a child is treated as a <em>replaced element</em> for the
purposes of determining its size, position, margins, padding and
border.

<p class=issue>Should we allow a more complex model, where such a
child may negotiate with the CSS environment to have several boxes and
several baselines, so that it can take part in line breaking and page
breaking?

<p>This specification defines no value(s) for the 'display' property
that indicate that an element is formatted according to a different
model than the box model, but separate specifications may do so.



<h3>Block-level boxes, containing blocks, flows and anonymous
boxes</h3>

<p>A <dfn>block-level</dfn> box is a box that has a <span>computed
value</span> for 'display' of ''block'', ''align-box'', ''list-item'',
''table'', ''table-*'' (i.e., all table boxes, see [[CSS3TBL]]),
<var>&lt;template&gt;</var> (see [[CSS3LAYOUT]]), ''run-in'' (under
certain circumstances, see <a href="#run-in-boxes">“Run-in boxes”
</a>), or ''compact'' (under certain circumstances, see <a
href="#compact-boxes">“Compact boxes”</a>).

<p>An <dfn>inline-level</dfn> box is a box that has a <span>computed
value</span> for 'display' of ''inline'', ''inline-block'',
''inline-table'', ''ruby'', ''run-in'' (under certain circumstances),
or ''compact'' (under certain circumstances).

<p class=issue>[What about the other ruby values?]

<p>An <dfn>anonymous box,</dfn> informally, is a box that cannot be addressed
with CSS selectors. All its properties, except for 'display', have their
default values (either the initial value or inherited). Anonymous boxes are
created when the CSS box model requires a child box with a certain value for
'display', but the child actually has a different value. In that case an
anonymous box of the right kind is created and wraps the child (or children).
Other modules (e.g., [[CSS3TBL]], [[!CSS3TEXT]]) may also define anonymous
boxes. The anonymous boxes defined by this module are the following:
<ul>
  <!--
  <li>An ''inline-table'' element creates one box with ''inline-table'' as
    the value for 'display', which contains one anonymous box with ''table''
    as the value.
  <li>An ''inline-block'' element creates one box with ''inline-block'' as
    the value for 'display', containing one anonymous box with ''block'' as
    the value.
  <li>A <span>block-level</span> element that has a
    'block-flow' of ''lr'' or
    ''rl'' and a parent with a 'block-flow' of ''tb'' (or vice-versa)
    generates one or more block-level boxes with the same 'block-flow'
    as the parent, each of which has one anonymous child box with a 'display'
    of ''block'' and the 'block-flow' of the element itself. <span
    class=issue>[Coordinate this with CSS3-WRITING-MODES]</span>
  -->
  <li>A <span>block-level box</span> may contain either <span
    title="line box">line boxes</span> or <span>block-level</span>
    boxes, but not both. If
    necessary, any line boxes that belong to this box's element are wrapped
    in one or more (as few as possible) anonymous boxes with a 'display' of
    ''block''.
</ul>

<div class=example>
<p>An example of the last point above is this document fragment:

<pre>&lt;p&gt;Somebody whose name I have
forgotten, said, long ago: &lt;q&gt;a box is
a box,&lt;/q&gt; and he probably meant it.&lt;/p&gt;</pre>

<p>with these style rules:
<pre>p { display: block }
q { display: block; margin: 1em }</pre>

<p>The <code>p</code> element has both line boxes and a child box for the
<code>q</code> element, which is a block-level element. The line boxes before
the <code>q</code> are wrapped in an anonymous block-level box and so are the
line boxes after the <code>q</code>. The resulting tree of boxes might be as
follows (refer to the <a href="#When">figure</a>):
<ul>
  <li>block-level box [p]
    <ul>
      <li>block-level box [anonymous]
        <ul>
          <li>line box: &ldquo;Somebody&hellip;&rdquo;
          <li>line box: &ldquo;forgotten&hellip;&rdquo;
        </ul>
      
      <li>block-level box [q]
        <ul>
          <li>line box: &ldquo;a box&hellip;&rdquo;
        </ul>
      
      <li>block-level box [anonymous]
        <ul>
          <li>line box: &ldquo;and he&hellip;&rdquo;
        </ul>
      
    </ul>
</ul>

<div class=figure id=When>
  <p><img alt="The P element has two line boxes before the q and one
  after. The first two are wrapped in an anonymous box, the last one
  is wrapped in another anonymous box." src="anonymous.png">

  <p class="caption">When the fragment is rendered, the text before
  the q is wrapped in an anonymous block and the text after the q in
  another.
</div>
</div><!--example-->

<p class=note>Note that the anonymous boxes defined in this module are
all <span>block-level,</span> but anonymous boxes defined in other
modules may be different.

<p class=mtb>The <dfn>containing block</dfn> of a box is a rectangle that
is associated with the box and that is used in various definitions in this
specification. Apart from a size and a position, the rectangle also has
'direction' and 'block-flow' properties. The containing block of a box
is defined as follows:
<ul>
  <li>The containing block of the <span title="root element">root
    element's</span> top-level boxes is a rectangle with the dimensions of
    the <em>viewport,</em> anchored at the <em title="canvas">canvas's</em>
    origin for continuous media and the page area for paged media. (See
    [[MEDIAQ]] and [[CSS3PAGE]] for definitions of continuous and paged
    media.) This containing block is called the <dfn>initial containing
    block.</dfn> The 'direction' and 'block-flow' of the initial
    containing block are the same as those of the root element.

  <li>For other elements, the containing block is one of the
    following:
	    <ol>
	      <li>If the element is a ''run-in'' that is rendered
	      inline in a sibling element, then its containing block
	      is the <span>content edge</span> of the <span>principal
	      box</span> of that sibling.

	      <li>Otherwise, if the parent has a <span>principal
	      box</span> that is a <span>block container box</span>
	      (e.g., if the parent is a 'table-cell' or a 'block'),
	      then the containing block is the content edge of the
	      parent's <span>principal box.</span>

	      <li>Otherwise the containing block is the same as that
	      of the parent.
	    </ol>
</ul>

<p>In the above, a <dfn>block container box</dfn> is, informally, a
box that can contain block boxes. More precisely: any box generated by
a (pseudo-)element with a computed value for 'display' of ''block'',
''inline-block'', ''table-caption'', ''table-cell'', ''list-item'' or
template. <span class=note>Note that most floating and absolutely
positioned elements have a computed 'display' of ''block''. Also, a
<em>flow root</em> has a computed 'display' of ''block''.</span>
<span class=issue>Or insert the definition of block container box from
CSS 2.1 here?</span>

<p class=issue>Also define <dfn>principal box</dfn> somewhere.

<p class=issue><a
href="http://wiki.csswg.org/spec/css2.1#issue-142">Issue 142 of
CSS 2.1</a> suggests that an anonymous cell box, unlike anonymous
block boxes, <em>can</em> establish the containing block for its
children. If that is accepted, make sure the table module modifies the
above definition.

<p class=note>Note that the above is modified by the Absolute Positioning
module [[CSS3POS]]: in particular, if a box's 'position' property is neither
''static'' nor ''relative'', its containing block is established
differently.

<p>If an element <span class=issue>[or a viewport?]</span> has
scrollbars (see 'overflow'), then any space taken up by the scrollbars
should be excluded from (subtracted from the dimensions of) any
containing block formed by that element.

<p class=mtb>A <dfn>flow root</dfn> is a box that satisfies at least one of
the following:
<ul>
  <li>The value of 'float' is not ''none''.
  <li>The <em>used value</em> of 'overflow' is not ''visible''.
  <li>The value of 'display' is ''table-cell'', ''table-caption'' (see
    [[CSS3TBL]]), ''inline-block'', ''inline-table'' or ''align-box''.
  <li>The value of 'position' is ''absolute'' or ''fixed'' (see
    [[CSS3POS]]).
  <li>The box is <em>vertical</em> and its parent is
    <em>horizontal.</em>
  <li>The box is <em>horizontal</em> and its parent is
    <em>vertical.</em>
  <li>The value of 'transform' is not ''none''.
  <li class=issue>The value of 'child-align' is not ''auto''. [If
    'child-align' is adopted, rather than, say, 'margin: fill']
</ul>

  <p class=note>Note that an element with 'display: inline' therefore
  cannot be a flow root: it doesn't float (otherwise its 'display'
  would be ''block''), and neither 'overflow' nor 'block-flow'
  apply to inlines.

  <p class=note>Note: The terminology in the CSS level 2 specification is
  different. A flow root is called “an element that establishes a
  <span class=index title="formatting context|new formatting
  context">new formatting context.</span>”

<p>Other modules may define additional flow roots. <span
class=issue>[Can we thus remove ''table-caption'', ''table-cell'', and
'position' from the list above?]</span>

<p>The <dfn>flow</dfn> (a.k.a. <dfn>normal flow</dfn>) of a given
<em>flow root</em> is a set of boxes. A box belongs to the flow if all
of the following are true:
<ol>
  <li>The used value of its 'display' is ''block'', ''list-item'',
  ''table'' or <var>&lt;template&gt;</var>.

  <li>The used value of its 'float' is ''none''.

  <li>The used value of its 'position' is ''static'' or ''relative''.

  <li>It is either a child of the flow root or a child of a box that
  belong to the flow.
</ol>



<div class=example>
<p>For example, the fragment
<pre>&lt;div class=sidebar&gt;
 &lt;p&gt;Text in a sidebar.
 &lt;p&gt;Here is quote:
 &lt;blockquote lang=ja&gt;
  &lt;p&gt;...
 &lt;/blockquote&gt;
 &lt;p&gt;Etc. etc.
&lt;/div&gt; </pre>

<p>with the style
<pre>div.sidebar { block-flow: tb; float: left }
blockquote[lang|=ja] { block-flow: rl; height: 10em }</pre>

<p>defines two flows:
<ol>
  <li>The <code>div</code> is a flow root, because it floats. Its flow
  consist of the 1st, 2nd and 4th <code>p</code> and the
  <code>blockquote</code>.

  <li>The <code>blockquote</code> is a <em>vertical</em> box inside a
  <em>horizontal</em> parent and it is thus a flow root. Its flow is
  formed by the 3rd <code>p</code>.
</ol>
<p>(The <code>div</code> itself belongs to a third flow, but its flow
root is not shown in the fragment.)
</div>

<p class=note>Note that a flow root is not necessarily block-level, it may
be an ''inline-block'', e.g.

<p>The boxes of a flow are laid out inside their flow root one after
the other in the direction of the 'block-flow' property of the
flow root and in the same order as in the source document. Their
position is given by how much their margins overlap (see <a
href="#collapsing-margins">“Collapsing margins”</a>) and by the fact
that their side margin edges coincide with content edges of their
containing blocks. More precisely: Each box's left and right margin
edges coincide with the left and right edges of its containing block
(if the flow root is ''tb''), or its top and bottom margin edges
coincide with the top and bottom edges of its containing block (if the
flow root is ''rl'' or ''lr'').

<h3 id=run-in-boxes>Run-in boxes</h3>

<p>A ''run-in'' element (or pseudo-element) <var>A</var> behaves as
follows:

<ol>
  <li>If <var>A</var> has any children that <span>inhibit run-in
    behavior</span> (see below), then <var>A</var> is rendered as if
    it had 'display: block'.

  <li>Let <var>B</var> be the first of <var>A's</var> following
    siblings that is neither floating nor absolutely positioned nor
    has 'display: none'. If <var>B</var> exists and has a specified
    value for 'display' of ''block'' or ''list-item'' and is not
    replaced,
    then <var>A</var> is rendered as an ''inline'' element at the
    start of <var>B's</var> principal
    box. <span class=note>Note: <var>A</var> is rendered
    before <var>B's</var> ':before' pseudo-element, if any. See
    [[CSS3GENCON]].</span>

  <li>Otherwise, <var>A</var> is rendered as if it had 'display:
    block'.
</ol>

<p>In the above, “siblings” and “children” include both normal
elements and :before/:after pseudo-elements.

<p>An element or pseudo-element <var>C</var> <dfn>inhibits
run-in behavior</dfn> if one or more of the following are true. <span
class=note>(Note that the definition is recursive.)</span>

<ul>
  <li><var>C</var> is not floating and not absolutely positioned and
    the computed value of its 'display' is one of ''block'',
    ''list-item'', ''table'' or ''run-in''.

  <li><var>C</var> has a computed value for 'display' of 'inline' and
    it has one or more children that inhibit run-in behavior. (Where
    “children” includes both normal elements and :before/:after
    pseudo-elements.)
</ul>

<div class=example>
<p>A ''run-in'' box is useful for run-in headers, as in this example:

<pre>
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
&lt;HTML>
  &lt;HEAD>
    &lt;TITLE>A run-in box example&lt;/TITLE>
    &lt;STYLE type="text/css">
      H3 { display: run-in }
    &lt;/STYLE>
  &lt;/HEAD>
  &lt;BODY>
    &lt;H3>A run-in heading.&lt;/H3>
    &lt;P>And a paragraph of text that
       follows it.
  &lt;/BODY>
&lt;/HTML>
</pre>

<p>This example might be formatted as:
<pre>
<b>A run-in heading.</b> And a
paragraph of text that 
follows it.
</pre>
</div>

<p>Despite appearing visually as part of the following block box, a
run-in element still inherits properties from its parent in the source
tree.
<span class=issue>It is undefined in level&nbsp;2 if a run-in inherits
from a ':first-line' pseudo-element. How about in level&nbsp;3?</span>


<h3 id=compact-boxes>Compact boxes</h3>

<p class=issue>Define here or in extended box module?

<p>A compact box is a box that is either put in the margin of the next
box or becomes a block of its own, depending on whether it is small
enough to fit in the margin or not. The typical use case is for lists
where most labels are small enough to fit in the margin, except for a
few.

<div class=example>
<p>An example is the DL list in HTML. Its COMPACT attribute indicates
to the formatter that the labels of the list are good candidates for
display as compact boxes:

<pre>
&lt;h3>Farm animals&lt;/h3>
&lt;dl compact>
 &lt;dt>cat
 &lt;dd>Lorem ipsum dolor sit amet, consectetaur adipisicing elit&hellip;
 &lt;dt>dog
 &lt;dd>Ut enim ad minim veniam, quis nostrud exercitation&hellip;
 &lt;dt>hippopotamus
 &lt;dd>Duis aute irure dolor in reprehenderit in voluptate velit&hellip;
 &lt;dt>fly
 &lt;dd>Excepteur sint occaecat cupidatat non proident, sunt in&hellip;
&lt;/dl>
</pre>

<p>With a style rule like

<pre>dl[compact] dt {display: compact}</pre>

<p>this might be rendered as in the figure below.

<div class=figure>
  <p><img src="compact" alt="[sample rendering]" style="max-width: 24em">
  <p class=caption>Three of the four labels are narrow enough to fit
  in the left margin. The one that is too wide is converted into a
  block.
</div>
</div>

<p>Whether a compact box <var>C</var> is displayed as a block or in
the margin is determined as follows. Let <var>N</var> be the next
sibling element in document order in the same flow as <var>C</var>, if
any. Let <var>W</var> be the hypothetical distance between the
<em>startside</em> margin edge and <em>endside</em> margin edge of
<var>C</var> if the 'display' property of <var>C</var> were set to
''block'' and any ''auto'' on its <em>inline dimension</em> were
replaced by ''fit-content''.

<ul>
<li>If there is no such <var>N</var>, then <var>C</var> is displayed
as a block.

<li>If <var>N</var> has a 'display' of ''list-item'', then
<var>C</var> is displayed as a block.

<li>If <var>N</var> is not <em>block-level</em>, then <var>C</var> is
displayed as a block.

<li>If the <em>startside</em> margin of <var>N</var> is less than
<var>W</var>, then <var>C</var> is displayed as a block.

<li>Otherwise, <var>C</var> is displayed in the margin.
</ul>

<p>If <var>C</var> is displayed as a block, it is a
<em>block-level</em> element and it is sized and positioned exactly as
if its 'display' had been ''block''.

<p>Otherwise, <var>C</var> is placed such that its <em>startside</em>
margin edge aligns with the <em>start</em> margin edge of its
<em>containing block</em> and its <em>headside</em> border edge aligns
with the <em>headside</em> border edge of <var>N</var>. It is in this
case an <em>inline-level</em> element.

<p class=issue>Do we do anything to avoid that floats overlap with
<var>C</var>? Do we do anything if <var>C</var> is taller than
<var>N</var>? E.g., adjust the 'min-height' of <var>N</var>?

<div class=example>
<p>Simple example...
</div>

<div class=example>
<p>This example shows a compact box that has a different <em>writing
mode</em> than its containing block:

<pre>
dl {block-flow: tb; direction: ltr}
dd {margin-left: 3em}
dt {display: compact; block-flow: rl}
...
&lt;dl>
 &lt;dt>cat
 &lt;dd>Lorem ipsum dolor sit amet, consectetaur adipisicing elit&hellip;
&lt;/dl>
</pre>

<p>The margin that is considered is the left margin of the DD, because
the containing block (established by the DL) is
top-to-bottom/left-to-right. That margin is thus compared to the width
of the DT and it is large enough, which leads to a rendering similar
to the figure below.

<div class=figure>
  <p><img src="compact-vert" alt="[Sample rendering]" style="max-width: 24em">

  <p class=caption>The word &ldquo;cat&rdquo; written sideways fits to
  the left of the definition.
</div>
</div>



<h2>The padding properties</h2>

<table class="propdef">
  <tr><td>Name: <td><dfn>padding</dfn>
  <tr><td>Value: <td>[ <var>&lt;length&gt;</var> |
    <var>&lt;percentage&gt;</var> | auto ]{1,4}
  <tr><td>Initial: <td>(see individual properties)
  <tr><td>Applies to: <td>all elements
  <tr><td>Inherited: <td>no
  <tr><td>Percentages: <td>width* of containing block
  <tr><td>Media: <td>visual
  <tr><td>Computed value: <td>see individual properties
  <tr><td colspan="2" class="footnote">*) if the <em>containing
    block</em> is <em>horizontal,</em> otherwise the height
</table>

<table class="propdef">
  <tr><td>Name: <td><dfn>padding-top</dfn> , <dfn>padding-right</dfn>,
    <dfn>padding-bottom</dfn>, <dfn>padding-left</dfn>
  <tr><td>Value: <td>[ <var>&lt;length&gt;</var> |
    <var>&lt;percentage&gt;</var> | auto ]
  <tr><td>Initial: <td>0
  <tr><td>Applies to: <td>all elements
  <tr><td>Inherited: <td>no
  <tr><td>Percentages: <td>width* of containing block
  <tr><td>Media: <td>visual
  <tr><td>Computed value: <td>&lt;length&gt;
  <tr><td colspan="2" class="footnote">*) if the <em>containing
    block</em> is <span><em>horizontal,</em></span> otherwise the height
</table>

<p>Sets the thickness of the <em>padding area.</em> The value may not be
negative.

<p>'Padding' is a shorthand for the other four properties. If 'padding' has
four values, they are for top, right, bottom and left in that order. If left
is omitted, it is the same as right. If bottom is omitted it is the same as
top, if right is omitted it is the same as top.

<p class=note>Note that percentages on 'padding-top' and 'padding-bottom'
are relative to the <em>width</em> of the containing block, not the height
(at least in a horizontal flow; in a vertical flow they are relative to the
height).

<p class=note>Note that percentages are not required for CSS level 2.

<div class=example>
<p>For example, the following two ways to set the padding of <code>h1</code>
are equivalent:
<pre>h1 { padding: 0.5em }
h1 { padding-top: 0.5em;
     padding-right: 0.5em;
     padding-bottom: 0.5em;
     padding-left: 0.5em }</pre>
</div>

<div class=issue>
<p>Values may not be negative, thus the third line is ignored, but
what about the fourth?

<pre>
p { font-size: 10pt;
    padding-left: 2em;
    padding: -11pt;
    padding-left: calc(1em - 11pt)
}
</pre>
</div>



<h2>Margins</h2>

<p>Margins in CSS serve to add both horizontal and vertical space
between boxes.

<h3>The margin properties</h3>

<table class="propdef">
  <tr><td>Name: <td><dfn>margin-top</dfn> , <dfn>margin-right</dfn>,
    <dfn>margin-bottom</dfn>, <dfn>margin-left</dfn>
  <tr><td>Value: <td><var>&lt;length&gt;</var> |
    <var>&lt;percentage&gt;</var> | auto
  <tr><td>Initial: <td>0
  <tr><td>Applies to: <td>see text
  <tr><td>Inherited: <td>no
  <tr><td>Percentages: <td>width* of containing block
  <tr><td>Media: <td>visual
  <tr><td>Computed value: <td>the percentage as specified or the
    absolute length or ''auto''
  <tr><td colspan="2" class="footnote">*) if the <em>containing
    block</em> is <em>horizontal,</em> otherwise the height
</table>

<table class=propdef>
  <tr><td>Name: <td><dfn>margin</dfn>
  <tr><td>Value: <td>[ <var>&lt;length&gt;</var> |
    <var>&lt;percentage&gt;</var> | auto]{1,4}
  <tr><td>Initial: <td>(see individual properties)
  <tr><td>Applies to: <td>see text
  <tr><td>Inherited: <td>no
  <tr><td>Percentages: <td>width* of containing block
  <tr><td>Media: <td>visual
  <tr><td>Computed value: <td>see individual properties
  <tr><td colspan="2" class="footnote">*) if the <em>containing
    block</em> is <em>horizontal,</em> otherwise the height
</table>

<p>These properties set the thickness of the <em>margin area</em>. The value
may be negative.

<p>'Margin' is a shorthand for the other four. If 'margin' has four values,
they set top, right, bottom and left in that order. If left is omitted, it is
the same as right. If bottom is omitted, it is the same as top. If right is
omitted it is the same as top.

<p>The properties apply to all boxes except certain table-* boxes (see
[[CSS3TBL]]) and certain inline-level boxes (see [[!CSS3TEXT]]).

<p>Margins must satisfy certain constraints, which means that the used value
may be different from the computed value. See <a
href="#Calculating">&ldquo;Calculating widths, heights and
margins.&rdquo;</a> The meaning of ''auto'' is also
explained there.

<p class=note>Note that in a <span>horizontal flow,</span> percentages on
'margin-top' and 'margin-bottom' are relative to the <em>width</em> of the
containing block, not the height (and in vertical flow, 'margin-left' and
'margin-right' are relative to the height, not the width).

<div class=example>
<p>For example, the following two ways of setting the margins of
<code>p</code> are equivalent:
<pre>p { margin: 1em 2em }
p { margin-top: 1em;
    margin-right: 2em;
    margin-bottom: 1em;
    margin-left: 2em }</pre>
</div>



<h3 id=collapsing-margins>Collapsing margins</h3>

<p>Certain adjoining margins, as defined in this section, combine to
form a single margin. Those margins are said to <dfn>collapse.</dfn>
Margins are <dfn>adjoining</dfn> if there are no nonempty content,
<span title="padding area">padding</span> or <span title="border
area">border areas</span> or <em>clearance</em> to separate them.

<div class=example>
<p>For example, in the following fragment with the given style rules:
<pre>p { display: block; margin-bottom: 2em 0 1em 0 }
div { display: block; margin: 2.5em 0 }
...
&lt;p&gt;First paragraph&lt;/p&gt;
&lt;div&gt;
  &lt;p&gt;Second paragraph&lt;/p&gt;
&lt;/div&gt;</pre>

<p>the bottom margin of the first <code>p</code> (=1em), the top margin of
the <code>div</code> (=2.5em) and the top margin of the second <code>p</code>
(=2em) collapse. The result is a single margin of 2.5em (the maximum of the
three) between the bottom of the first <code>p</code> and the top of the
second.
</div>

<div class=figure>
  <p><img src="collapse1.png" alt="Three margins collapse: 1em + 2.5em + 2em">
  <p class=caption>Schematic representation of the previous example.
</div>

<div class=example>
<p>In the following fragment,
<pre>p { display: block; margin: 2em 0 1em 0 }
div { display: block; margin: 2.5em 0;
      border: thin solid }
...
&lt;p&gt;First paragraph&lt;/p&gt;
&lt;div&gt;
  &lt;p&gt;Second paragraph&lt;/p&gt;
&lt;/div&gt;</pre>

<p>the bottom margin of the first <code>p</code> and the top margin of
the <code>div</code> collapse, but the top margin of the second
<code>p</code> does not collapse with them, because it is not
<em>adjoining;</em> the border of the <code>div</code> separates them.
</div>

<div class=figure>
  <p><img src="collapse2.png" alt="Only two margins collapse: 1em + 2.5em">
  <p class=caption>Schematic representation of the previous example.
</div>

<p>If a set of adjoining margins collapses, then the width of the resulting
margin is <var>M</var> - <var>N</var>, where <var>M</var> is the maximum of
the adjoining margins that are positive, or zero if there are none; and
<var>N</var> is the minimum of the adjoining margins that are negative, or
zero if there are none.

<p>We call an element or box <dfn>collapsed through</dfn> if two of
its margins collapse with each other.

<div class=example>
<p>The most common use of collapsing through elements is that empty
paragraphs don't cause extra white space:

<pre>&lt;p>First paragraph
&lt;p>Second paragraph
&lt;p>
&lt;p>Last paragraph</pre>

<p>There is equal space between the first and second paragraphs as
between the second and last. 
</div>

<p>The following two sets of rules determine which margins collapse.

<ul>
  <li>Only margins of <em>block-level</em> boxes can collapse.

  <li>Margins of a floated box do not collapse with any other margins.

  <li>Margins of a <em>flow root</em> do not collapse with its
  children's margins.

  <li>Margins of an absolutely positioned box (see [[CSS3POS]]) do not
  collapse with any other margins.

  <!--
  <li>Margins of an ''inline-block'' box do not collapse (not even
  with its in-flow children). <span class=issue>Assuming the first
  rule above (“only block-level”) is correct, this rule seems
  redundant, because an inline block is not block-level.</span>
  -->

  <li>Margins of the root element's box do not collapse with any other
  margins.

  <li>If a box is <em>collapsed through</em> and it has
  <em>clearance</em> applied to one of its two collapsed margins, then
  those two margins do not collapse with certain of the parent's
  margins, as follows: If clearance is applied to, respectively, the
  top, right, bottom or left margin, then the two margins do not
  collapse with the parent's bottom, left, top or right margin,
  respectively.

  <li>If a <em>horizontal</em> element has a 'height' that is not
  ''auto'', or if setting its 'min-height' and 'max-height' to their
  initial values would change its used height, then the <em>tail</em>
  margin of the element does not collapse with any of its children's
  margins. <span class=issue>[Check with latest CSS 2.1 if min/max
  width/height still have this effect.]</span>

  <li>Similarly, if a <em>vertical</em> element has a 'width' that is
  not ''auto'', or if setting its 'min-width' and 'max-width' to their
  initial values would change the used width, then the <em>tail</em>
  margin of the element does not collapse with any of its children's
  margins. <span class=issue>[Check with latest CSS 2.1 if min/max
  width/height still have this effect.]</span>
</ul>

<p>Except when forbidden by the list above, the following margins
collapse:

<ul>
  <!-- transitive -->
  <li>
    <p>If a margin P collapses with a margin Q and margin Q with a
    margin R, then P, Q and R collapse together. (“Collapsing is
    transitive”)

  <!-- parent-child / head -->
  <li>
    <p>A margin of a box collapses with the <em>head</em> margin of
    its parent box if those two margins are <em>adjoining.</em>

  <!-- parent-child / tail -->
  <li>
    <p>A margin of a box collapses with the <em>tail</em> margin of
    its parent box if those two margins are <em>adjoining.</em>

  <!-- sibling -->
  <li>
    <p>The <em>head</em> margin of a box collapses with the
    <em>tail</em> margin of a sibling box if the two margins are
    <em>adjoining.</em>

  <!-- self top-bottom -->
  <li>
    <p>The top and bottom margins of a box A collapse with each other
    if the two margins are <em>adjoining</em> and the parent box B is
    <em>horizontal.</em> (The box is <em>“collapsed through.”</em>)

  <!-- self left-right -->
  <li>
    <p>The left and right margins of a box A collapse with each other
    if the two margins are <em>adjoining</em> and the parent box B is
    <em>vertical.</em> (The box is <em>“collapsed through.”</em>)
</ul>

<p>If a box A is <em>collapsed through</em> and it has the same mode
as its parent (i.e., both are <em>horizontal</em> or both are
<em>vertical</em>), then the position of its <em>head</em> border edge
is defined as follows.

<ul>
  <li>If the box A's margins are collapsed with its parent's
  <em>head</em> margin, the head border edge of A is defined to be the
  same as the parent's head border edge.

  <li>Otherwise, either the parent is not taking part in the margin
  collapsing, or only the parent's <em>tail</em> margin is involved. 
  The position of A's head border edge is defined to be the same as it
  would have been if A had a nonzero <em>tail</em> border.
</ul>

  <p class=note>Note that box A itself is invisible and its position
  has no effect on the positions of the other elements with whose
  margins it is being collapsed; the border edge position is only
  required for laying out descendants of A.

<div class=example>
<p>In a horizontal flow, the bottom margin of an in-flow
<span>block-level</span> element is always adjoining to the top margin
of its next in-flow block-level sibling, unless that sibling has
clearance:

<pre>
&lt;p style="margin-bottom: 2em">The bottom margin of this
box&hellip;&lt;/p>

&lt;p style="margin-top: 3em">&hellip; collapses with the top margin
of this box, to yield max(2em, 3em) = 3em margin.&lt;/p>
</pre>

<p>The top margin of an in-flow block-level element is adjoining to
its first in-flow block-level child's top margin if the element has no
top border, no top padding, and the child has no clearance:

<pre>
&lt;div style="margin-top: 2em; padding: 0; border: 0">
  &lt;p style="margin-top: 3em">
    The top margin of the DIV and the P
    collapse, to yield max(2em, 3em) = 3em margin.
  &lt;/p>
&lt;/div>
</pre>

<p>The bottom margin of an in-flow block-level element with a 'height'
of ''auto'' and 'min-height' less than the element's used height and
'max-height' greater than the element's used height is adjoining to
its last in-flow block-level child's bottom margin if the element has
no bottom padding or border:

<pre>
&lt;div style="margin-bottom: 2em; padding: 0; border: 0;
    height: auto; min-height: 0; max-height: 100em">
  &lt;p style="margin-bottom: 3em">
    The bottom margin of the DIV and the P collapse, to yield max(2em,
    3em) = 3em margin.
  &lt;/p>
&lt;/div>
</pre>

<p>An element's own margins are adjoining if the 'min-height' property is
zero, and it has neither vertical borders nor vertical padding, and it has a
'height' of either 0 or ''auto'', and it does not contain a line box, and all
of its in-flow children's margins (if any) are adjoining:

<pre>
&lt;div style="margin-top: 2em; margin-bottom: 3em">
  &lt;p style="position: absolute">
    The DIV is empty and its top and bottom margins collapse.
  &lt;/p>
&lt;/div>
</pre>

<p>When an element's own margins collapse, and that element has had
clearance applied to it, its top margin collapses with the adjoining
margins of subsequent siblings but that resulting margin does not
collapse with the bottom margin of the parent block:

<pre>
&lt;div style="margin-bottom: 2em">
  &lt;p style="float: left">
    The margins of the next two Ps collapse
  &lt;p style="clear: left; margin-top: 4em; margin-bottom: 3em">
    <!-- empty -->
  &lt;/p>
  &lt;p style="margin-top: 1em; margin-bottom: 1em">
    <!-- empty -->
  &lt;/p>
&lt;/div>
</pre>

<p>The top and bottom margins of the two empty Ps collapse all
together. But they can't collapse with the bottom of the DIV, because
one of the two empty P's has clearance.

<p class=issue>Check this. This is probably the only possible
interpretation of the rules, but it is certainly not obvious that the
clearance of one element may stop later elements from
collapsing&hellip;
</div>

<p>Collapsing is based on the used value of 'padding', 'margin', and 'border'
(i.e., after resolving any percentages). The collapsed margin is calculated
over the used value of the various margins.



<h2>The width and height properties</h2>

<table class=propdef>
  <tr><td>Name: <td><dfn>width</dfn>
  <tr><td>Value: <td>[<var>&lt;length></var> | <var>&lt;percentage></var>] &&
    [border-box | content-box]? | available | min-content |
    max-content | fit-content | auto
  <tr><td>Initial: <td>auto 
  <tr><td>Applies to: <td>all elements but non-replaced inline
    elements, table rows, and row groups
  <tr><td>Inherited: <td>no
  <tr><td>Percentages: <td>refer to width of containing block
  <tr><td>Media: <td>visual
  <tr><td>Computed value: <td>the specified keyword, the specified
    percentage (see prose under &lt;percentage>) or the absolute
    length; ''auto'' if the property does not apply
</table>

<table class=propdef>
  <tr><td>Name: <td><dfn>height</dfn>
  <tr><td>Value: <td>[<var>&lt;length></var> | <var>&lt;percentage></var>] &&
    [border-box | content-box]? | available | min-content |
    max-content | fit-content | complex | auto
  <tr><td>Initial: <td>auto 
  <tr><td>Applies to: <td>all elements but non-replaced inline
    elements, table columns, and column groups
  <tr><td>Inherited: <td>no
  <tr><td>Percentages: <td>see prose
  <tr><td>Media: <td>visual
  <tr><td>Computed value: <td>the specified keywords, the specified
    percentage (see prose under &lt;percentage>) or the absolute
    length; ''auto'' if the property does not apply
</table>

<!-- Nov 2007, ftf: add four keywords and Jason's example of image + caption -->

<p>These properties specify the width and height of the <em>content
area</em> or <em>border area</em> (depending on
'box-sizing') of certain boxes.

<p>Values have the following meanings:

<dl>
  <dt><var>&lt;length></var> <dd>Specifies the size using a length
  unit. Negative values are illegal. If the keyword ''border-box'' is
  present, the length sets the size of the border box; if
  ''content-box'' is present, it sets the size of the content box; if
  neither is present, the 'box-sizing' property determines which size
  is set.

  <dt><var>&lt;percentage></var> <dd>Specifies a percentage width or
  height. The percentage is calculated with respect to the width (in
  the case of 'width') or height (for 'height') of the generated box's
  <span>containing block.</span> Negative percentages are illegal. If
  the containing block's width, resp. height depends on this element,
  <span class=issue>then the percentage is relative to '100vw', resp. 
  '100vh'.</span> If the keyword ''border-box'' is present, the
  percentage sets the size of the border box; if ''content-box'' is
  present, it sets the size of the content box; if neither is present,
  the 'box-sizing' property determines which size is set.

  <dt>available <dd>Equal to the <em>containing block</em> width or
  height minus the current element's margin, border, and padding. 
  <span class=issue>If the required width, resp. height of the
  containing block is unknown (depends on this element), then
  ''available'' is equal to '100vw', resp. '100vh'.</span>

  <dt>max-content <dd>The <em>intrinsic preferred</em> width or
  height.

  <dt>min-content <dd>The <em>intrinsic minimum</em> width or height.

  <dt>fit-content <dd>Equal to max(''min-content'',
  min(''max-content'', ''available'')).

  <dt>auto <dd>The width or height depends on the values of other
  properties. See <a href="#Calculating">Calculating widths, heights
  and margins</a> below.

  <dt>complex <dd>(Only on 'height'.) The same as ''auto'', except
  that elements with a <em>complex aspect ratio</em> are considered to
  have an <em>intrinsic ratio.</em> More precisely: for the purposes
  of the section on <a href="#Calculating">“Calculating widths,
  heights and margins,”</a> the element is treated as if its height
  was ''auto'' and it had an <em>intrinsic ratio.</em>
</dl>

<p class=issue>Another possible value is
<var>&lt;non-negative-number&gt;</var>, which would mean
''min-content'' times that number.

<p class=note>Note that ''available'', ''max-content'',
''min-content'', ''fit-content'', ''border-box'', ''content-box'' and
''complex'' do not exist in level 2.

<p>The keyword values (in contrast to length and percentage values)
are not influenced by the 'box-sizing' property, they always set the
size of the content box, even if 'box-sizing' is ''border-box''.

<p>''Available'', ''max-content'', ''min-content'' and ''fit-content''
only have effect in the inline progression direction: when
'block-flow' is ''tb'' and these keyword are set on 'height', they act
like ''auto''; ditto when 'block-flow' is something else and the
keywords are set on 'width'.

<p class=note>Note that 'width: fit-content' is the same as 'width:
auto' for floats and tables, and 'width: available' is the same as
'width: auto' for blocks in the normal flow.

<div class=example>
<p>For example, the following rule fixes the content width of
paragraphs at 100 px:

<pre>p { width: 100px }</pre>
</div>

<div class=example>
<p>This example shows the use of the keyword values. Assume these
style rules:
<pre>
div {width: 20em}
p.available {width: available}
p.min-content {width: min-content}
p.max-content {width: max-content}
p.fit-content {width: fit-content}
p.float {float: left; width: auto}
p.auto {width: auto}
* {outline: thin solid red}
</pre>
<p>Then a document like this might be rendered as in the figure below:
<pre>
<b>&lt;div></b>
  <b>&lt;p class=available></b>available: as wide as parent.
  <b>&lt;p class=min-content></b>min-content: as narrow as possible.
  <b>&lt;p class=max-content></b>max-content: As wide as needed, even
    if that means wider than the parent.
  <b>&lt;p class=fit-content></b>fit-content: As wide as needed.
  <b>&lt;p class=fit-content></b>fit-content: As wide as needed, but
    no wider than the parent.
  <b>&lt;p class=float></b>auto: depends on flow (=float).
  <b>&lt;p class=auto></b>auto: depends on flow (=normal).
<b>&lt;/div></b>
</pre>
</div>

<div class=figure>
  <p><img src="width-keywords" alt="Image: paragraphs of different
  widths">

  <p class=caption>Rendering of the example:
  ''min-content'' and ''max-content'' depend only on the content;
  ''available'' depends only on the containing block; ''fit-content''
  depends on both; and ''auto'' acts either like ''available'' or like
  ''fit-content'', depending on the type of box.
</div>

<div class=example>
<p>This example sets the width of the border box of an element to 50%.
  It includes a fallback (48%) for UA that do not support the
  ''border-box'' keyword, such as level 2 UAs:
<pre>
div.side {
    width: 48%;
    width: 50% border-box }
</pre>
<p>It is equivalent to
<pre>
div.side {
    width: 50%;
    box-sizing: border-box }
</pre>
<p>except that the latter doesn't have a fallback for level 2 UAs
  (which don't support the 'box-sizing' property).
</div>



<h2 id=min-max>The min-width, max-width, min-height and
max-height properties</h2>

<table class=propdef>
  <tr><td>Name: <td><dfn>min-width</dfn>, <dfn>min-height</dfn>
  <tr><td>Value: <td><var>&lt;length&gt;</var>
    | <var>&lt;percentage&gt;</var> | available | min-content | max-content
    | fit-content
  <tr><td>Initial: <td>0
  <tr><td>Applies to: <td>all elements but non-replaced
    inline elements, table rows, and row groups
  <tr><td>Inherited: <td>no
  <tr><td>Percentages: <td>refer to width, resp. height of
    containing block
  <tr><td>Media: <td>visual
  <tr><td>Computed value: <td>the percentage as specified, the keyword
    as specified, or the absolute length
</table>

<table class=propdef>
  <tr><td>Name: <td><dfn>max-width</dfn>, <dfn>max-height</dfn>
  <tr><td>Value: <td><var>&lt;length&gt;</var>
    | <var>&lt;percentage&gt;</var> | available | min-content | max-content
    | fit-content | none
  <tr><td>Initial: <td>none
  <tr><td>Applies to: <td>all elements but non-replaced inline
    elements, table rows, and row groups
  <tr><td>Inherited: <td>no
  <tr><td>Percentages: <td>refer to width, resp. height of
    containing block
  <tr><td>Media: <td>visual
  <tr><td>Computed value: <td>the percentage as specified, the keyword
    as specified, the absolute length, or ''none''
</table>

<p>These properties allow authors to constrain content widths and
heights to a certain range. Values have the following meanings:</p>

<dl>
  <dt><var>&lt;length&gt;</var> <dd>Specifies a fixed minimum or
  maximum for 'width' or 'height'. Negative values are illegal.

  <dt><var>&lt;percentage&gt;</var> <dd>Specifies a minimum or maximum
  for 'width' or 'height' as a percentage of the corresponding
  dimension of the <em>containing block.</em> Negative percentages are
  illegal. If the containing block's dimension is negative, the used
  value is zero. If that containing block's dimension depends on this
  element's dimension, then the resulting layout is undefined. <span
  class=issue>Or: use the initial value?</span>

  <dt>max-content <dd>The <em>intrinsic preferred</em> width or
  height.

  <dt>min-content <dd>The <em>intrinsic minimum</em> width or height.

  <dt>available <dd>The containing block width or height minus margin,
  border, and padding.

  <dt>fit-content <dd>For 'max-width'/'max-height', same as
  ''max-content''. For 'min-width'/'min-height', same as
  ''min-content''.

  <dt>none <dd>No limit on the width or height of the box.
</dl>

<p>The keyword values (in contrast to length and percentage values)
are not influenced by the 'box-sizing' property, they always set the
size of the content box, even if 'box-sizing' is ''border-box''.

<p>''Available'', ''max-content'', ''min-content'' and ''fit-content''
only have effect in the inline progression direction: when
'block-flow' is ''tb'', keyword values on 'min-height' and
'max-height' act like '0' and ''none'', resp., and when
'block-flow' is something else, keyword values on 'min-width'
and 'max-width' act like '0' and ''none'', resp.




<h2 id=intrinsic>Definition of intrinsic sizes &ndash; high quality</h2>

<p>The size of a box often depends on the width or height of its
content. This section defines two measures of that size: the
<em>intrinsic preferred</em> width (IPREF) is, roughly, the size the
content would have if no “soft” line breaks were inserted; the <em>intrinsic
minimum</em> width (IMIN) is, roughly, the narrowest the box can get
by breaking all lines at all possible places. Or stated another way:
they are the largest width that the content can usefully fill and the
smallest width that the content can fit in without unintended
overflow.

<div class=figure>
  <p><img src="width-intrinsic" alt="">

  <p class=caption>For example, in a simple paragraph with just text
  the intrinsic preferred width is the width of the line if all words
  are laid out on one line; and the intrinsic minimum width is the
  width of the longest word.
</div>

<p>The <dfn>intrinsic minimum</dfn> width (<dfn>IMIN</dfn>) of a
<em>horizontal,</em> non-replaced element <var>E</var> is defined as
the smallest length &ge; 0 such that

<blockquote>
<p>OVERFLOW(<var>E</var>,IMIN) &le;
OVERFLOW(<var>E</var>,<var>w</var>) for all <var>w</var> &ge; 0
</blockquote>

<p>where the function OVERFLOW(<var>E</var>,<var>w</var>) is defined
as follows. Set the 'display' of <var>E</var> to ''block'', 'float' to
''none'', 'position' to ''static'', 'overflow' to ''visible'',
'min-width' to ''0'', 'max-width' to ''none'', 'height' to ''auto'',
'min-height' to ''0'', 'max-height' to ''none'' and 'width' to
<var>w</var>. Then measure the total width <var>W</var> of
<var>E</var> including all overflow, considering <var>E</var> and all
its descendants in the same flow and all floats of which <var>E</var>
is the containing block. Then

<blockquote>
<p>OVERFLOW(<var>E</var>,<var>w</var>) = <var>W</var> - <var>w</var>
</blockquote>

<p>The <dfn>intrinsic preferred</dfn> width (<dfn>IPREF</dfn>) of a
<em>horizontal,</em> non-replaced element <var>E</var> is defined as
the smallest length &ge; 0 such that

<blockquote>
<p>HEIGHT(<var>E</var>,IPREF) &le; HEIGHT(<var>E</var>,<var>w</var>)
for all <var>w</var> &ge; 0
</blockquote>

<p>and

<blockquote>
<p>HEIGHT(<var>E</var>,IPREF) &lt; HEIGHT(<var>E</var>,<var>w</var>)
or
OVERFLOW(<var>E</var>,IPREF) &le; OVERFLOW(<var>E</var>,<var>w</var>)
for all <var>w</var> &ge; 0
</blockquote>

<p>where HEIGHT(<var>E</var>,<var>w</var>) is defined as follows. Set
the 'display' of <var>E</var> to ''block'', 'float' to ''none'',
'position' to ''static'', 'overflow' to ''visible'', 'min-width' to
''0'', 'max-width' to ''none'', 'height' to ''auto'', 'min-height' to
''0'', 'max-height' to ''none'' and 'width' to <var>w</var>. Then
HEIGHT(<var>E</var>,<var>w</var>) is the height as defined below in <a
href="#root-height">“Auto heights for flow roots.”</a>

<p class=note>OVERFLOW is not necessarily monotonic in <var>w</var>
and a binary search for IMIN and IPREF may thus fail.

<p>The corresponding definitions for vertical elements are analogous,
with width and height swapped.

<p class=issue>We probably want a definition that gives the same
result in easy cases (only inline content) but is quicker to compute
in complex cases.



<h2 id=intrinsic-low>Definition of intrinsic sizes &ndash; low
quality</h2>

<p>UA's may also, if speed is preferred over quality, use the
<dfn>approximate intrinsic minimum</dfn> width (<dfn>AMIN</dfn>)
instead of <span>IMIN</span> and the <dfn>approximate intrinsic
preferred</dfn> width (<dfn>APREF</dfn>):

<blockquote>
<p>AMIN = max(<var>W<sub>1</sub></var>,<var>W<sub
>2</sub></var>,<var>W<sub >3</sub></var>,<var>W<sub>4</sub></var>)
<br>
APREF = max(<var>P<sub>1</sub></var>,<var>P<sub
>2</sub></var>,<var>P<sub >3</sub></var>,<var>P<sub>4</sub></var>)
</blockquote>

<p>where

<dl>
<dt><var>W<sub>1</sub></var>

<dd>Break the text content of <var>E</var> at all possible break
points and find the width <var>W<sub>1</sub></var> of the widest
stretch of unbreakable text. Break points are determined as normal,
i.e., taking 'white-space' into account and using language-dependent
information, such as whether hyphens are added after a break. If
'text-indent' applies to the text, add its value to the first stretch
(which may thus get a negative width, if 'text-indent' is sufficiently
negative). If there is no text, or if the widest stretch has a
negative width, then <var>W<sub>1</sub></var> is set to 0.

<dt><var>W<sub>2</sub></var>

<dd>Let <var>W<sub>2</sub></var> be the largest of the widths of the
margin boxes of all <em>replaced</em> child elements that have an
intrinsic width, a 'position' of ''static'' or ''relative'', and a
'display' other than ''none''. If there are no such children, or if
the largest width is negative, <var>W<sub>2</sub></var> is 0.

<dt><var>W<sub>3</sub></var>

<dd>(Recursively) determine the AMIN<sub>i</sub> of all
<em>horizontal,</em> non-replaced child elements
<var>C<sub>i</sub></var> with a 'position' of ''static'' or
''relative'' and a 'display' other than ''none''. Let
<var>w<sub>i</sub></var> be the sum of AMIN<sub>i</sub> and the left
and right margins, padding and border of <var>C<sub>i</sub></var>. 
Then <var>W<sub>3</sub></var> is the largest of those
<var>w<sub>i</sub></var>. If there are no such child elements, or if
the largest <var>w<sub>i</sub></var> is negative, then
<var>W<sub>3</sub></var> is 0.

<dt><var>W<sub>4</sub></var>

<dd>Let <var>W<sub>4</sub></var> be the largest of the widths of the
margin boxes of all <em>vertical,</em> non-replaced child elements
with 'position' either ''static'' or ''relative'', 'display' other
then ''none'' and 'width' set to a <var>&lt;length&gt;</var>. If there
are no such elements, or if the largest of the widths is negative,
then <var>W<sub>4</sub></var> is 0. <span class=note>Note that this
calculation does not require looking at the contents of
elements.</span>

<dt><var>P<sub>1</sub></var>

<dd class=issue>&hellip; [Define inline formatting contexts as longest
sequences of text and elements without hard line breaks or blocks?]

</dl>

<p class=note>Note that several kinds of child elements are ignored
for the calculation of AMIN, e.g., <em>vertical</em> elements with
'width' of ''auto''. Also, tables aren't laid out.

<p>The corresponding definitions for vertical elements are analogous,
with width and height swapped.



<h2 id=Calculating>Calculating widths, heights and margins</h2>

<p>The following two algorithms define the <em>used value</em> of
'width' and 'height' respectively and also the used values of the
'margin' properties and of 'top', 'right' 'bottom' and 'left'.

<p class=note>Note that they do not affect the computed values of
'width' and 'height'. Also note that in some cases the used width has
to be known in order to calculate the used height, or vice versa,

<p>For 'width':

<ol>
  <li>The tentative used width is calculated following the rules in
  the subsections below. If 'transform' is not ''none'', it is assumed
  to be 'rotate(0)' (i.e., the identity transform) for the purposes of
  this calcutlation.

  <li>If the tentative used width is greater than 'max-width', the same
  rules are applied again, but this time using the computed value of
  'max-width' as the computed value for 'width'.

  <li>If the resulting width is smaller than 'min-width', the same rules
  are applied again, but this time using the computed value of
  'min-width' as the computed value for 'width'.
</ol>

<p>For 'height':

<ol>
  <li>The tentative used height is calculated following the rules in
  the sections below. If 'transform' is not ''none'', it is assumed to
  be 'rotate(0)' (i.e., the identity transform) for the purposes of
  this calcutlation.

  <li>If the tentative used height is greater than 'max-height', the
  same rules are applied again, but this time using the computed value
  of 'max-height' as the computed value for 'height'.

  <li>If the resulting height is smaller than 'min-height', the same
  rules are applied again, but this time using the computed value of
  'min-height' as the computed value for 'height'.
</ol>

<p>If 'transform' is not ''none'', the used width or height is further
modified as follows:

<ul>
  <li>If the element is <em>horizontal</em> and 'height' is ''auto'',
  then the used height is the height of the content box after the
  transformation is applied.

  <li>If the element is <em>vertical</em> and 'width' is ''auto'',
  then the used width is the width of the content box after the
  transformation is applied.
</ul>

<p class=note>Note that translations [[!CSS3-2D-TRANSFORMS]] do not
affect the width or height and also do not affect the placement of
boxes in the normal flow (see <a href="#basic">“Basic flow layout”
</a>).

<p>However, for <em>replaced elements</em> with an <em>intrinsic
ratio</em> and both 'width' and 'height' specified as ''auto'', the
algorithm is as follows:

<p>Select from the table the resolved height and width values for the
appropriate constraint violation. Take the <var>max-width</var> and
<var>max-height</var> as max(min, max) so that <var>min</var> &#8804
<var>max</var> holds true. In this table <var>w</var> and <var>h</var>
stand for the results of the width and height computations ignoring
the 'min-width', 'min-height', 'max-width' and 'max-height'
properties. Normally these are the intrinsic width and height, but
they may not be in the case of replaced elements with intrinsic
ratios.

<table class=equiv-table>
<thead>
  <tr><th>Constraint violation <th>Resolved width <th>Resolved height
<tbody>
  <tr><td>none
      <td><var>w</var>
      <td><var>h</var>
  <tr><td><var>w&nbsp;>&nbsp;max-width</var>
      <td><var>max-width</var>

      <td><var>max(max-width&nbsp;*&nbsp;h/w, min-height)</var>
  <tr><td><var>w&nbsp;&lt;&nbsp;min-width</var>
      <td><var>min-width</var>
      <td><var>min(min-width&nbsp;*&nbsp;h/w, max-height)</var>

  <tr><td><var>h&nbsp;>&nbsp;max-height</var>
      <td><var>max(max-height&nbsp;*&nbsp;w/h, min-width)</var>
      <td><var>max-height</var>
  <tr><td><var>h&nbsp;&lt;&nbsp;min-height</var>

      <td><var>min(min-height&nbsp;*&nbsp;w/h, max-width)</var>
      <td><var>min-height</var>
  <tr><td>(<var>w&nbsp;>&nbsp;max-width</var>) and (<var>h&nbsp;>&nbsp;max-height</var>), where (<var>max-width/w&nbsp;&#8804;&nbsp;max-height/h</var>)

      <td><var>max-width</var>
      <td><var>max(min-height, max-width&nbsp;*&nbsp;h/w)</var>
  <tr><td>(<var>w&nbsp;>&nbsp;max-width</var>) and (<var>h&nbsp;>&nbsp;max-height</var>), where (<var>max-width/w&nbsp;>&nbsp;max-height/h</var>)

      <td><var>max(min-width, max-height&nbsp;*&nbsp;w/h)</var>
      <td><var>max-height</var>
  <tr><td>(<var>w&nbsp;&lt;&nbsp;min-width</var>) and (<var>h&nbsp;&lt;&nbsp;min-height</var>), where (<var>min-width/w&nbsp;&#8804;&nbsp;min-height/h</var>)

      <td><var>min(max-width, min-height&nbsp;*&nbsp;w/h)</var>
      <td><var>min-height</var>
  <tr><td>(<var>w&nbsp;&lt;&nbsp;min-width</var>) and (<var>h&nbsp;&lt;&nbsp;min-height</var>), where (<var>min-width/w&nbsp;>&nbsp;min-height/h</var>)

      <td><var>min-width</var>
      <td><var>min(max-height, min-width&nbsp;*&nbsp;h/w)</var>
  <tr><td>(<var>w&nbsp;&lt;&nbsp;min-width</var>) and (<var>h&nbsp;>&nbsp;max-height</var>)

      <td><var>min-width</var>
      <td><var>max-height</var>
  <tr><td>(<var>w&nbsp;>&nbsp;max-width</var>) and (<var>h&nbsp;&lt;&nbsp;min-height</var>)

      <td><var>max-width</var>
      <td><var>min-height</var>
</tbody>
</table>

<p>Then apply the appropriate rules in the subsections below, as if
'width' and 'height' were computed as these values.

<p class=note>Note that some values of the 'image-scaling' property
([[CSS3PAGE]]) may further change the used values of 'width' and
'height'.

<p>The following subsections apply if the element's <em>containing
block</em> is <em>horizontal.</em> If it is <em>vertical,</em> the
same rules apply, but with every occurrence of “left” replaced by
“top,” “right” by “bottom,” “top” by “right,” “bottom” by “left”,
“height” by “width” and “width” by “height.”

<!-- '100vw' decided at ftf Sep 10, 2007. '100vh' is my sugggestion
[BB] --> <p>For the purposes of evaluating percentages in the
following subsections, if the width of the containing block is
unknown, then assume the width is '100vw'. Likewise, if the height of
the containing block is unknown, then assume it is '100vh'.



<h3 id=inline-non-replaced>Inline, non-replaced
elements</h3>

<p>The 'width' and 'height' properties do not apply. For each of
'left', 'right', 'top', 'bottom', 'margin-left', 'margin-right',
'margin-top' and 'margin-bottom', the used value is calculated from
the computed value by evaluating percentages and replacing ''auto'' by
0.

<p class=note>Note that this section applies equally when
the <em>containing block</em> is <em>horizontal</em> as when it
is <em>vertical.</em>



<h3 id=inline-replaced>Inline or floating, replaced
elements</h3>

<p>The used values of 'margin-left', 'margin-right', 'margin-top' and
'margin-bottom' derive from the computed value, except that a computed
value of ''auto'' becomes a used value of '0'.

<p>If 'height' and 'width' both have computed values of ''auto'' and
the element also has an intrinsic width, then that intrinsic width is
the used value of 'width'.

<p>If 'height' and 'width' both have computed values of ''auto'' and
the element also has an intrinsic height, then that intrinsic height
is the used value of 'height'.

<p>If 'height' and 'width' both have computed values of ''auto'' and
the element has no intrinsic width, but does have an intrinsic height
and intrinsic ratio; or if 'width' has a computed value of ''auto'',
'height' has some other computed value, and the element has an
intrinsic ratio; then the used value of 'width' is:

  <blockquote><p>(used height) * (intrinsic ratio)</blockquote>

<p>If 'height' and 'width' both have computed values of ''auto'' and
the element has no intrinsic height, but does have an intrinsic width
and intrinsic ratio; or if 'height' has a computed value of ''auto'',
'width' has some other computed value, and the element has an
intrinsic ratio; then the used value
of 'height' is:

  <blockquote><p>(used width) / (intrinsic ratio)</blockquote>

<p>If 'height' and 'width' both have computed values of ''auto'' and
the element has an intrinsic ratio but no intrinsic height or width
and the containing block's width doesn't itself depend on the replaced
element's width, then the used value of 'width' is calculated from the
<a href="#width-constraints">constraint equation</a> used for
block-level, non-replaced elements in normal flow. The used value for
'height' is: (used width) / (intrinsic ratio).

<p>If 'width' has a computed value of 'auto', and the element has an
intrinsic width but no intrinsic ratio, then that intrinsic width is
the used value of 'width'.

<p>If 'height' has a computed value of 'auto', and the element has an
intrinsic height but no intrinsic ratio, then that intrinsic width is
the used value of 'width'.

<p>If 'width' has a computed value of ''auto'', but none of the
conditions above are met, then the used value of 'width' becomes
300px. If 300px is too wide to fit the device, UAs should use the
width of the largest rectangle that has a 2:1 ratio and fits the
device instead.

<p>If 'height' has a computed value of ''auto'' and none of the rules
above define its used value, then the used value of 'height' must be
set to the height of the largest rectangle that has a 2:1 ratio, has a
height not greater than 150px, and has a width not greater than the
device width.

  <p class=issue>Theoretically, a device may be wider than than 300px
  but not tall enough for 150px. In that case the resulting replaced
  element will be too tall. But this is the formulation in CSS 2.1 and
  it seems not worth improving such an edge case.

<p>Percentage intrinsic widths are first evaluated with respect to the
containing block's width, if that width doesn't itself depend on the
replaced element's width. If it does, then a percentage intrinsic
width on that element can't be resolved and the element is assumed to
have no intrinsic width.

  <p class=note>Note that this section applies equally when the
  <em>containing block</em> is <em>horizontal</em> as when it is
  <em>vertical.</em>



<h3 id=blockwidth>Block-level, non-replaced elements
in normal flow
when 'overflow' computes to ''visible''</h3>

<p>This section also applies to <span>block-level</span> non-replaced
elements in normal flow when 'overflow' does not compute to
''visible'' but has been propagated to the viewport.

<p>The used values of the <span>head</span> padding, <span>tail</span>
padding, <span>head</span> margin and <span>tail</span> margin are
calculated from their computed values, with any ''auto'' values
replaced by 0.

<p>If the computed value of the <span>block flow dimension</span> is
not ''auto'', then the used value is calculated by evaluating the
computed value. Otherwise, the <span>block flow dimension</span> is
the distance between two edges that are defined as follows:

<ul>
<li>For the first edge: If the element is the <span>root
element</span> or if it has a non-zero <span>head</span> padding or a
non-zero <span>head</span>
border, then the first edge is the <span>headside</span> <em>margin
edge</em> of the first <span>line box</span> or <span>block-level
box</span> (whichever comes first); otherwise the first edge is the
<span>headside</span> <em>border edge</em> of the first <span>line
box</span> or <span>block-level box</span> (whichever comes first)
that doesn't have its margins <span>collapsed through.</span>

<li>For the second edge: If the element is the <span>root
element</span> or if it has a non-zero <span>tail</span> padding or a
non-zero <span>tail</span>
border, then the second edge is the <span>tailside</span> <em>margin
edge</em> of the last <span>line box</span> or <span>block-level
box</span> (whichever comes last); otherwise the second edge is the
<span>tailside</span> <em>border edge</em> of the last <span>line
box</span> or <span>block-level box</span> (whichever comes last) that
doesn't have its margins <span>collapsed through.</span>
</ul>

<p class=note>The above reflects the fact that the margins of the
element may collapse with the margins of its first and last children
(unless the element has a border or padding). In that case the
children's margins fall outside the block flow dimension.

<p>The position of the edges is calculated without applying relative
positioning, if any, to the children. And only children in the normal
flow are taken into account, i.e., floating boxes and absolutely
positioned boxes are ignored.

<div class=example>
<p>For example, the DIV in this fragment has a bottom border but no
padding or border at the top. The height is thus calculated from the
<em>border</em> edge of the first child (img1) to the <em>margin</em>
edge of the last child (img2). The result is 8em.

<pre>
div {border-bottom: 0.2em dashed}
img {height: 3em; display: block; margin: 1em}
...
&lt;div>
  &lt;img src="img1" alt=...>
  &lt;img src="img2" alt=...>
&lt;/div>
</pre>

  <div class=figure>
    <p><img src="height.png" alt="The top margin of the first IMG does
    not contribute to the height of the DIV.">

    <p class=caption>The height is measured from the top border edge
    of the first IMG to the bottom margin edge of the last.
  </div>
</div>

<p>With respect to the <span>inline dimension,</span> the following
constraint must hold among the used values of the given properties.

  <blockquote id=width-constraints>
  <p>start margin + start border + start padding + inline dimension +
  end padding + end border + end margin = inline dimension of
  containing block
  </blockquote>

<p>The used values of the above properties, except for any values that
are ''auto'', are calculated from the computed values, evaluating
percentages. If this makes the inline dimension negative, then set
its used value to 0. Ditto for start padding and end
padding. <span class=note>Note that such negative values can only
happen when the specified value includes 'calc()'.</span> Then apply
one of the following cases:

<ol>
  <li id=case1>
  <p>If none of the values is ''auto'', then there are three
  sub-cases:

  <ol>
    <li>If the current element's 'alignment' is ''center'', then the
    used values of start margin and end margin are set so that they
    are the same and the constraint is satisfied.

    <li>If 'alignment' corresponds to the <em>end</em> edge, then the
    used value of the end margin is set to the value that satisfies
    the constraint.

    <li>If 'alignment' has any other value, then the used value of the
    start margin is set to the value that satisfies the constraint.
  </ol>

  <li>If the <span>inline dimension</span> is ''auto'', then set the
  used value of all other properties in the constraint that are
  ''auto'' to 0 and set the used value of the inline dimension so
  that the constraint is satisfied. If that makes the used value
  negative, then set it to 0 instead and apply <a href="#case1">case 1
  above.</a>

  <li>If both the <span>start</span> and <span>end</span> margins are
  ''auto'', and 'alignment' is 'center', then solve the constraint
  under the extra condition that the start and end margin are equal.

  <li>If both the <span>start</span> and <span>end</span> margins are
  ''auto'', and 'alignment' is not 'center', then solve the constraint
  under the extra condition that the start and end margins are equal.
  But if that makes them negative, then set both to 0 and
  apply <a href="#case1">case 1 above.</a>

  <li>If only the <span>start</span> margin is ''auto'' and
  'alignment' corresponds to the <span>end</span> edge, then set the
  start margin to the value that satisfies the constraint.

  <li>If only the <span>start</span> margin is ''auto'' and
  'alignment' does not correspond to the <span>end</span> edge, then
  set the start margin to the value that satisfies the constraint. But
  if that makes it negative, then set it to 0 instead and
  apply <a href="#case1">case 1 above.</a>

  <li>If only the <span>end</span> margin is ''auto'' and 'alignment'
  corresponds to the <span>start</span> edge, then set the end margin
  to the value that satisfies the constraint.

  <li>If only the <span>end</span> margin is ''auto'' and 'alignment'
  does not correspond to the <span>start</span> edge, then set
  the <span>end</span> margin to the value that satisfies the
  constraint. But if that makes it negative, then set it to 0 instead
  and apply <a href="#case1">case 1 above.</a>
</ol>

  <p class=note>Note that the best way to center a block is
  'margin-left: auto; margin-right: auto; alignment: center'. Setting
  the margins to ''auto'', instead of leaving them at 0, provides a
  fallback for UAs that do not support 'alignment' (which is a level 3
  feature).

  <p class=note>Note also that only 'alignment: center' guarantees
  proper centering. Setting the margins to ''auto'' only centers
  blocks if they are narrower than their containing block, because
  only one of the two margins is allowed to become negative.

<div class=example>
  <p>The following examples illustrate different ways of aligning a
  fixed-width block in its parent. Assume English text, default values
  for 'block-flow' and 'direction', a P of fixed with (e.g., 'width:
  30em'), and the following HTML mark-up:

<pre>
&lt;div>
  &lt;p>A paragraph here.
&lt;/div>
</pre>

  <p>The following aligns the right border edge of the P with the
  right content edge of the DIV:

  <pre>p {alignment: right}</pre>

  <p>The following centers the P:

  <pre>p {alignment: center}</pre>

  <p>Adding ''auto'' margins provides a fallback for UAs that do not
  support 'alignment'. (The fallback has the desired effect as long as
  the DIV is wider than the P.)

  <pre>p {margin-left: auto; margin-right: auto; alignment: center}</pre>

  <p>“Conflicting” combinations of ''auto'' margins and 'alignment'
  are well-defined, but not very useful. They cause 'alignment' to be
  all but ignored. The following right-aligns the P (unless it is too
  wide for the DIV):

  <pre>p {margin-left: auto; alignment: left}</pre>

  <p>Similarly, the following left-aligns the P in the DIV:

  <pre>p {margin-right: auto; alignment: right}</pre>

  <p>Fixed or percentage margins can be combined with alignment. The
  following puts the right border edge of the P at 2em inside the
  right content edge of the DIV:

  <pre>p {margin-right: 2em; alignment: right}</pre>

  <p>The following does the same. The value of 'margin-left' is
  ignored in a right-aligned block:

  <pre>p {margin-right: 2em; margin-left: 4em; alignment: right}</pre>
</div>



<h3>Other block-level, non-replaced elements in normal flow</h3>

<p>This section applies to <span>block-level,</span> non-replaced
elements when 'overflow' does not compute to ''visible'' (except if
the 'overflow' property's value has been propagated to the viewport).

<p>The used values of <span>head</span> padding, <span>tail</span>
padding, <span>head</span> margin and <span>tail</span> margin are
calculated from the computed values, with any ''auto'' values replaced
by 0.

<p>If the <span>block flow dimension</span> is ''auto'', the used value
is defined by <a href="#root-height">“''Auto'' heights for flow
roots.”</a> Otherwise, the used value is evaluated from the computed
value.

<p>Apply the rules for <span>start</span> margin, <span>start</span>
padding, <span>inline dimension,</span> <span>end</span> padding and
<span>end</span> margin as given above in <a href="#blockwidth">
“Block-level, non-replaced elements in normal flow when 'overflow'
computes to ''visible''.”</a>



<h3>'Inline-block' or floating, non-replaced
elements</h3>

<p class=issue>Not yet generalized with head, tail, etc.

<p>The used values of 'margin-left', 'margin-right', 'margin-top' and
'margin-bottom' are derived from their computed values, except that a
computed value of ''auto'' gives a used value of 0.

<p>If the computed value of 'width' is ''auto'', the used value is the
same as for ''fit-content''. Otherwise the computed value is evaluated
to give the used value.

<p>If the computed value of 'height' is ''auto'', the used value is
defined by <a href="#root-height">“''Auto'' heights for flow roots.”
</a> If it contains a percentage and the height of the containing
block is not known (depends on this element), then the used value is
also defined by <a href="#root-height">“''Auto'' heights for flow
roots.”</a> Otherwise it is calculated by evaluating the computed
value.

<p>For inline-block boxes, the margin box is used when calculating the
height of the line box. <span class=issue>Does this belong
here?</span>



<h3 id=abs-non-replaced-width>Absolutely positioned, non-replaced
elements</h3>

<p>For the purposes of this section and the next, the term <dfn>static
position</dfn> (of an element) refers, roughly, to the position an
element would have had in the normal flow. More precisely:

<ul>
  <li>The static position for 'left' is the distance from the left
  edge of the containing block to the left margin edge of a
  hypothetical box that would have been the first box of the element
  if its 'position' property had been ''static'' and 'float' had been
  'none'. The value is negative if the box's margin is to the left
  of the containing block's edge.

  <li>The static position for 'right' is the distance from the right
  edge of the containing block to the right margin edge of the same
  hypothetical box as above. The value is positive if the box's margin
  is to the left of the containing block's edge.

  <li>The static position for 'top' is the distance from the top edge
  of the containing block to the top margin edge of the same
  hypothetical box as above. The value is negative if the box's margin
  is above the containing block's edge.

  <li>The static position for 'bottom' is the distance from the bottom
  edge of the containing block to the bottom margin edge of the same
  hypothetical box as above. The value is positive if the box's margin
  is above the containing block's edge.
</ul>

<p>But rather than actually calculating the dimensions of that
hypothetical box, user agents are free to make a guess at its probable
position.

<p>For the purposes of calculating the static position, the containing
block of fixed positioned elements is the initial containing block
instead of the viewport, and all scrollable boxes should be assumed to
be scrolled to their origin.

<p>This constraint must hold among the used values:

  <blockquote>
  <p>'left' + 'margin-left' + 'border-left-width' + 'padding-left' +
  'width' + 'padding-right' + 'border-right-width' + 'margin-right' +
  'right' = width of containing block
  </blockquote>

<p>If all three of 'left', 'width', and 'right' are ''auto'': First
set any ''auto'' values for 'margin-left' and 'margin-right' to 0. Then,
if the 'direction' property of the containing block is ''ltr'' set
'left' to the <em>static position</em> and apply rule number three
below; otherwise, set 'right' to the <em>static position</em> and
apply rule number one below.

<p>If none of the three is ''auto'': If both 'margin-left' and
'margin-right' are ''auto'', solve the equation under the extra
constraint that the two margins get equal values, unless this would
make them negative, in which case when direction of the containing
block is ''ltr'' (''rtl''), set 'margin-left' ('margin-right') to zero
and solve for 'margin-right' ('margin-left'). <span class=issue>Should
we remove the phrase starting with “unless”?</span> If one of
'margin-left' or 'margin-right' is ''auto'', solve the equation for that
value. If the values are over-constrained, ignore the value for 'left'
(in case the 'direction' property of the containing block is ''rtl'')
or 'right' (in case 'direction' is ''ltr'') and solve for that value.

<p>Otherwise, set ''auto'' values for 'margin-left' and 'margin-right'
to 0, and pick the one of the following six rules that applies.

<ol>
  <li>'left' and 'width' are ''auto'' and 'right' is not ''auto'',
  then the width is as for ''fit-content''. Then solve for 'left'.

  <li>'left' and 'right' are ''auto'' and 'width' is not ''auto'', then
  if the 'direction' property of the containing block is ''ltr'' set
  'left' to the <em>static position</em>, otherwise set 'right' to
  the <em>static position</em>. Then solve for 'left' (if 'direction'
  is ''rtl'') or 'right' (if 'direction' is ''ltr'').

  <li>'width' and 'right' are ''auto'' and 'left' is not ''auto'',
  then the width is ''fit-content''. Then solve for 'right'.

  <li>'left' is ''auto'', 'width' and 'right' are not ''auto'', then
  solve for 'left'.

  <li>'width' is ''auto'', 'left' and 'right' are not ''auto'', then
  solve for 'width'.

  <li>'right' is ''auto'', 'left' and 'width' are not ''auto'', then
  solve for 'right'.
</ol>

<p>This constraint must also hold among the used values:

  <blockquote>      
  <p>'top' + 'margin-top' + 'border-top-width' + 'padding-top' +
  'height' + 'padding-bottom' + 'border-bottom-width' +
  'margin-bottom' + 'bottom' = height of containing block
  </blockquote>

<p>If all three of 'top', 'height', and 'bottom' are ''auto'', set
'top' to the static position and apply rule number three below.

<p>If none of the three are ''auto'': If both 'margin-top' and
'margin-bottom' are ''auto'', solve the equation under the extra
constraint that the two margins get equal values. If one of
'margin-top' or 'margin-bottom' is ''auto'', solve the equation for
that value. If the values are over-constrained, ignore the value for
'bottom' and solve for that value.

<p>Otherwise, pick the one of the following six rules that applies.

<ol>
  <li>'top' and 'height' are ''auto'' and 'bottom' is not ''auto'':
  The used value of 'bottom' is its computed value. The used height is
  defined by <a href="#root-height">“''Auto'' heights for flow roots.”
  </a> The used values of 'margin-top' and 'margin-bottom' are their
  computed values, except that any ''auto'' gives a used value of 0. 
  Finally, the constraint gives the used value of 'top'.

  <li>'top' and 'bottom' are ''auto'' and 'height' is not ''auto'':
  The used value of 'top' is its <em>static position.</em> The used
  values of 'margin-top' and 'margin-bottom' are their computed
  values, except that any ''auto'' gives a used value of 0. Finally,
  the constraint gives the used value for 'bottom'.

  <li>'height' and 'bottom' are ''auto'' and 'top' is not ''auto'':
  The used height is defined by <a href="#root-height">“''Auto''
  heights for flow roots.”</a> The used values of 'margin-top' and
  'margin-bottom' are their computed values, except that any ''auto''
  gives a used value of 0. Finally, the constraint gives the used
  value of 'bottom'.

  <li>'top' is ''auto'', 'height' and 'bottom' are not ''auto'': The
  used values of 'margin-top' and 'margin-bottom' are their computed
  values, except that any ''auto'' gives a used value of 0. The
  constraint gives the used value for 'top'.

  <li>'height' is ''auto'', 'top' and 'bottom' are not ''auto'': The
  used values of 'margin-top' and 'margin-bottom' are their computed
  values, except that any ''auto'' gives a used value of 0. The
  constraint gives the used value for 'height'.

  <li>'bottom' is ''auto'', 'top' and 'height' are not ''auto'': The
  used values of 'margin-top' and 'margin-bottom' are their computed
  values, except that any ''auto'' gives a used value of 0. The
  constraint gives the used value for 'bottom'.
</ol>



<h3 id=abs-replaced>Absolutely positioned, replaced
elements</h3>

<p>This situation is similar to the previous one, except that the
element may have an intrinsic size or ratio. The sequence of
substitutions is now:

<ol>
  <li>The used value of 'width' and 'height' is determined as
  for <a href="#inline-replaced">inline replaced elements</a>.

  <li>For each of 'top', 'right', 'bottom', 'left', 'margin-top',
  'margin-right', 'margin-bottom' and 'margin-left', if the computed
  value is not ''auto'', the used value is equal to the computed
  value.

  <li>If both 'left' and 'right' have the value ''auto'', then if
  'direction' of the containing block is ''ltr'', the used value of
  'left' is its <em>static position;</em> else if 'direction' is
  ''rtl'', the used value of 'right' is its <em>static position.</em>

  <li>If both 'top' and 'bottom' have the value ''auto'', then the
  used value of 'top' is its <em>static position.</em>

  <li>If 'left' or 'right' (or both) are ''auto'', and 'margin-left'
  is ''auto'', then the used value of 'margin-left' is 0.

  <li>If 'left' or 'right' (or both) are ''auto'', and 'margin-right'
  is ''auto'', then the used value of 'margin-right' is 0.

  <li>If neither 'left' nor 'right' are ''auto'' and both
  'margin-left' and 'margin-right' are ''auto'', then the used values
  satisfy the extra constraint that 'margin-right' and 'margin-left'
  are equal, unless this would make them negative, in which case when
  the direction of the containing block is ''ltr'' (''rtl''), the used
  value of 'margin-left' ('margin-right') is
  0. <span class=issue>Remove the part starting with “unless”? It
  looks better to center the image.</span>
</ol>

<p>The remaining used values, if any, follows from these two
constraints:

  <blockquote>
  <p>'left' + 'margin-left' + 'border-left-width' + 'padding-left' +
  'width' + 'padding-right' + 'border-right-width' + 'margin-right' +
  'right' = width of containing block

  <p>'top' + 'margin-top' + 'border-top-width' + 'padding-top' +
  'height' + 'padding-bottom' + 'border-bottom-width' +
  'margin-bottom' + 'bottom' = height of containing block
  </blockquote>

<p>If the first equation is over-constrained, ignore the value for
either 'left' (in case the 'direction' property of the containing
block is ''rtl'') or 'right' (in case 'direction' is ''ltr'') and solve
for that value.

<p>If the second equation is over-constrained, ignore the value for
'bottom' and solve for that value.



<h3>Block-level, replaced elements in normal flow</h3>

<p>Apply the rules for <a href="#inline-replaced">inline replaced
elements</a>, but ignore the resulting values for 'margin-left' and
'margin-right'. To compute the used value of those, apply the rules
for <a href="#blockwidth">block-level, non-replaced elements</a> using
the used values just found for 'width', 'border' and 'padding' as if
they were the computed values.



<h3>Floating, non-replaced elements</h3>

<p>The used values of the margins are derived from the computed
values, except that the used values of any margins computed as
''auto'' are '0'.

<p>The used value of 'width' is derived from the computed value,
except that if 'width' is computed as ''auto'', the used value is the
same as for ''fit-content''.

<p>If the computed value of 'height' is ''auto'', the used value is
given by <a href="#root-height">“''Auto'' heights for flow roots.”
</a> If the computed value includes a percentage and the height of the
containing block is not known (depends on this element), then the used
value is computed as if the computed value were ''auto''. Otherwise
the computed value is evaluated to give the used value.



<h3 id=root-height>Auto heights for flow roots</h3>

<p>In certain cases (see the preceding sections), the height of an
element is computed as follows:

<p>If it only has inline-level children, the height is the distance
between the top of the topmost line box and the bottom of the
bottommost line box.

<p>If it has <span>block-level</span> children, the height is the
distance between the top margin-edge of the topmost block-level child
box and the bottom margin-edge of the bottommost block-level child
box.

<p>Absolutely positioned children are ignored, and relatively
positioned boxes are considered without their offset. Note that the
child box may be an <em>anonymous block box.</em>

<p>In addition, if the element has any floating descendants whose
bottom margin edge is below the bottom, then the height is increased
to include those edges. Only floats that are children of the element
itself or of descendants in the normal flow are taken into account,
e.g., floats inside absolutely positioned descendants or other floats
are not.



<h2>The float property</h2>

<table class=propdef>
  <tr><td>Name: <td><dfn>float</dfn>
  <tr><td>Value: <td>[ left | right | top | bottom | start | end | none |
    <var>&lt;page-floats&gt;</var> ] && contour?
  <tr><td>Initial: <td>none 
  <tr><td>Applies to: <td>all, but see text
  <tr><td>Inherited: <td>no 
  <tr><td>Percentages: <td>N/A 
  <tr><td>Media: <td>visual 
  <tr><td>Computed value: <td>as specified
</table>

<p class=issue>Adding ''start'' and ''end'' was decided at 2009-12-02
telcon. Precide definitions not yet decided: does it depend on
'direction' of the element itself or its parent?

<p>This property specifies whether a box should float to the left,
right, or not at all. It only applies if the element has a
'display' other than ''none'' and a 'position' of ''static'' or
''relative''.

<p class=note>The 'float' property in turn influences the computed
value of 'display'. See <a href="#display">“The display property.”</a>

<p>The values of this property have the following meanings:

<dl>
  <dt>top <dd>Same as ''left''

  <dt>left <dd>If 'block-flow' is ''tb'', the element generates
  a box that is floated to the left and content flows on the right
  side of the box (subject to the 'clear' property). If
  'block-flow' has a different value, the element generates a
  box that is floated to the top and content flows on the bottom side
  of the box (subject to the 'clear' property).

  <dt>bottom <dd>same as ''right''

  <dt>right</dt> <dd>Similar to ''left'', except the box is floated to
  the right (if 'block-flow' is ''tb'') or to the bottom
  (otherwise), and content flows on the left or top side of the
  box.

  <dt>start <dd>If the 'direction' property is ''ltr'', the same as
  ''left''; otherwise the same as ''right''.

  <dt>end <dd>If the 'direction' property is ''rtl'', the same as
  ''right''; otherwise the same as ''left''.

  <dt>none</dt> <dd>The box is not floated.

  <dt><var>&lt;page-floats&gt;</var> <dd>See Generated Content for
  Paged Media [[CSS3GCPM]]. <span class=issue>Check that the names
  page-top, page-bottom, next-top, or otherwise do not clash with top
  and bottom</span>

  <dt>contour <dd>Text is flowed around the actual shape of the
  element rather than around its margin box. Only applies if the
  element is a replaced element without a border and without padding.
  See under 'float-displace' for how it affects text flow.
</dl>

<p>User agents may treat float as ''none'' on the root element.

<p>The <dfn>exclusion zone</dfn> of a floating element is, roughly, the area
that text may not intrude into when it flows around a float. More
precisely, given a point <var>P</var> and a floating element
<var>F</var>, the following determines if <var>P</var> is inside or
outside the exclusion zone of <var>F</var>:

<ul>
<li>
  <p>If <var>F</var> is a replaced element and its value of 'float'
  includes the keyword ''contour'' and <var>F</var> has no border and
  no padding:

  <ul>
  <li>
    <p>If <var>F</var> is a <span>horizontal</span> element:

    <ul>
    <li>
      <p>If 'float' is ''left'' or ''top'', then <var>P</var> is
      inside the exclusion zone of <var>F</var> iff <var>P</var> or any point
      to the right of <var>P</var> on a horizontal line through
      <var>P</var> is a in a non-transparent area of <var>F</var>.

    <li>
      <p>If 'float' is ''right'' or ''bottom'', then <var>P</var> is
      inside the exclusion zone of <var>F</var> iff <var>P</var> or any point
      to the left of <var>P</var> on a horizontal line through
      <var>P</var> is a in a non-transparent area of <var>F</var>.
    </ul>

  <li>
    <p>If <var>F</var> is <span>vertical</span>:

    <ul>
    <li>
      <p>If 'float' is ''left'' or ''top'', then <var>P</var> is
      inside the exclusion zone of <var>F</var> iff <var>P</var> or any point
      below <var>P</var> on a vertical line through <var>P</var> is a
      in a non-transparent area of <var>F</var>.

    <li>
      <p>If 'float' is ''right'' or ''bottom'', then <var>P</var> is
      inside the exclusion zone of <var>F</var> iff <var>P</var> or any point
      above <var>P</var> on a vertical line through <var>P</var> is a
      in a non-transparent area of <var>F</var>.
    </ul>
  </ul>

<li>
  <p>If <var>F</var> is not a replaced element, or if 'float' does not
  include the keyword ''contour'', or if <var>F</var> has a border
  or a padding:

  <ul>
  <li>
    <p>If <var>F</var> is <span>horizontal</span>:

    <ul>
    <li>
      <p>If 'float' is ''left'' or ''top'', then <var>P</var> is
      inside the exclusion zone of <var>F</var> iff <var>P</var> or any point
      to the right of <var>P</var> on a horizontal line through
      <var>P</var> is inside the <span>margin area</span> of
      <var>F</var>.

    <li>
      <p>If 'float' is ''right'' or ''bottom'', then <var>P</var> is
      inside the exclusion zone of <var>F</var> iff <var>P</var> or any point
      to the left of <var>P</var> on a horizontal line through
      <var>P</var> is inside the <span>margin area</span> of
      <var>F</var>.
    </ul>

  <li>
    <p>If <var>F</var> is <span>vertical</span>:

    <ul>
    <li>
      <p>If 'float' is ''left'' or ''top'', then <var>P</var> is
      inside the exclusion zone of <var>F</var> iff <var>P</var> or any point
      below <var>P</var> on a vertical line through <var>P</var> is
      inside the <span>margin area</span> of <var>F</var>.

    <li>
      <p>If 'float' is ''right'' or ''bottom'', then <var>P</var> is
      inside the exclusion zone of <var>F</var> iff <var>P</var> or any point
      above <var>P</var> on a vertical line through <var>P</var> is
      inside the <span>margin area</span> of <var>F</var>.
    </ul>
  </ul>
</ul>

<p><dfn>Non-transparent</dfn> in this case means anything other than
fully transparent. E.g., an area that is 90%
transparent is non-transparent.

<div class=figure>
  <p><img src="contour.png" alt="The contour of a left-floating image
  includes all points that have a non-transparent part of the image to
  their right.">

  <p class=caption>When 'float' is 'left contour', then the exclusion zone of
  the element includes all non-transparent parts (blue) and all points
  that are to the left of a non-transparent part (grey).
</div>

<p class=note>Note that the 'margin' is ignored for the purposes of
determining the exclusion zone if ''contour'' is used. To create a
visual “margin” around an image, an author can instead include an area
in the image that is 99% transparent.

<p class=issue>It might occasionally be nice to be able to give that
“margin” a thickness in em without scaling the whole image, but that
is a difficult operation…

<p class=issue>Replaced elements can be handled by plug-ins and the
plug-in API may not provide access to the contour of the object.
Should there be a sentence about UAs not having to compute a contour
in such a case?



<h3>Introduction to floats</h3>

<p>(This section is not normative.)

<p>A float is a box that is shifted to the left or right on the
current line. The most interesting characteristic of a float (or
“floating” box) is that content may flow along its side (or be
prohibited from doing so by the 'clear' property). Content flows down
the right side of a left-floated box and down the left side of a
right-floated box. The following is a (non-normative) introduction to
float positioning and content flow; the exact rules governing float
positioning are given in the next section.

<p>A floated box is shifted to the left or right until its margin edge
touches the containing block edge or the margin edge of another float. 
If there is a line box, the top of the floated box is aligned with the
top of the current line box.

<p>If there isn't enough horizontal room for the float, it is shifted
downward until either it fits or there are no more floats present.

<p>Since a float is not in the flow, non-positioned block boxes
created before and after the float box flow vertically as if the float
didn't exist. However, <em>line boxes</em> created next to the float
are shortened to make room for the margin box of the float. If a
shortened line box is too small to contain any further content, then
it is shifted downward until either it fits or there are no more
floats present. Any content in the current line before a floated box
is re-flowed in the first available line on the other side of the
float. In other words, if inline boxes are placed on the line before a
left float is encountered that fits in the remaining line box space,
the left float is placed on that line, aligned with the top of the
line box, and then the inline boxes already on the line are moved
accordingly to the right of the float (the right being the other side
of the left float) and vice versa for rtl and right floats.

<div class=example>
<p>In the following document fragment, the containing block is too
narrow to contain the content next to the float, so the content gets
moved to below the floats where it is aligned in the line box
according to the text-align property.

<pre>
p { width: 10em; border: solid aqua; }
span { float: left; width: 5em; height: 5em; border: solid blue; }

...

&lt;p&gt;
  &lt;span&gt; &lt;/span&gt;
  Supercalifragilisticexpialidocious
&lt;/p&gt;
</pre>

<p>This fragment might look like this:

<div class=figure>
  <p><img src="supercal.png" alt="Image illustrating the effect of an
  unbreakable piece of content being reflowed to just after a float
  which left insufficient room next to it for the content to fit.">

  <p class=caption>The text is too long to fit in a shortened line box
  next to the float (dark blue box) and so it is pushed down until it
  is passed the float.
</div>
</div>

<p>Several floats may be adjacent, and this model also applies to
adjacent floats in the same line.

<div class=example>
<p>The following rule floats all IMG boxes with
<code>class="icon"</code> to the left (and sets the left margin to
'0'):

<pre>
img.icon { 
  float: left;
  margin-left: 0;
}
</pre>
</div>

<div class=example>
<p>Consider the following HTML source and style sheet:

<pre>
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;HTML&gt;
  &lt;HEAD&gt;
    &lt;TITLE&gt;Float example&lt;/TITLE&gt;
    &lt;STYLE type="text/css"&gt;
      IMG { float: left }
      BODY, P, IMG { margin: 2em }
    &lt;/STYLE&gt;
  &lt;/HEAD&gt;
  &lt;BODY&gt;
    &lt;P&gt;&lt;IMG src=img.png alt="This image will illustrate floats"&gt;
       Some sample text that has no other...
  &lt;/BODY&gt;
&lt;/HTML&gt;
</pre>

<p>The IMG box is floated to the left. The content that follows is
formatted to the right of the float, starting on the same line as the
float. The line boxes to the right of the float are shortened due to
the float's presence, but resume their “normal” width (that of the
containing block established by the P element) after the float. This
document might be formatted as:

<div class=figure>
  <p><img src="floateg.png"
     alt="Image illustrating how floating boxes interact with margins.">

  <p class=caption>An image showing the various margins of the BODY, P
  and IMG element. Not that the top margin of the floating IMG does
  not collapse with the top margins of the P and BODY elements.
</div>

<p>Formatting would have been exactly the same if the document had
been:

<pre>
&lt;BODY&gt;
  &lt;P&gt;Some sample text 
  &lt;IMG src=img.png alt="This image will illustrate floats"&gt;
           that has no other...
&lt;/BODY&gt;
</pre>

<p>because the content to the left of the float is displaced by
the float and re-flowed down its right side.
</div>

<p>As stated in <a href="#collapsing-margins">“Collapsing margins,”
</a> the margins of floating boxes never <em>collapse</em> with
margins of adjacent boxes. Thus, in the previous example, vertical
margins do not collapse between the P box and the floated IMG box.

<p>The contents of floats are stacked as if floats generated new
stacking contexts, except that any elements that actually create new
stacking contexts take part in the float's parent's stacking context. 
A float can overlap other boxes in the normal flow (e.g., when a
normal flow box next to a float has negative margins). When this
happens, floats are rendered in front of non-positioned in-flow
blocks, but behind in-flow inlines.

<div class=example>
<p>Here is another illustration, showing what happens when a float
overlaps borders of elements in the normal flow.

<div class=figure>
  <p><img src="float2p.png" alt="Image showing a floating image
  that overlaps the borders of two paragraphs: the borders are
  interrupted by the image.">

  <p class=caption>A floating image obscures borders of block boxes it
  overlaps.
</div>
</div>

<p>The following example illustrates the use of the 'clear' property
to prevent content from flowing next to a float.

<div class=example>
<p>Assuming a rule such as this:

<pre>
p { clear: left }
</pre>

<p>formatting might look like this:

<div class=figure>
  <p><img src="floatclear.png" alt="Image showing a floating
  image and the effect of 'clear: left' on the two paragraphs.">

  <p class=caption>Both paragraphs have set 'clear: left', which
  causes the second paragraph to be “pushed down” to a position
  below the float &ndash; <em>clearance</em> is added above its top margin
  to accomplish this (see the 'clear' property).
</div>
</div>



<h3>Rules for positioning floats</h3>

<p>Here are the precise rules that govern the positions of floats with
a <em>horizontal</em> containing block. References to other elements
in these rules refer only to other elements in the same <em>flow</em>
as the float's parent.

<ol>
<li>The left <span>margin edge</span> of a left-floating box may not
be to the left of the left edge of its <span>containing block</span>. 
An analogous rule holds for right-floating elements.

<!-- The A margin edge of box that floats to the A may not be to A of
the A edge of its containing block -->

<li>If the current box is left-floating, and there are any
left-floating boxes generated by elements earlier in the source
document, then for each such earlier box, either the left <span>margin
edge</span> of the current box must be to the right of the right
<span>margin edge</span> of the earlier box, or its top must be lower
than the bottom of the earlier box. Analogous rules hold for
right-floating boxes.

<li>The right <span>margin edge</span> of a left-floating box may not
be to the right of the left <span>margin edge</span> of any
right-floating box that is to the right of it. Analogous rules hold
for right-floating elements.

<li>A floating box's top <span>margin edge</span> may not be higher
than the top of its <span>containing block</span>. When the float
occurs between two collapsing margins, the float is positioned as if
it had an otherwise empty <span title="anonymous box">anonymous block
parent</span> taking part in the flow. The position of such a parent
is defined by <span title="collapsed through">the rules</span> in the
section on margin collapsing.

<li>The top <span>margin edge</span> of a floating box may not be
higher than the margin top of any <span>block-level</span> or
<span>floated</span> box generated by an element earlier in the source
document.

<li>The top <span>margin edge</span> of an element's floating box may
not be higher than the top of any <span>line-box</span> containing a
box generated by an element earlier in the source document.

<li>A left-floating box that has another left-floating box to its left
may not have its right margin edge to the right of its containing
block's right edge. (Loosely: a left float may not stick out at the
right edge, unless it is already as far to the left as possible.) An
analogous rule holds for right-floating elements.

<li>A floating box must be placed as high as possible.

<li>A left-floating box must be put as far to the left as possible, a
right-floating box as far to the right as possible. A higher position
is preferred over one that is further to the left/right.
</ol>

<div class=example>
<p>This HTML fragment results in the b floating to the right.

<pre>&lt;P>a&lt;SPAN style="float: right">b&lt;/SPAN>&lt;/P></pre>

<p>If the P element's width is enough, the a and the b will be side by
side. It might look like this:

<div class=figure>
<p><img src="float-right.png"
alt="An a at the left side of a box and a b at the right side">
</div>
</div>


<p>The rules for a float with a containing block with
'block-flow: rl' are exactly the same after replacing left with
top, right with bottom, top with right, bottom with left and adjusting
the text accordingly. Here they are:

<p class=issue>[Still some words like lower and higher to replace...]

<ol>
<li>The top <span>margin edge</span> of a top-floating box may not be
above the top edge of its <span>containing block</span>. An analogous
rule holds for bottom-floating elements.

<li>If the current box is top-floating, and there are any top-floating
boxes generated by elements earlier in the source document, then for
each such earlier box, either the top <span>margin edge</span> of the
current box must be below the bottom <span>margin edge</span> of the
earlier box, or its right must be to the left of the left margin edge
of the earlier box. Analogous rules hold for bottom-floating boxes.

<li>The bottom <span>margin edge</span> of a top-floating box may not
be below the top <span>margin edge</span> of any
bottom-floating box that is below it. Analogous rules hold
for bottom-floating elements.

<li>A floating box's right <span>margin edge</span> may not be to the
right of the right edge of its <span>containing block</span>. When the
float occurs between two collapsing margins, the float is positioned
as if it had an otherwise empty <span title="anonymous box">anonymous
block parent</span> taking part in the flow. The position of such a
parent is defined by <span title="collapsed through">the rules</span>
in the section on margin collapsing.

<li>The right <span>margin edge</span> of a floating box may not be to
the right of the right margin edge of any <span>block-level</span> or
<span>floated</span> box generated by an element earlier in the source
document.

<li>The right <span>margin edge</span> of an element's floating box
may not be to the right of the right edge of any <span>line-box</span>
containing a box generated by an element earlier in the source
document.

<li>A top-floating box that has another top-floating box above it
may not have its bottom margin edge below its containing
block's bottom edge. (Loosely: a top float may not stick out at the
bottom edge, unless it is already as far to the top as possible.) An
analogous rule holds for bottom-floating elements.

<li>A floating box must be placed as far to the right as possible.

<li>A top-floating box must be put as far to the top as possible, a
bottom-floating box as far to the bottom as possible. A position
further to the right is preferred over one that is further to the
top/bottom.
</ol>

<p>The rules for a float with a containing block with
'block-flow: lr' are exactly the same after replacing left with
top, right with bottom, top with left and bottom with right. They are
given here for completeness:

<p class=issue>[...]











<p class=note>Note that a box with a value of 'float' other than ''none''
is a <em>flow root.</em>

<p>The border box of a table, a <span>block-level</span> replaced
element, or an element in the normal flow that is a <em>flow root</em>
(such as an element with 'overflow' other than ''visible'') must not
overlap any floats in the same flow as the element itself. If
necessary, implementations should clear the said element by placing it
below any preceding floats, but may place it adjacent to such floats
if there is sufficient space, <span class=issue>by increasing one
margin and decreasing the opposite margin. (“Sufficient space” means
that the opposite margin does not become negative.)</span>



<h2>The clear property</h2>

<table class=propdef>
  <tr><td>Name: <td><dfn>clear</dfn>
  <tr><td>Value: <td>none | left | right | both
  <tr><td>Initial: <td>none 
  <tr><td>Applies to: <td><span>block-level</span> elements 
  <tr><td>Inherited: <td>no 
  <tr><td>Percentages: <td>N/A 
  <tr><td>Media: <td>visual 
  <tr><td>Computed value: <td>as specified
</table>

<p class=issue>[To do: copy from CSS2 [[!CSS21]] and generalize to
vertical text, define <dfn>clearance.</dfn>]



<h2>The clear-after property</h2>

<div id=contain-floats class=issue>
<p>The main use case is to make sure an element is at least as high as
all its floating descendants. I.e., at the end of the element, clear
the floats that are descendants of the element, but not any floats
that were declared before the element. There are three possible
approaches:

<ol>
<li>Set 'overflow' to anything else than 'visible' (and 'height' to
'auto'). This requires no new property, but has the side effect of
influencing the scrolling mechanism. It also doesn't clear any floats
that occurred before the element and doesn't distinguish left, right
or other floats. [2004-02-29 ftf]

<li>A new property 'clear-after' (see below).

<li>Use the value ''shrink-wrap'' on 'height' (and 'width', in case of
vertical text) to make an element into a <em>flow root.</em> This
requires no new property, only a new value, but doesn't clear any
floats before the element and doesn't distinguish left, right or other
floats. [The idea to add the functionality to 'height' is due to IanH
2004-02-29]

<li>A new value ''align-box'' on 'display'.
</ol>
</div>

<table class="propdef">
  <tbody>
    <tr>
      <td>Name:
      <td><dfn>clear-after</dfn>
    
    <tr valign="baseline">
      <td>Value:
      <td>none | left | right | top | bottom | inside | outside | start | end
        | both | descendants
    
    <tr valign="baseline">
      <td>Initial:
      <td>none
    
    <tr valign="baseline">
      <td>Applies to:
      <td>block-level elements
    
    <tr valign="baseline">
      <td>Inherited:
      <td>no
    
    <tr valign="baseline">
      <td>Percentages:
      <td>N/A
    
    <tr valign="baseline">
      <td>Media:
      <td>visual
    
    <tr>
      <td>Computed value:
      <td>specified value
    
  </tbody>
</table>

<p>It is sometimes useful to make sure that the bottom border of a
block-level element goes below floating elements. The 'clear-after'
property increases the element's padding as needed. More precisely: If
there are any floats in the current <em>flow</em> up to and including
the end of this element that float to the indicated side(s), then find
the one whose <em>tailside</em> <em>margin edge</em> is furthest away
from the <em>head</em> <em>content edge</em> of the <em>containing
block.</em> Then increase the tailside padding of the current element
by the minimum amount needed so that the padding edge is at least as
far away from the head content edge of the containing block as the
tailside margin edge of that float.

<p class=note>Note: Since a floating element is a <em>flow root,</em>
setting 'clear-after' on such an element only
takes into account any descendant floats in the flow established by the
element itself.

<p>The value of the property determines which kinds of floats are taken into
account:
<dl>
  <dt><dfn title="none!!value of 'clear-after'">none</dfn>
    <dd>No effect.
  <dt>left, top
    <dd>Only left and top floating elements are considered.
  <dt>right, bottom
    <dd>Only right and bottom floating elements are considered,
  <dt>inside
    <dd>If the bottom of the element occurs on a right-hand page, only left
      floating elements are considered. On a left-hand page, only right
      floating elements. On media that are not paged, 'inside' means the same
      as 'left'.
  <dt>outside
    <dd>Analogous
  <dt>start
    <dd>If the 'direction' of the element is
      'ltr', same as 'left', otherwise same as 'right'.
  <dt>end
    <dd>If the 'direction' of the element is
      'ltr', same as 'right', otherwise same as 'left'.
  <dt><dfn title="both!!value of 'clear-after'">both</dfn>
    <dd>Both left/top and right/bottom floats are considered.
  <dt>descendants
    <dd>All floats in the element's flow that are descendants of the
    element are considered, but not any other floats.
</dl>

<p class=issue>Use only two values: height-includes-floats and
height-does-not-include floats? [DavidB 2004-02-29]

<div class="figure">
<p><img src="clear-after.png" alt=" ">

<p class="caption">The effect of 'clear-after: left' on a paragraph next to a
floating image: the bottom padding of the paragraph is stretched, so that the
original padding and the border go below the float.
</div>

<div class=issue>
<p>Instead of a new property 'clear-after', another idea is to add one or
more values to 'clear'. If 'clear' is turned into a set, instead of a single
value, one could add the value 'after' (clears both left and right floats) or
several values like 'left-after' and 'right-after':

<table class="propdef-extra">
  <tbody>
    <tr>
      <td>Name:
      <td>clear
    
    <tr valign="baseline">
      <td>Value:
      <td>none | [ left | right | top | bottom | inside | outside | start |
        end | both | after]+
    
    <tr valign="baseline">
      <td>Initial:
      <td>none
    
    <tr valign="baseline">
      <td>Applies to:
      <td>block-level elements
    
    <tr valign="baseline">
      <td>Inherited:
      <td>no
    
    <tr valign="baseline">
      <td>Percentages:
      <td>N/A
    
    <tr valign="baseline">
      <td>Media:
      <td>visual
    
    <tr>
      <td>Computed value:
      <td>specified value
    
  </tbody>
</table>

<p>The following rule would ensure that a SECTION starts below all preceding
floats and doesn't end until after all floats it contains:
<pre>section {clear: left right after}</pre>
</div>

<p class=issue>Daniel Beardsmore <a
href="http://lists.w3.org/Archives/Public/www-style/2007Feb/0120.html">
proposed</a> a property 'underhang-limit: &lt;count of full lines>' to
protect against the case that the last line of a paragraph (or the
last few lines) is shown under a float. In that case it looks better
to indent that line like the other lines of the paragraph. The default
is '1', i.e., no protection.



<h2>Overflow</h2>

<!-- As per 2009-08-12 telcon, define more precisely what causes
overflow and what doesn't. E.g., exclude shadows and anti-aliasing
from causing overflow, but relatively and absolutely positioned
descendants do cause overflow. -->

<p>When some content of an element is placed outside the element's
content box, the element is said to overflow. This module allows
overflow to be clipped, other modules may add other treatments, e.g.,
scale it down or to scroll it (“marquee,” see [[CSS3-MARQUEE]]).

<h3 id=overflow>The overflow, overflow-x and overflow-y properties</h3>

<p class=issue>In the preceding sections, several things (such as flow
roots) depend on the value of 'overflow'. We probably need to rewrite
them in terms of “overflow-x and/or -y” or similar.

<table class=propdef>
  <tr><td>Name: <td><dfn>overflow-x</dfn>, <dfn>overflow-y</dfn>,
  <tr><td>Value: <td>visible | hidden | scroll | auto | no-display | no-content
  <tr><td>Initial: <td>visible
  <tr><td>Applies to: <td>non-replaced <em>block-level</em> elements
    and non-replaced ''inline-block'' elements
  <tr><td>Inherited: <td>no
  <tr><td>Percentages: <td>N/A
  <tr><td>Media: <td>visual
  <tr><td>Computed value:<td>as specified, except 'visible', see text
</table>

<table class=propdef>
  <tr><td>Name: <td><dfn>overflow</dfn>
  <tr><td>Value: <td>[ visible | hidden | scroll | auto | no-display |
    no-content ]{1,2}
  <tr><td>Initial: <td>see individual properties
  <tr><td>Applies to: <td>non-replaced <em>block-level</em> elements
    and non-replaced ''inline-block'' elements
  <tr><td>Inherited: <td>no
  <tr><td>Percentages: <td>N/A
  <tr><td>Media: <td>visual
  <tr><td>Computed value:<td>as specified, except 'visible', see text
</table>

<p>These properties specify whether content is clipped when it
overflows the element's <em>content area.</em> It affects the clipping
of all of the element's content except any descendant elements (and
their respective content and descendants) whose containing block is
the viewport or an ancestor of the element. 'Overflow-x' determines
clipping at the left and right edges, 'overflow-y' at the top and
bottom edges.

<p>'Overflow' is a shorthand. If it has one keyword, it sets both
'overflow-x' and 'overflow-y' to that keyword; if it has two, it sets
'overflow-x' to the first and 'overflow-y' to the second. Keywords
have the following meanings:

<dl>
  <dt>visible

    <dd>This value indicates that content is not clipped, i.e., it may
    be rendered outside the content box.

  <dt>hidden

    <dd>This value indicates that the content is clipped and that no
    <em>scrolling mechanism</em> should be provided to view the
    content outside the clipping region.

  <dt>scroll

    <dd>This value indicates that the content is clipped and that if
    the user agent uses a <em>scrolling mechanism</em> that is visible
    on the screen (such as a scroll bar or a panner), that mechanism
    should be displayed for a box whether or not any of its content is
    clipped. This avoids any problem with scrollbars appearing and
    disappearing in a dynamic environment. When this value is
    specified and the target medium is ''print'', overflowing content
    may be printed.

  <dt>auto

    <dd>The behavior of the ''auto'' value is UA-dependent, but should
    cause a <em>scrolling mechanism</em> to be provided for
    overflowing boxes.

  <dt class=issue><dfn>no-display</dfn>

    <dd class=issue>When the content doesn't fit in the content box,
    the whole box is removed, as if 'display: none' were specified. 
    [This idea is due to Till Halbach &lt;tillh@opera.com&gt;, July
    21, 2005]

  <dt class=issue><dfn>no-content</dfn>

    <dd class=issue>When the content doesn't fit in the content box,
    the whole content is hidden, as if 'visibility: hidden' were
    specified. [This idea is due to Till Halbach
    &lt;tillh@opera.com&gt;, July 21, 2005]
</dl>

<p>Even if 'overflow' is set to ''visible'', content may be clipped to
a UA's document window by the native operating environment.

<p>UAs must apply the 'overflow' property set on the root element to
the viewport. HTML UAs must instead apply the 'overflow' property from
the BODY element to the viewport, if the value on the HTML element is
''visible''. The ''visible'' value when used for the viewport must be
interpreted as ''auto''. The element from which the value is
propagated must have a used value for 'overflow' of ''visible''.

<p class=issue>The para above is from CSS 2.1. Need to check if the
introduction of overflow-x/y changes anything.

<p>In the case of a scrollbar being placed on an edge of the element's
box, it should be inserted between the inner border edge and the outer
padding edge. The space taken up by the scrollbars affects the
computation of the dimensions in the rendering model.

<p>A UA may use multiple scrolling mechanisms at the same time. E.g.,
if content overflows both to the right and to the bottom, it may use a
marquee effect for the overflow to the right and a scrollbar for the
overflow to the bottom.

<p class=note>Note that a box with 'overflow' other than ''visible''
is a <em>flow root.</em>

<div class=example>
<p>Consider the following example of a block quotation
(&lt;blockquote>) that is too big for its containing block
(established by a &lt;div>). Here is the source:

<pre>
&lt;div>
&lt;blockquote>
&lt;p>I didn't like the play, but then I saw
it under adverse conditions - the curtain was up.&lt;/p>
&lt;cite>- Groucho Marx&lt;/cite>
&lt;/blockquote>
&lt;/div>
</pre>

<p>Here is the style sheet controlling the sizes and style of the
generated boxes:

<pre>
div { width : 100px; height: 100px;
      border: thin solid red;
      }

blockquote   { width : 125px; height : 100px;
      margin-top: 50px; margin-left: 50px; 
      border: thin dashed black
      }

cite { display: block;
       text-align : right; 
       border: none
       }
</pre>

<p>The initial value of 'overflow' is ''visible'', so the
&lt;blockquote> would be formatted without clipping, something like
this:

<div class=figure>
  <p><img src="overflow1" alt="[image: Rendered overflow]">
  <p class=caption>Possible rendering with 'overflow: visible'
</div>

<p>Setting 'overflow' to ''hidden'' for the &lt;div>, on the other
hand, causes the &lt;blockquote> to be clipped by the containing
block:

<div class=figure>
  <p><img src="overflow2" alt="[image: Rendered overflow]">
  <p class=caption>Possible rendering with 'overflow: hidden'
</div>

<p>A value of ''scroll'' would tell UAs that support a visible
scrolling mechanism to display one so that users could access the
clipped content.
</div>

<div class=example>
<p>Consider this case where an absolutely positioned element is mixed
with an overflow parent. Style sheet:

<pre>
container { position: relative; border: solid; }
scroller { overflow: scroll; height: 5em; margin: 5em; }
satellite { position: absolute; top: 0; }
body { height: 10em; }
</pre>

<p>Document fragment: 

<pre>
&lt;container>
 &lt;scroller>
  &lt;satellite/>
  &lt;body/>
 &lt;/scroller>
&lt;/container>
</pre>

<p>In this example, the “scroller” element will not scroll the
“satellite” element, because the latter's containing block is
outside the element whose overflow is being clipped and scrolled.
</div>

<p id=collapse-scroll>The combination of collapsing margins,
'max-height' and ''overflow: auto'' can lead to subtle differences in
implementations, unless special care is taken. A UA should assume that
an element can be rendered <em>without</em> a scrolling mechanism
first, perform all the collapsing of margins, and check that the
content height is indeed less than the 'max-height'. If it is not, the
process is repeated under the assumption that a scrolling mechanism
<em>is</em> needed.

<div class="example">
<p>In the following document fragment, the outer DIV has ''height:
auto'', but ''max-height: 5em''. The inner DIV has large margins and
would normally just fit:

<pre>
...
    #d1 { overflow: auto; max-height: 5em }
    #d2 { margin: 2em; line-height: 1 }
...
&lt;div id=d1&gt;
  &lt;div id=d2&gt;
    This DIV has big margins.
  &lt;/DIV&gt;
&lt;/DIV&gt;
</pre>

<p>If we assume that d1 needs scroll bars, then the height of d1,
including the single line of text and twice 2em of margins, adds
up to 5em plus a scrollbar. Since that is greater than 5em, the
maximum allowed height, it seems we made the right assumption and d1
indeed needs scrollbars.

<p>However, we should have started by assuming that no scrollbars are
needed. In that case the content height of d1 is exactly the maximum
height of 5em, proving that the assumption was correct and d1 indeed
should not have scrollbars.
</div>

<p>The computed values of 'overflow-x' and 'overflow-y' are the same
as their specified values, except that some combinations with
'visible' are not possible: if one is specified as 'visible' and the
other is 'scroll' or 'auto', then 'visible' is set to 'auto'. <span
class=issue>The computed value of 'overflow' is equal to the
computed value of 'overflow-x' if 'overflow-y' is the same; otherwise
it is the pair of computed values of 'overflow-x' and
'overflow-y'.</span>

<p>The <dfn>scrolling mechanism</dfn> depends on the UA. The most
common mechanism is a scrollbar, but panners, hand cursors, page
flickers, etc. are also possible. A value of 'scroll' would tell UAs
that support a visible scrolling mechanism to display one so that
users can access the clipped content. The 'overflow-style' property
lets an author specify one or more preferred scrolling mechanism.

<p class=note>Note that 'overflow-x' and 'overflow-y' did not exist in
CSS2.

<p class=note>Note that 'text-overflow' (see
[[!CSS3TEXT]]) can be used to give a visual indication where text has been
clipped.





<h2>The visibility property</h2>

<table class=propdef>
  <tr><td>Name: <td><dfn>visibility</dfn>
  <tr><td>Value: <td>visible | hidden | collapse
  <tr><td>Initial: <td> visible
  <tr><td>Applies to: <td>all elements
  <tr><td>Inherited: <td>yes
  <tr><td>Percentages: <td>N/A
  <tr><td>Media: <td>visual
  <tr><td>Computed value: <td>as specified
</table>

<p>This property specifies whether the boxes generated by an element
are rendered. Invisible boxes still affect layout (set the 'display'
property to ''none'' to suppress box generation altogether). Values
have the following meanings:

<dl>
  <dt>visible <dd>The generated box is visible.

  <dt>hidden <dd>The generated box is invisible (fully transparent,
  nothing is drawn), but still affects layout. Furthermore,
  descendants of the element will be visible if they have 'visibility:
  visible'.

  <dt>collapse <dd>See the Tables module [[CSS3TBL]]. If used on
  elements other than rows, row groups, columns, or column groups,
  ''collapse'' has the same meaning as ''hidden''.
</dl>



<h2>The alignment property</h2>

<table class=propdef>
  <tr><td>Name: <td><dfn>alignment</dfn>
  <tr><td>Value: <td>top | right | bottom | left | center
  <tr><td>Initial: <td>see text
  <tr><td>Applies to: <td><span>block-level</span> elements
  <tr><td>Inherited: <td>no
  <tr><td>Percentages: <td>N/A
  <tr><td>Media: <td>visual
  <tr><td>Computed value: <td>specified value
</table>

<p class=issue>Another way to allow real centering of boxes would be
to allow 'margin: any' (or 'margin: fill' or some other keyword that
suggest “as large as possible, even if that means negative”) with the
meaning that 'margin: auto' had before CSS 2.1. See
also <a href="/Style/CSS/Tracker/actions/18">ACTION-18</a>
(especially <a
href="http://lists.w3.org/Archives/Public/www-style/2008May/0045.html">
the ideas at end of Bert's comment</a> ), which is continued in
<a href="/Style/CSS/Tracker/issues/53">ISSUE-53.</a>

<p class=issue>For consistency with 'text-align', maybe this should be
called 'block-align'.

<p>This property influences how a block in the normal flow is aligned
in its parent in the inline progression direction. It affects the used
values of 'margin-left' and 'margin-right' (for <em>horizontal</em>
blocks) or 'margin-top' and 'margin-bottom' (for <em>vertical</em>
blocks), as defined in <a href="#Calculating">&ldquo;Calculating
widths, heights and margins.&rdquo;</a>

<p>The initial value depends on both 'block-flow' and 'direction', as
follows:

<table class=equiv-table>
<tr><th>    <th>tb    <th>rl     <th>lr
<tr><th>ltr <td>left  <td>top    <td>top
<tr><th>rtl <td>right <td>bottom <td>bottom
</table>

<p class=note>Note that this property doesn't exist in level 2.

<div class=example>
<p>The 'alignment' property in combination with the ''fit-content''
value of 'width' can be used to make borders that enclose just the
content of a heading, without the need for an additional element:

<pre>
h2 {
  margin-top: 1em;
  margin-bottom: 1em;
  border: solid;
  padding: 0.5em;
  alignment: center;
  width: fit-content}
</pre>

<pre>
<b>&lt;p></b>Lorem ipsum dolor sit amet...
<b>&lt;h2></b>A section heading<b>&lt;/h2></b>
<b>&lt;p></b>Lorem ipsum dolor sit amet...
<b>&lt;h2></b>Another section heading<b>&lt;/h2></b>
<b>&lt;p></b>Lorem ipsum dolor sit amet...
</pre>

<p>See the figure below for a possible rendering.
</div>

<div class=figure>
  <img src="alignment" alt="Image: centered headings with border tightly
  around the text">

  <p class=caption>A possible rendering of the example.
</div>



<h2>The child-align property</h2>

<p class=issue>Other names: block-align (but note that it influences
the children of the block, not the block itself), block-vertical-align
(but note that it really means horizontal if the block's
'block-flow' is ''lr'' or ''rl'').

<p class=issue>Another way to allow centering and other alignments of
boxes would be to allow 'margin: any' (or 'margin: fill' or some other
keyword). See the explanation at the end
of <a
href="http://lists.w3.org/Archives/Public/www-style/2008May/0045.html">
Bert's comment</a>
on <a href="/Style/CSS/Tracker/actions/18">ACTION-18.</a> This is
<a href="/Style/CSS/Tracker/issues/53">ISSUE-53.</a>

<table class=propdef>
  <tr><td>Name: <td><dfn>child-align</dfn>
  <tr><td>Value: <td>top | middle | bottom | left | right | auto
  <tr><td>Initial: <td>auto
  <tr><td>Applies to: <td>block-level elements, table cells and inline blocks
  <tr><td>Inherited: <td>yes
  <tr><td>Percentages: <td>N/A
  <tr><td>Media: <td>visual
  <tr><td>Computed value: <td>the initial value or as specified
</table>

<p>This property describes how block-level content of a block is
aligned vertically, or more precisely: in the block progression
direction. Values have the following meanings:

<dl>
  <dt>top, bottom, left, right <dd>Child blocks are aligned in the
  current block depending on the 'child-align' and 'block-flow'
  as follows:

  <table class=equiv-table>
  <tr><th>   <th>top   <th>bottom <th>left   <th>right
  <tr><th>tb <td>top   <td>bottom <td>top    <td>top
  <tr><th>rl <td>right <td>right  <td>left   <td>right
  <tr><th>lr <td>left  <td>left   <td>left   <td>right
  </table>

  <dt>middle <dd>Child blocks are centered in the block progression
  direction.

  <dt>auto <dd>Child blocks are aligned according to
  'block-flow': at the top if ''tb'', at the right if ''rl''
  and at the left if ''lr''.
</dl>

<p>An element with 'child-align' values other than ''auto'' is
a <em>flow root.</em> Content of such a block is formatted as follows:

<ol>
  <li>Content is laid out as a regular sequence of blocks.

  <li class=issue>To be discussed: If the smallest rectangle that
  encloses all margin boxes of the children (excluding absolutely
  positioned children and counting relatively positioned children as
  if they had zero offset) is bigger in the block progression
  direction than the content box of the current element, then the
  content is placed in that content box as if 'child-align' were
  ''top''.

  <li>The content is shifted such that the rectangle that
  encloses all margin boxes of the children (excluding absolutely
  positioned children and counting relatively positioned children as
  if they had zero offset) touches an edge of the content box. Which
  edge of the rectangle and which edge of the content box is
  determined by the table above. But if 'child-align' is 'middle', the
  rectangle is instead centered in the content box.
</ol>

<div class=note>
  <p>Note that the effect of 'child-align' can also be achieved with
  template layout [[CSS3LAYOUT]]. E.g.,

  <pre>div {child-align: bottom}</pre>

  <p>is the same as

  <pre>div {display: "a"};
div::slot(a) {vertical-align: bottom}</pre>

  <p>except that the latter forces the DIV to be a block, while the
  former leaves the 'display' value of the DIV unchanged (but has no
  effect unless the DIV is block-level).
</div>

<p>When this property applies and is not ''auto'', then
'vertical-align' does not apply. E.g., the placement of the content of
a table cell is determined by 'vertical-align' only if 'child-align'
is ''auto'', otherwise 'child-align' determines the placement.

<p class=issue>Or, alternatively, 'child-align' doesn't apply to
elements that 'vertical-align' applies to, i.e., only to ''block'',
''list-item'', ''inline-block'' and ''run-in'' (under circumstances).

<p>In paged media and in multi-column layout, page breaks and column
breaks are calculated first, then the content is vertically aligned
according to the property within each portion of the parent block.



<h2>Stacking contexts</h2>

<p>This section defines the painting order in more detail than
described in the rest of the specification.

<h3>Definitions</h3>

<dl>
  <dt>Tree Order <dd>Preorder depth-first traversal of the
  <em>rendering</em> tree, in logical (not visual) order for
  bidirectional content, after taking into account properties that
  move boxes around such as the 'run-in' value of 'display'.

  <dt>Element <dd>In this description, “element” refers to actual
  elements, pseudo-elements, and anonymous boxes. Pseudo-elements and
  anonymous boxes are treated as descendants in the appropriate
  places. For example, an outside list marker comes before an
  adjoining '::before' box in the line box, which comes before the
  content of the box, and so forth.
</dl>

<h3>Painting order</h3>

    <p>The bottom of the stack is the furthest from the user, the top
    of the stack is the nearest to the user:

    <div class=figure>
      <p><img src="stack.png" alt="All layers are between the canvas
      and the user">

      <p class=caption>Schematic diagram of a stacking context with
      four layers.
    </div>

<!--
<pre>
	     |	   |	     |	  |
	     |		|    |	  |	&#8678; &#9787;
	     |		|	  |	user
z-index:  canvas  -1	0    1	  2
</pre>
-->

    <p>The stacking context background and most negative positioned
    stacking contexts are at the bottom of the stack, while the most
    positive positioned stacking contexts are at the top of the stack.

    <p>The canvas is transparent if contained within another, and
    given a UA-defined color if it is not. It is infinite in extent
    and contains the root element. Initially, the viewport is anchored
    with its top left corner at the canvas origin.

    <p>The stacking order for an element generating a stacking context
    (see the 'z-index' property) is:

    <ol class=stack>
      <li>
	<p>If the element is a root element:
	<ol>
	  <li>background color of element over the entire canvas.

	  <li>background image of element, over the entire canvas,
	  anchored at the origin that would be used if it was painted
	  for the root element.
	</ol>

      <li>
	<p>If the element is a block, list-item, or other block
	equivalent:
	<ol>
	  <li>background color of element unless it is the root
	  element.

	  <li>background image of element unless it is the root
	  element.

	  <li>border of element.
	</ol>

	<p>Otherwise, if the element is a block level table:
	<ol>
	  <li>table backgrounds (color then image) unless it is the
	  root element.
	  <li>column group backgrounds (color then image).
	  <li>column backgrounds (color then image).
	  <li>row group backgrounds (color then image).
	  <li>row backgrounds (color then image).
	  <li>cell backgrounds (color then image).
	  <li>all table borders (in tree order for separated borders).
	</ol>

      <li>
	<p>Stacking contexts formed by positioned descendants with
	negative z-indices (excluding 0) in z-index order (most
	negative first) then tree order.

      <li>
	<p>For all its in-flow, non-positioned,
	<span>block-level</span> descendants in tree order: If the
	element is a block,
	list-item, or other block equivalent:
	<ol>
	  <li>background color of element.
	  <li>background image of element.
	  <li>border of element.
	</ol>

	<p>Otherwise, the element is a table:
	<ol>
	  <li>table backgrounds (color then image).
	  <li>column group backgrounds (color then image).
	  <li>column backgrounds (color then image).
	  <li>row group backgrounds (color then image).
	  <li>row backgrounds (color then image).
	  <li>cell backgrounds (color then image).
	  <li>all table borders (in tree order for separated borders).
	</ol>

      <li>
	<p>All non-positioned floating descendants, in tree order. For
	each one of these, treat the element as if it created a new
	stacking context, but any positioned descendants and
	descendants which actually create a new stacking context
	should be considered part of the parent stacking context, not
	this new one.

      <li>
	<p>If the element is an inline element that generates a
	stacking context, then:
	<ol>
	  <li>
	    <p>For each line box that the element is in:
	    <ol>
	      <li>Jump to <a href="#each-box">7.2.1</a> for the
	      box(es) of the element in that line box (in tree order).
	    </ol>
	</ol>

      <li>
	<p>Otherwise: first for the element, then for all its in-flow,
	non-positioned, <span>block-level</span> descendants in tree
	order:
	<ol>
	  <li>
	    <p>If the element is a <span>block-level</span> replaced
	    element, then: the replaced content, atomically.

	  <li>
	    <p>Otherwise, for each line box of that element:
	    <ol>
	      <li id=each-box>
		<p>For each box that is a child of that element, in
		that line box, in tree order:
		<ol>
		  <li>
		    <p>background color of element.
		  <li>
		    <p>background image of element.
		  <li>
		    <p>border of element.
		  <li>
		    <p>For inline elements:
		    <ol>
		      <li>
			<p>For all the element's in-flow,
			non-positioned, inline-level children that are
			in this line box, and all runs of text inside
			the element that is on this line box, in tree
			order:
			<ol>
			  <li>
			    <p>If this is a run of text, then:
			    <ol>
			      <li>any underlining affecting the text
			      of the element, in tree order of the
			      elements applying the underlining (such
			      that the deepest element's underlining,
			      if any, is painted topmost and the root
			      element's underlining, if any, is drawn
			      bottommost).

			      <li>any overlining affecting the text of
			      the element, in tree order of the
			      elements applying the overlining (such
			      that the deepest element's overlining,
			      if any, is painted topmost and the root
			      element's overlining, if any, is drawn
			      bottommost).

			      <li>the text.

			      <li>any line-through affecting the text
			      of the element, in tree order of the
			      elements applying the line-through (such
			      that the deepest element's line-through,
			      if any, is painted topmost and the root
			      element's line-through, if any, is drawn
			      bottommost).
			    </ol>

			  <li>
			    <p>Otherwise, jump to <a
			    href="#each-box">7.2.1</a> for that
			    element.
			</ol>
		    </ol>

		    <p>For inline-block and inline-table elements:
		    <ol>
		      <li>For each one of these, treat the element as
		      if it created a new stacking context, but any
		      positioned descendants and descendants which
		      actually create a new stacking context should be
		      considered part of the parent stacking context,
		      not this new one.
		    </ol>

		    <p>For inline-level replaced elements:
		    <ol>
		      <li>the replaced content, atomically.
		    </ol>
		</ol>

		<p class=note>Some of the boxes may have been
		generated by line splitting or the Unicode
		bidirectional algorithm.

	      <li>
		<p>Optionally, the outline of the element (see <a
		href="#outlines">10 below</a>).
	    </ol>

	  <li>
	    <p>Optionally, if the element is <span>block-level,</span>
	    the outline
	    of the element (see <a href="#outlines">10 below</a>).
	</ol>

      <li>
	<p>All positioned descendants with 'z-index: auto' or
	'z-index: 0', in tree order. For those with 'z-index: auto',
	treat the element as if it created a new stacking context, but
	any positioned descendants and descendants which actually
	create a new stacking context should be considered part of the
	parent stacking context, not this new one. For those with
	'z-index: 0', treat the stacking context generated atomically.

      <li>
	<p>Stacking contexts formed by positioned descendants with
	z-indices greater than or equal to 1 in z-index order
	(smallest first) then tree order.

      <li id=outlines>
	<p>Finally, implementations that do not draw outlines in steps
	above must draw outlines from this stacking context at this
	stage. (It is recommended to draw outlines in this step and
	not in the steps above.)
    </ol>

    <h3>Notes</h3>

    <p>The background of the root element is only painted once, over
    the whole canvas.

    <p>While the backgrounds of bidirectional inlines are painted in
    tree order, they are positioned in visual order. Since the
    positioning of inline backgrounds is unspecified in CSS&nbsp;2.1,
    the exact result of these two requirements is UA-defined. CSS3 may
    define this in more detail. <span class=issue>[Replace 2.1 by 3. 
    Check if inline backgrounds are still undefined, otherwise say
    result is UA-dependent.]</span>
















<h3>The &lt;number&gt; value</h3>

<p>A <var>&lt;number&gt;</var> value sets the width or height to that
many times the <em>intrinsic width</em> resp. height of the element. 
The computed value is the number itself.

<p>If a replaced element does not have an intrinsic size or if it has
a <span title="complex width/height">complex relation between width
and height,</span> the used value for 'width: <var>N</var>'
is <var>N</var> × <var>W</var>, where <var>W</var> is 300px or
the <span>largest width that fits the device</span>, whichever is
smaller; the used value for 'height: <var>N</var>' is <var>N</var>
× <var>W/2</var>.

<div class=example>
<p>Here are some examples. Compare the following rules to set the size
of an image, assuming 'height' is ''auto'' in each case:

<pre>img {width: 50px}  /* exactly 50px wide */
img {width: 50%}   /* half as wide as the containing block */
img {width: 50em}  /* 50× the current font size */
img {width: auto}  /* the intrinsic size */
img {width: 1}     /* ditto, i.e., the intrinsic size */
img {width: 0.5}   /* half the intrinsic width */</pre>
</div>

<p class=note>Note that <var>&lt;number&gt;</var> does not exist in
CSS level 2.

<h3 id=auto>The <dfn title="auto!!value of 'width' or
'height'">auto</dfn> value</h3>

<p>We describe the meaning of ''auto'' on elements that
have <em>horizontal flow</em>. Vertical flow is analogous, but with
the roles of 'width' and 'height' interchanged.

<p>On a <em>replaced element,</em> the meaning of ''auto'' depends on
whether the element has an intrinsic size or not, as follows.

<ol>
  <li>
    <p>If the replaced element has an intrinsic width and an intrinsic
    height, then the used value for 'width: auto' is

    <blockquote>
    <p>(intrinsic width)/(intrinsic height) × (used value for height),
    </blockquote>

    <p>The used value for 'height: auto' is

    <blockquote>
    <p>(intrinsic height)/(intrinsic width) × (used value for width),
    </blockquote>

    <p>unless both 'width' and 'height' are ''auto'', in which case
    the used value of the former is the intrinsic width and the used
    value of the latter is the intrinsic height.

  <li>
    <p>If the element has an aspect ratio (but no intrinsic width or
    height, because then it would fall under the preceding case), then
    the used value for 'width: auto' is

    <blockquote>
    <p>(aspect ratio) × (used value for height),
    </blockquote>

    <p>The used value for 'height: auto' is

    <blockquote>
    <p>(used value for width) / (aspect ratio),
    </blockquote>

    <p>unless both 'width' and 'height' are ''auto'', in which case
    the used width is 300px or the maximum width that fits the device,
    whichever is smaller; and the used height is (aspect ratio)
    × (used width).

  <li>
    <p>If the element has an intrinsic width, but no intrinsic height
    and no aspect ratio (i.e., the height can be chosen freely), then
    the value used for 'width: auto' is the intrinsic width and the
    value used for 'height: auto' is 150px or half the maximum
    width that fits the device, whichever is smaller.

  <li>
    <p>If the element has an intrinsic height, but no intrinsic width
    and no aspect ratio, then the value used for 'height: auto' is the
    intrinsic height and the value used for 'width: auto' is 300px or
    the maximum width that fits the device, whichever is smaller.

  <li>
    <p>If the element has a <em title="complex width/height">complex
    relation between width and height,</em> then the used value of
    ''auto'' is the result of
    the <a href="#complex-size">algorithm</a> below.

  <li>
    <p>If the element has no intrinsic width, no intrinsic height, no
    aspect ratio and no relation between width and height, then the
    value used for 'width: auto' is 300px or the <span>largest width
    that fits the device</span>, whichever is smaller; and the value
    used for 'height: auto' is 150px or half the largest width that
    fits the device, whichever is smaller.
</ol>

<p class=note>Examples of replaced elements with an intrinsic size are
most raster images (PNG, JPEG, etc.) and certain <span
class=index>SVG</span> graphics. SVG graphics and other scalable
images may also have just an aspect ratio and no intrinsic width or
height. Certain SVG graphics may have neither an intrinsic size nor an
aspect ratio; they adapt to any width and height. Examples of replaced
elements with a <span title="complex width/height">complex relation
between width and height</span> are HTML files and objects that can
only take certain discrete sizes, such as a command a line that must
be a whole number of characters wide and high.

<p>For non-replaced elements, ''auto'' on 'height' is always
the <em>intrinsic height</em> that corresponds to the element's
computed width. The computed value of ''auto'' on 'width' depends on
the type of box:

<ol>
  <li>If the element is a <em>flow root</em> other than the <em>root
    element</em>, width is the <em>intrinsic width</em>.
  <li>If the element is the <em>root element</em> on paged media, the
    value is the computed width value of the 'size' property.
  <li>Otherwise, if the element is a <em>block-level element</em> and
    its <em>containing block</em> also has a <em>horizontal
    flow</em>, <a href="#eq1">equation (1)</a> below determines the
    width.
  <li>Otherwise, if the element is block-level and the containing
    block has a different <em>writing mode</em>, the computed value is
    the <em>intrinsic width</em>.
  <li>Otherwise (i.e., the element is positioned, is a table element
    or a ruby), see the positioning [[CSS3POS]], table [[CSS3TBL]] or
    ruby [[CSS3RUBY]] modules.
</ol>

<p class=note>Note that in CSS2, floating elements (case 1) were given
a certain small, UA-dependent width, but in CSS3 they are given their
intrinsic width (often referred to as <dfn>"shrink-wrapped"</dfn>).

<p>'Min-width', 'max-width', 'min-height' and 'max-height' impose
further constraints on the computed value.
See <a href="#min-width">below</a>.


<h3 id=complex-size>Algorithm for shrink-wrapping replaced elements
with complex width/height</h3>

<p><span class=issue>Should this algorithm be defined by CDF/WICD
instead? Or by some plug-in API?</span> If the replaced object has a
<em title="complex width/height">complex relation between width and
height,</em> then the CSS UA cannot itself compute the value to use
for ''auto'' or ''shrink-wrap''. Instead, the UA has to ask an
external “oracle”. We assume there is a function that the
CSS UA can call, which takes as input the following parameters:

<ul>
  <li>the object to compute the size of
  <li>the computed value of 'min-width'
  <li>the computed value of 'min-height'
  <li>the computed value of 'max-width'
  <li>the computed value of 'max-height'
  <li>the computed value of 'width'
  <li>the computed value of 'height'
  <li>an auxiliary width
  <li>an auxiliary height
</ul>

<p class=note>Note that most can be of various types:
<var>&lt;length&gt;</var>, <var>&lt;percentage&gt;</var>, ''auto'',
''shrink-wrap'' or ''none''.

<p>The auxiliary width is the width of the <span>containing
block</span> minus this element's margin, padding and border, unless
the containing block's width depends on this element's width, in which
case the width of the viewport is given. The suggested height is
analogous, but using the containing block's height.

<p>The returned values are

<ul>
  <li>The object's preferred width (a <var>&lt;length&gt;</var>)
  <li>The object's preferred height (a <var>&lt;length&gt;</var>)
</ul>

<p>If 'width' is ''auto'' or ''shrink-wrap'', the used width will be

<blockquote>
<p>max(min-width, min(preferred-width, max(min-width, max-width)))
</blockquote>

<p>If 'height' is ''auto'' or ''shrink-wrap'', the used height will be

<blockquote>
<p>max(min-height, min(preferred-height, max(min-height, max-height)))
</blockquote>

<p>If the used width is different from the preferred width, the UA may
call the oracle again with the used width instead of the computed
width in order to get a new value for the preferred height.

<p class=note>Note that the size of the box may still be different
from the object's preferred size. Whether the object resizes to the
box's size or not depends on the object. The 'fit' property determines
how the object is positioned relative to the box if their sizes
differ.

<p>If a CSS UA is used as an oracle, it should behave as follows: The
parameters should be interpreted as the corresponding style rules on
the root element of the object (':root') with specificity 1 at the
start of the author style sheet. The auxiliary width and height should
be interpreted as the size of the viewport.

<div class=example>
<p>The following example of an HTML file with another HTML file
transcluded is rendered with the transclusion taking its full height.
The visual result will be very much as if the trancluded document was
simply a block element in the outer document (except that it doesn't
share its style).

<pre>
...
&lt;style type="text/css">
  object {display: block; width: 100%; height: shrink-wrap}
&lt;/style>
...
&lt;object data="other.html">
  &lt;p>See &lt;a href="other.html">other&lt;/a> document.
&lt;/object>
...
</pre>
</div>

<p class=note>Note that the oracle may need to have access to the
whole object before computing its width and height. E.g., the height
of a transcluded HTML file is only known after the whole file has been
downloaded and formatted. Thus the use of ''shrink-wrap'' may cause a
delay in the rendering of a document, or may cause reflow if the
oracle is called asynchronously.

<p class=note>Note that there was no concept of “complex
width/height” in CSS level 2, so UAs that understand
level 3 will use a different size for transcluded HTML files than
UAs for level 2. In particular, level 2 UAs will render a
300 by 150px block with scrollbars instead of a block that is as big
as neeeded to contain the transclusion.



<h2>The 'float-displace' property</h2>

<table class="propdef">
  <tbody>
    <tr>
      <td><em>Name:</em>
      <td><dfn>float-displace</dfn>
    
    <tr>
      <td><em>Value:</em>
      <td>line | indent | block | block-within-page
    
    <tr>
      <td><em>Initial:</em>
      <td>line
    
    <tr>
      <td><em>Applies to:</em>
      <td>all block-level elements
    
    <tr>
      <td><em>Inherited:</em>
      <td>yes
    
    <tr>
      <td><em>Percentages:</em>
      <td>N/A
    
    <tr>
      <td><em>Media:</em>
      <td>visual
    
    <tr>
      <td><em>Computed value:</em>
      <td>Same as specified value
    
    <tr>
      <td><em>Computed value:</em>
      <td>specified value
    
  </tbody>
</table>

<div class=issue>
<p>Alternative definition, that (1) avoids the need for
'indent-edge-reset' and (2) changes not just the line boxes, but also
the content edge, so that list markers stay close to the content:

<dl>
    <dt>line

      <dd><p>Line boxes are shortened so they don't overlap floats. 
      See <a href="#contour">below</a> for the details. The element's
      margin, border or padding are not influenced by the presence of
      floats. (This is the only behavior in CSS level 2.)

    <dt>indent

      <dd><p>Line boxes are first shortened as for ''line''. If the
      distance between the start edge of the content box and the start
      edge of the line box is then not zero, then that distance is
      further increased by the element's <em>relative indent</em>
      (defined below). Ditto for the end edge. The element's margin,
      border or padding are not influenced by the presence of floats.

    <dt>block

      <dd><p>The margins of the element are increased (and the width thus
      reduced) by the amount necessary so that the border box of the
      element doesn't overlap any floats in the same flow that are
      created by elements earlier in the document; and then the
      margins are increased even more by the amount of the
      <em>relative indent</em> on the relevant side of the element. If
      that causes the element to have more overflow than it would have
      had with a value of ''line'', the element is moved down instead
      (by adding clearance) just enough that it doesn't have more
      overflow, or that its top border edge is just below the bottom
      margin edge of all floats.

      <p>Line boxes inside the element are shortened and/or moved as
      needed the same way as for ''line''.

      <p>Note that floats that are descendants of the element do not
      influence the element's margins, but they may influence the line
      boxes.

    <dt>block-within-page

      <dd><p>Like block, except that the parts of the element on different
      pages are treated as separate blocks for the purpose of this
      property and are only indented as necessary to avoid floats on
      the same page.
</dl>

<p class=note>Note that centered text ('text-align' is ''center'') is
centered relative to the content edges, not relative to the edges of
the line box.

<p class=note>Note also that ''block'' and ''block-within-page''
influence the position of the element's list marker (if any), because
list markers are positioned relative to the content edge. Indeed, this
may be the main reason for using 'float-displace': to move the list
markers from one side of the float (or on top of the float) to the
other side.

<p>A <span>line box</span> normally stretches from an
element's <span>content edge</span> to the opposite content edge,
unless it overflows (see [[!CSS3TEXT]]), but if the element's
'float-displace' is ''line'' or ''indent'' it may fall short of either
or both content edges. The following defines how line boxes are
shortened in the case of ''line'':

<p>For all elements <var>E</var>, and all floats <var>F</var> whose
parent is in the same <span>flow</span> as <var>E</var>, and all <span
title="line box">line boxes</span> <var>L</var> of <var>E</var>: if
<var>L</var> contains any inline boxes that are generated by elements
that come after <var>F</var> in the document, then <var>L</var> must
may not overlap the <em>exclusion zone</em> of <var>F</var>.

<p class=note>Note that a line box next to a float cannot overflow: if
an inline box is too wide for a shortened line box, the line box is
left empty and the inline box is put in the next line box in which it
fits, or the next one that is not shortened by floats. <span
class=issue>[Is this indeed correctly defined in
[[!CSS3TEXT]]?]</span>

<p class=note>Implementation note: Note that the height of a line box
depends on its content. It may be, e.g., that a line box next to a
float has enough room horizontally for three words, but adding the
third word would increase the height of the line box and make it
overlap the next float further down. In that case the third word
cannot be added to that line box and must be put in the next line box
(or even further down).

<p class=mtb>The <dfn>relative indent</dfn> on side <var>S</var> of an
element <var>E</var> is defined recursively as follows:

<ul>
      <li>If <var>E</var> has no parent, or the parent is not in the same
      flow, or the parent's 'float-displace' has a different value
      than <var>E's</var>, then the value is 0.

      <li>Otherwise, the value is the relative indent on side <var>S</var>
      of the parent, plus the computed values of the parent's margin,
      padding and border-width on side <var>S</var>.
</ul>



<p>How <em title="line box">line boxes</em> are constructed is
explained in the CSS Text Module [[!CSS3TEXT]]. The presence of a
float modifies that construction in two ways: the length of the line
box can become shorter (i.e., shorter than the distance between the
element's content edges) and, unlike a normal line box, such a shorter
line box may be empty. The following describes these effects in
detail.

<p>We consider construction of line boxes in <span>horizontal</span>
elements first. (Vertical elements are analogous and are defined
below.) Let <var>L</var> be a line box





     



</div>

<div class=issue>
<p>Yet another alternative. This one adds a fixed indent rather than
one that depends on the context:

<pre>
Value:     auto | &lt;length> && [ block | block-within-page ]?
Inherited: no
</pre>

<dl>
    <dt>auto

      <dd><p>Line boxes are shortened and/or moved so they don't overlap
      floats. (This is the only behavior in CSS level 2.)

    <dt>&lt;length>

      <dd><p>Line boxes are shortened and/or moved as for ''auto'', except
      that the amount they are shortened by, if possible, is equal to
      the amount necessary to not overlap any float plus the given
      &lt;length>.

    <dt>block

      <dd><p>If the keyword ''block'' is present in addition to a
      &lt;length>, the margins of the element are increased (and the
      width thus reduced) by the amount necessary so that the border
      box of the element doesn't overlap any floats in the same flow
      that are created by elements earlier in the document; and then
      the margins are increased even more by the given &lt;length>. If
      that causes the element to have more overflow than it would have
      had with a value of ''auto'', the element is moved down instead
      (by adding clearance) just enough that it doesn't have more
      overflow, or that its top border edge is just below the bottom
      margin edge of all earlier floats in the same flow.

      <p>Line boxes inside the element are shortened and/or moved as
      needed the same was as for ''auto''.

      <p class=note>Note that floats that are descendants of the
      element do not influence the element's margins, but they may
      influence the line boxes.

    <dt>block-within-page

      <dd><p>Like block, except that the parts of the element on
      different pages are treated as separate blocks for the purpose
      of this property and are only indented as necessary to avoid
      floats on the same page.
</dl>

<p class=note>Note that all values, except ''auto'', also cause
centered lines to no longer be centered if they are next to a float.

<p class=note>Note also that ''block'' and ''block-within-page''
influence the position of the element's list marker (if any), because
list markers are positioned relative to the content edge. Indeed, this
may be the main reasons for using 'float-displace': to move the list
markers from one side of the float (or on top of the float) to the
other side.

<div class=example>
<p>Example: Assume that the floating image is tall than the paragraph
it is part of.

<pre>img {float: left}
ul {float-displace: 2em block}
li {margin-left: 2em}</pre>

<p>with document fragment

<pre>
&lt;p>
  &lt;img src=... alt=... style="float: left">
  Paragraph before the list.

&lt;ul>
  &lt;li>First item
  &lt;li>Second item
&lt;/ul>
</pre>

<p>Without the image, the rendering might look like this:

<pre>
Paragraph before the list.

  * First item
  * Second item
</pre>

<p>With the image, but without the rule for 'float-displace', the
output might look like this:

<pre>
+----+Paragraph before the list.
|\  /|
| */ |First item
| *\ |Second item
|/  \|
+----+
</pre>

<p>With the 'float-displace' rule, the UL is indented extra to
avoid the image, plus 2em more:

<pre>
+----+Paragraph before the list.
|\  /|
| \/ |  * First item
| /\ |  * Second item
|/  \|
+----+
</pre>
</div>
</div>

<p>This property determines the line wrapping policy in the presence of
floats. Values have the following meanings:
<dl>
  <dt>line
    <dd>Line boxes should be shortened and moved so as to avoid floats. The
      margin, border, padding and background of the element are not affected
      by floats. (This is the behavior as described in CSS2.) <span
      class=issue>[add description or image?]</span>
  <dt>indent
    <dd>The distance between the margin edge of the floats and the start of
      the line box is set to the distance between the active <em>reference
      indent edge</em> (see the 'indent-edge-reset' property) and the content
      edge of the block box. This ensures that relative indents are preserved
      in the presence of floats.

      <div class="figure">
      <p><img src="float-displace-indent.png"
      alt="Example of lines wrapping around a float individually.">
      <p class="caption">Example of 'float-displace: indent'. Note that the
      “bar” paragraph has the same indent (green arrow) next to the float as
      below it .
      </div>
    
  <dt><dfn title="block!!value of 'float-displace'">block</dfn>
    <dd><p>The containing block's width as used by the horizontal formatting
      model is reduced by the width of the floats intruding upon its content
      area (not taking into account floating descendants or floating elements
      that appear later in the document tree). The block is then flowed in
      this reduced containing block width.
      <p>If the effective containing block width is, by the algorithm given
      above, reduced to a value smaller than the sum of the margin-left,
      border-width-left, padding-left, width, padding-right,
      border-width-right, and margin-right values (treating any 'auto' values
      as zero) then the margin-top of the block is increased until the
      effective containing block width is no longer so constrained or until
      all floats have been cleared, whichever occurs first.

      <div class="figure">
      <p><img src="float-displace-block.png"
      alt="Example of blocks being made narrower because of floats">
      <p class="caption">Example of 'float-displace: block'
      </div>
    
  <dt>block-within-page
    <dd>As for the ''block'' value, but the determination of intrusions that
      adjust the width of the block is done separately on each page on which
      the block appears. Thus, the block may be narrowed on the first page
      due to one or more intrusions, but may expand (or contract) its width
      on subsequent pages with different intrusions. The computed value of
      the 'width' property for this case is...?
</dl>

<div class="example">
<p>A set of rules for HTML might look like this:
<pre>OL, UL, LI {float-displace: indent}
TABLE {float-displace: block}</pre>

<p>Lines in a list will get extra indentation when they are next to a float,
so you can still see that they are part of the list, and tables will be made
narrower as a whole.
</div>

<h2>The 'indent-edge-reset' property</h2>

<table class="propdef">
  <tbody>
    <tr>
      <td><em>Name:</em>
      <td><dfn>indent-edge-reset</dfn>
    
    <tr>
      <td><em>Value:</em>
      <td>none | margin-edge | border-edge | padding-edge | content-edge |
        inherit
    
    <tr>
      <td><em>Initial:</em>
      <td>none
    
    <tr>
      <td><em>Applies to:</em>
      <td>all elements with a block-level inner formatting context.
    
    <tr>
      <td><em>Inherited:</em>
      <td>no
    
    <tr>
      <td><em>Percentages:</em>
      <td>n/a
    
    <tr>
      <td><em>Media:</em>
      <td>visual
    
    <tr>
      <td><em>Computed value:</em>
      <td>specified value
    
  </tbody>
</table>

<p>This property determines which edge to use as the <dfn>reference indent
edge</dfn> when calculating the amount of indent to preserve when the value
of 'float-displace' is set to ''indent''.
<dl>
  <dt><dfn title="none!!value of 'indent-edge-reset'">none</dfn>
    <dd>This block does not introduce a new reference edge.
  <dt>margin-edge
  <dt>border-edge
  <dt>padding-edge
  <dt>content-edge
    <dd>A new reference indent edge is introduced by this block. Which edge
      is used as the reference indent edge is determined by which value is
      given.
</dl>

<p>The reference indent edge is the nearest ancestor in the same formatting
context which has a non-none value for 'indent-edge-reset'. If no ancestor in the formatting
context has a value specified for this property, then the content edge of the
root of the formatting context is used.



<h2>Conformance and profiles</h2>

<p class=issue>Levels&nbsp;1, 2 and 3&hellip;

<p class=issue>UAs that render must either support <em>vertical</em>
      elements or the ''vertical'' media feature.


<h2 id="exit">CR exit criteria</h2>

<p>As described in the W3C process document, a <a
href="http://www.w3.org/2005/10/Process-20051014/tr.html#cfi">Candidate
Recommendation</a> (CR) is a specification that W3C recommends for use
on the Web. The next stage is “Recommendation,” when the
specification is sufficiently implemented.

<p>For this specification to be proposed as a W3C Recommendation, the
following conditions shall be met. There must be at least two
independent, interoperable implementations of each feature. Each
feature may be implemented by a different set of products, there is no
requirement that all features be implemented by a single product. For
the purposes of this criterion, we define the following terms:

<dl>
  <dt>independent <dd>each implementation must be developed by a
  different party and cannot share, reuse, or derive from code
  used by another qualifying implementation. Sections of code that
  have no bearing on the implementation of this specification are
  exempt from this requirement.

  <dt>interoperable <dd>passing the respective test case(s) in the
  official CSS test suite, or, if the implementation is not a Web
  browser, an equivalent test. Every relevant test in the test
  suite should have an equivalent test created if such a user
  agent (UA) is to be used to claim interoperability. In addition
  if such a UA is to be used to claim interoperability, then there
  must one or more additional UAs which can also pass those
  equivalent tests in the same way for the purpose of
  interoperability. The equivalent tests must be made publicly
  available for the purposes of peer review.

  <dt>implementation <dd>a user agent which:

  <ol class="inline">
    <li>implements the specification.

    <li>is available to the general public. The implementation may
    be a shipping product or other publicly available version
    (i.e., beta version, preview release, or “nightly build”). 
    Non-shipping product releases must have implemented the
    feature(s) for a period of at least one month in order to
    demonstrate stability.

    <li>is not experimental (i.e., a version specifically designed
    to pass the test suite and is not intended for normal usage
    going forward).
  </ol>
</dl>

<p>A minimum of sixth months of the CR period must have elapsed. This
is to ensure that enough time is given for any remaining major errors
to be caught.

<p>Features will be dropped if two or more interoperable
implementations are not found by the end of the CR period.

<p>Features may/will also be dropped if adequate/sufficient (by
judgment of CSS WG) tests have not been produced for those feature(s)
by the end of the CR period.



<h2>Acknowledgments</h2>

<p class=issue>To do…

<!--
<p>[acknowledgments. David Baron, Ian Hickson]

<p>David Baron discovered that the assumption about whether a scrolling
mechanism is needed can influence whether it is indeed needed or not. See the
<a href="#collapse-scroll">explanation</a> under <a href="#overflow">"The
overflow property"</a>.

<p>Many people on the www-style@w3.org mailing list provided valuable
reviews, corrections and proposals. Among them, Bj&ouml;rn H&ouml;hrmann deserves
special mention.

<p>[Comments:
<ul>
  <li><a
    href="http://lists.w3.org/Archives/Public/www-style/2001Jul/0167.html">Bj&ouml;rn
    H&ouml;hrmann</a>
  <li><a
    href="http://lists.w3.org/Archives/Public/www-style/2001Jul/0169.html">Jeffrey
    Yasskin</a>
  <li><a
    href="http://lists.w3.org/Archives/Public/www-style/2001Sep/0041.html">Valerie
    G. Sharp</a>
</ul>

<p>]
-->

<h2 class="no-num">References</h2>

<p>Normative references:
<!--normative-->

<p>Informative references:
<!--informative-->



<h2 class="no-num">Index</h2>
<!--index-->



<h2 class="no-num">Property index</h2>
<!--properties-->



<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-minimize-attributes:t
End:
-->
